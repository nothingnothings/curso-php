






NA ÚLTIMA AULA, FALAMOS SOBRE DATA MODELLING,


MAIS ESPECIFICAMENTE 


DATA TRANSFER OBJECTS ('DTOs')...











-> HOJE FALAREMOS SOBRE VALUE OBJECTS (VOs)...








--> ANTES DE FALARMOS SOBRE A TEORIA E FORMAL DEFINITIONS,

    O PROFESSOR QUER MOSTRAR 1 EXEMPLO...









-> SERÁ MT MAIS FÁCIL ENTENDER:



1) WHEN 

2) WHY


3) WHERE 


4) HOW 






DOS VALUE OBJECTS...












-> O EXEMPLO DE HOJE É SOBRE O __ CALCULATE__ DE 

SHIPPING COSTS....















SHIPPING COSTS:





---> TIPICAMENTE,
    PARA CALCULAR 
    O CUSTO DE ENVIO DE 1 PACKAGE,

    ISSO DEPENDE DE ALGUNS FACTORS E VARIABLES...


    ALGUMAS DELAS SÃO:





    1) DIMENSIONS OF THE PACKAGE (width x height x length)


    2) Weight 


    3) distance 


    4) carrier 


    5) speed

    6) value 











--> VAMOS ASSUMIR ALGUNS DOS FATORES 

NESSA LESSON...









-> VAMOS FAZER 1 CÁLCULO BEM SIMPLES,

    PARA NÃO 'GO OUT OF THE SCOPE'..













-->  VAMOS FOCAR APENAS EM ALGUNS FACTORS...





SÃO ELES:



1) PACKAGE DIMENSION 




2) WEIGHT ...











--> USAREMOS ISSO PARA CALCULAR AQUILO QUE CHAMAMOS 

DE 

'BILLABLE WEIGHT'...









BILLABLE WEIGHT...









--> É ALGO USADO POR CARRIERS, PARA 
    CALCULAR O SHIPPING COST DE CADA PACKAGE...











--> O BILLABLE WEIGHT 
É BASEADO EM ALGO CHAMADO DE 


'DIMENSIONAL WEIGHT',

QUE POR SUA VEZ TAMBÉM É CONHECIDO COMO 'DIM Weight'...











--> É BASEADO NO 'DIM WEIGHT' E O 'ACTUAL WEIGHT' 
DA PACKAGE...












--> BILLABLE WEIGHT -->     SEMPRE SERÁ 
                        EQUIVALENTE 


                        AO WEIGHT 

                        MAIOR 

                        ENTRE 

                        O 

                        'DIM Weight' 


                        e 

                        o 

                        'Actual Weight'...






--> POR ISSO, A FÓRMULA É 



max(DIM Weight, Weight);








-> SE O DIM Weight é maior 
    do que o weight da package,

    ele será o billable weight... e vice-versa...














    --> PARA CALCULAR ISSO,





O PROFESSOR CRIOU 1 SERVICE DE 


'BillableWeightCalculatorService',






COM ESTE CÓDIGO:



<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        return 241;
    }
}




ESSE SERVICE CONTÉM 1 ÚNICO METHOD,

'CALCULATE'...






--> É ESSA A CLASS QUE VAI CALCULATAR 
O BILLABLEWEIGHT PARA NÓS...











--> ELE ACEITA AQUELES 5 PARAMS...









-> COM ISSO, ELE DEVE RETORNAR O BILLABLEWEIGHT..








-> COLOCAMOS O TYPE COMO INT, MAS PODERIA 
    SER FLOATS OU STRINGS...








MAS PARA DEIXAR AS COISAS SIMPLES,

COLOCAMOS O RETURN 

DE INT...












--> O PROFESSOR CONSIDERA QUE AS UNITS DAS 
DIMENSIONS SERÃO EM INCHES...



--> JÁ OS WEIGHT SERÃO EM POUNDS...










-> O PROFESSOR HAVIA MENCIONADO QUE A BILLABLEWEIGHT SERÁ 




max(billableWeight, weight)....





o professor vai escrevendo assim:





<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = 0;


        return max($weight, $dimWeight);
    }
}





















A 'DIMWEIGHT',

DIMENSIONAL WEIGHT,



LEVA EM CONSIDERAÇÃO:




WIDTH,
LENGTH,
HEIGHT 


DA PACKAGE...










--> É POR ISSO QUE ESCREVEMOS TIPO ASSIM:



<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = $width * height * length;


        return max($weight, $dimWeight);
    }
}

















-> NO CASO, ESSE VALUE SERÁ DIVIDIDO POR UM 'dimDivisor'...











-> DIMENSION DIVISOR É UM 
    NUMBER QUE SEMPRE É DETERMINADO 

    POR CADA  CARRIER...



 

    FEDEX PODE TER 

    1 DIM DIVISOR DIFERENTE DE USPS, POR EXEMPLO...








-> 

<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = $width * height * length / $dimDivisor;


        return max($weight, $dimWeight);
    }
}


















--> vamos fazer ROUND DO VALUE INTEIRO,

'TO THE NEAREST INTEGER',



e aí 

VAMOS CASTAR TUDO 



COMO SENDO 


INT... pq o return type é de int,



TIPO ASSIM:



<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = (int) round($width * height * length / $dimDivisor);


        return max($weight, $dimWeight);
    }
}













CERTO... TESTAMOS ISSO, PARA VER SE FUNCIONA...








eX:










<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}















o professor também criou um arquivo 

de 



'shipping_calculator_example.php',


QUE USAREMOS PARA 


TESTAR ESSE SERVICE, E PARA DEMONSTRAR O FUNCIONAMENTO 


DOS 'VO' (value objects)....









TIPO ASSIM:







<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\Shipping\BillableWeightCalculatorService;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 139;

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length'],
    $package['weight'],
    $fedexDimDivisor
);















OK...





MAS ISSO É BEM RUIM...







PQ QUANDO INSTANCIAMOS AQUELE SERVICE,

TEMOS DE PASSAR 1 MONTE DE PARAMETERS, 1 ATRÁS DO OUTRO...












-> O CÓDIGO FUNCIONA,

MAS 

É FEIO...













''BUT WHAT IS THE ISSUE, HERE?''













--> PQ DIABOS NÃO PODEMOS USAR ESSA SERVICE CLASS DESSA FORMA AÍ?










--> EM ALGUNS CASES, ESSE CÓDIGO É PERFECTLY FINE,
E FUNCIONARIA...










--> ENTRETANTO, EM OUTROS CASES,
    ESSE CODE _ FALHARIA___...













--> POR EXEMPLO,



''WHAT IF WE 
    _ PASSED __ 
    NEGATIVE VALUES'',


''OR WHAT IF WE PASSED 0 FOR THE DIM DIVISOR???''

 












 -> PARA TESTAR ISSO, DIGAMOS QUE A WIDTH FOI SETTADA COMO '-9',


 tipo assim:












 <?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\Shipping\BillableWeightCalculatorService;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => -9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 139;

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length'],
    $package['weight'],
    $fedexDimDivisor
);















AO FAZER ISSO, 


ficamos com 


'6lb', em vez de '7lb',


no print desse method...









isso aconteceu pq, quando o width, length e height são multiplicados,

o value final fica 





um NÚMERO NEGATIVO..








--> COMO RESULTADO DISSO,




o 'dimWeight' FICA UM NÚMERO NEGATIVO...











E O 'max()' entre um -6 E UM +6 




É UM +6,
OBVIAMENTE....














CERTO....














-> MAS DIGAMOS QUE TEMOS 1 'dimDivisor'

DE 0...









tipo assim:




<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\Shipping\BillableWeightCalculatorService;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 0;

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length'],
    $package['weight'],
    $fedexDimDivisor
);















AO FAZERMOS ISSO,


FICAMOS COM 1 ERROR DE 



'Uncaught DivisionByZeroError: division by zero in BillableWeightCalculatorService'...













OU SEJA,


VÁRIAS COISAS PODEM DAR ERRADO, AQUI,


E NÃO TEMOS NENHUM TIPO DE VALIDATION 

CONTRA ESSES ERROR-CASES...














--> 'WHAT IF WE ALSO WANTED TO HAVE 
    SOME KIND OF 'MAXIMUM ALLOWED PACKAGE DIMENSIONS'? ''










--> OU SEJA,

NÃO QUEREMOS ACEITAR 

NUMBERS COMO '9999999'....













-> UMA MANEIRA DE CONSERTAR ISSO, NO CASO,

É TER 1 VALIDATION...








''THIS VALIDATION 
    CAN EXIST 


    EITHER INSIDE THE SERVICE CLASS,

    OR INSIDE IT, INSIDE THE VERIFY METHOD''...













-> OK... O PROFESSOR REVERTE TUDO PARA OS VALUES ADEQUADOS,
    E AÍ 


    DECIDE ADICIONAR VALIDATION NESSE METHOD DE 'calculate()'... 












EX:




    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
















NO CASO, O PROFESSOR DECIDE USAR UMA MATCH EXPRESSION,

TUDO PARA 

EVITAR TER UM MONTE DE IF-ELSE BLOCKS...










--> PODEMOS ESCREVER ALGO ASSIM:










<?php declare(strict_types=1);

namespace App\Services\Shipping;

class BillableWeightCalculatorService
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}













CERTO...






FAZ SENTIDO, É UMA VALIDATION BÁSICA...





vamos fazer throw da exception, caso qualquer 1 desses values seja 
invalid...













--. AÍ TESTAMOS ISSO..











SIMPLESMENTE PASSAMOS 1 VALUE NEGATIVE 

PARA O width,

TIPO ASSIM:




$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];











COM ISSO, FICAMOS COM A EXCEPTION 

DE 


'Invalid package width',


O QUE QUER DIZER QUE NOSSA VALIDATION FOI UM SUCESSO...











--> O MESMO ACONTECE COM LENGTH E HEIGHT..


TODOS ELES FAZEM THROW DA EXCEPTION CORRESPONDENTE...









-> SE DEIXAMOS O DIM DIVISOR COMO '0',

FICAMOS COM 'Invalid dim divisor'..









QUER DIZER QUE 




ESSA VALIDATION ESTÁ FUNCIONANDO..








-> MAS E QUANTO ÀS 'UNITS'?









--> BEM, O PROFESSOR HAVIA COMENTADO QUE 

    DEVERÍAMOS 
    CONSIDERAR AS UNITS DE DIMENSIONS COMO SENDO EM 'INCHES',


    E AS UNITS DE PESO SEREM EM 'POUNDS'...













--> OK... MAS DIGAMOS QUE QUEREMOS QUE AS MEDIDAS 
    SEJAM EM 'METRIC UNITS',

    EM VEZ DE IMPERIAL UNITS...







--> OU SEJA,

    QUEREMOS KILOGRAMS, METERS, ETC....









-> UMA MANEIRA DE SUPORTAR ISSO 
    SERIA FAZER 

    O 'ACCEPT' DE 
    UNITS 


    COMO _ OUTRO ARGUMENT,

    DENTRO DA FUNCTION DE 'calculate'...









--> A OUTRA ALTERNATIVA SERIA 


DEFINIR 1 PARAMETER DE '$array',







UM ARRAY QUE CONTERIA:


1) AS DIMENSIONS 

2) THE WEIGHT 

3) THE UNIT,


ETC...







-> ISSO SERIA OK, EM SITUAÇÕES MAIS SIMPLES,


    MAS LOGO FICARIA UMA PORCARIA COM 
     
    SITUAÇÕES MAIS COMPLEXAS...










-> QUANDO AS COISAS FICAREM MAIS COMPLEXAS,
    OS REQUIREMENTS VÃO MUDAR,
    TUDO VAI MUDAR...










--> 
O PROFESSOR APONTA QUE 

OS ARGUMENTS 


DE 


'width', 'height', 'length', 'weight' e 'dimDIVISORF'



NÃO SÃO MAIS APENAS 'SCALAR VALUES'..











-> AGORA, NO CASO, HÁ MAIS COISAS ACONTECENDO 
COM ELES ...








 

-> NO CASO, HÁ VALIDATION ENVOLVIDA..







-> PODERIA TER MAIS DE 1 TIPO DE UNIT ENVOLVIDA...





-> PODERIA TER 1 FORMATTING ENVOLVIDO, TAMBÉM...










-> QUER DIZER QUE ESSA INFO NÃO SERÁ APENAS 
    SIMPLES SCALAR VALUES








--> QUER DIZER QUE MAIS INFO É NECESSÁRIA, PARA ESSES ARGUMENTS..











-> SÃO NESSES CASOS QUE 'VALUE OBJECTS'

PODEM SER ÚTEIS:












1) ''WHEN THERE IS NEED FOR ADDITIONAL INFORMATION FOR THE PARAMETERS, 
    AND A SIMPLE SCALAR TYPE IS NO LONGER ENOUGHT''.....





 
2) ''WHEN YOU NEED TO _GROUP_ MULTIPLE ARGUMENTS 
    IN A SINGLE TYPE...''










-> AÍ, NESSES CASOS, 

É QUE 


'VALUE OBJECTS' 

PODEM SER ÚTEIS...







MAS O QUE SÃO ELES?










DEFINIÇÃO:







''A value object is a SMALL OBJECT THAT 

REPRESENTS __ A SIMPLE ENTITY,
 WHOSE EQUALITY IS __ NOT BASED ON IDENTITY (e.g two values 
 are EQUAL when they have the SAME VALUES, not necessarily being 
 the same object, LOOSE OPERATOR...)

''






''Examples of value objects are objects 
    representing an amount of MONEY or a DATE RANGE''...












AS KEYWORDS AQUI SÃO:




1) EQUALITY 



2) ENTITY 


3) IDENTITY...











-> COBRIMOS ENTITIES MAIS CEDO NESSE CURSO,...











-> APESAR DE VALUE OBJECTS SOAREM SEMELHANTES 

A ENTITIES,

HÁ UMA DIFERENÇA ESSENCIAL...












ENTITIES --> SÃO TIPICAMENTE 
            IDENTIFICADOS
            por algo como um 'ID'...












VALUE OBJECT -> 'THEY DON'T HAVE ANY 
                SPECIFIC IDENTIFIER'...










--> ok... quer dizer que são completamente diferentes..






-> ENTITIES SÃO IDENTIFICADOS POR IDs...







-> JÁ AS PROPERTIES 
     DO VALUE OBJECT 

     SÃO SUA 'ACTUAL IDENTIITY',



     JUSTAMENTE POR 'value object'

    NÃO TEREM 1 IDENTIFIER ESPECÍFICO...










--> ENTITIES TAMBÉM GERALMENTE POSSUEM 
    LIFECYCLES....


    EX: SE TEMOS UMA 'PACKAGE' COMO 
        ENTITY, SUAS PROPRIEDADES PODERIAM 
        MUDAR AO LONGO DO TEMPO,


        TIPO ASSIM:


        #[Entity]
        class Package 
        {
            
            #[Id]
            private int $id;

            #[Column]
            private int $width;

            #[Column]
            private int $height;

            #[Column]
            private int $length;

            #[Column]
            private int $weight;
        }
        







--> PODERÍAMOS TER ESSAS PROPERTIES INICIALMENTE,
    MAS MAIS PROPERTIES PODERIAM SER ADICIONADAS,
    DE ACORDO COM AS CARACTERÍSTICAS DA PACKAGE:





        #[Entity]
        class Package 
        {
            
            #[Id]
            private int $id;

            #[Column]
            private int $width;

            #[Column]
            private int $height;

            #[Column]
            private int $length;

            #[Column]
            private int $weight;

            // ... more properties;

            // ... more methods
        }
        
















MAS A PACKAGE IDENTITY 
SEMPRE CONTINUARIA A MESMA, POR CONTA DAQUELE ID...












--> PODERÍAMOS COMPARAR 2 
    PACKAGES POR EQUALITY (strict comparison),


    POR MEIO DE 

    ALGO COMO 


    $package1->id === $package2->id ,




    QUE ISSO SEMPRE RETORNARÁ 
    FALSE, se não forem o mesmo object...











--> QUER DIZER QUE PODEMOS TER 2 PACKAGES COM OS MESMOS 
    VALUES, MAS QUE AINDA SERÃO PACKAGES DIFERENTES...







ex:



$package1 = new Package();

$package1->width = 4;
$package1->length = 8;
$package1->height = 3;
$package1->weight = 5;





$package2 = new Package();

$package2->width = 4;
$package2->length = 8;
$package2->height = 3;
$package2->weight = 5;





persist($package1);
persist($package2);




// Two different packages:
$package->id !== $package2->id;











certo... nesse caso,



os 2 objects 'package' SÃO 

DIFERENTES, SIM...







MAS VC PODERIA CONSIDERAR, POR OUTRO LADO,


QUE A COMBINAÇÃO 



DE 'width - length - height',

nesse exemplo aí,



CONSTITUI UM 'VALUE OBJECT',


JUSTAMENTE PQ 


NÃO IMPORTA SUA IDENTITY, O QUE IMPORTA 
SÃO OS VALUES (que serão os mesmos 
entre suas 2 utilizações, nesse exemplo)











--> ''THIS TYPE OF OBJECTS,
    WHERE THE EQUALITY IS BASED 
    ON ITS _ PROPERTIES' VALUES,

    IS CALLED ''VALUE OBJECTS''....''








EXEMPLO DE VALUE OBJECT:





class Dim
{
    public readonly int $width;
    public readonly int $height;
    public readonly int $length;
}







--> VALUE OBJECTS GERALMENTE REPRESENTAM ALGO:


1) QUANTIFIABLE 


2) MEASURABLE 


3) OR THEY DESCRIBE SOMETHING...






POR EXEMPLO:


-- ADDRESS 

-- EMAIL

-- AMOUNT 

-- DIMENSIONS 

-- AGE 



TODOS ELES PODERIAM SER MODELADOS 


COMO 'VALUE OBJECTS'...








AGORA DEVEMOS VOLTAR AO NOSSO EXEMPLO,

E VER COMO PODEMOS MODELAR 


NOSSOS ARGUMENTS COMO VALUE OBJECTS...










ATUALMENTE, TEMOS ESTE CÓDigo:







<?php declare(strict_types=1);

namespace App\Services\Shipping;

class BillableWeightCalculatorService
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}










HÁ UM PUNHADO DE OPTIONS, AQUI...










PODERÍAMOS OU:


1) CREATE VALUE OBJECTS 
FOR EACH INDIVIDUAL ARGUMENT,


tipo algo assim:







public function calculate(
    Width $width,
    Height $height,
    Length $length,
    int $weight,
    int $dimDivisor
) {

}









OU, ALTERNATIVAMENTE,
PODERÍAMOS AGRUPAR ESSES 3 ARGUMENTS 



EM 1 VALUE OBJECT SÓ,

CHAMADO DE 'Dimensions'...










--> NESSE EXEMPLO,
    EM VEZ DE REPRESENTÁ-LOS COMO SEPARATE
    VALUE OBJECTS,


    VAMOS COMBINÁ-LOS EM 1 ÚNICO VALUE OBJECT,

    DE NOME 'Dimensions'...







TIPO ASSIM:







public function calculate(
    Width $width,
    Height $height,
    Length $length,
    int $weight,
    int $dimDivisor
) {
    
}










-> CRIAMOS ESSE VALUE OBJECT DENTRO DO SERVICE 



DE BillableWeightCalculatorService....







TIPO ASSIM:





<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class PackageDimensions
{
    public function __construct(
        private readonly int $width,
        private readonly int $height,
        private readonly int $length,
    ) {}
}











CERTO... MAS OS VALUE OBJECTS POSSUEM ALGUMAS 
CARACTERÍSTICAS...










ALGUMAS DELAS SÃO:



1) THEY MUST BE _ IMMUTABLE_...




--> É POR ISSO QUE DEIXAMOS ESSAS PROPERTIES 
COMO READONLY...








-> A RAZÃO PARA ELES TEREM DE SER 
    IMMUTABLE É JUSTAMENTE 

    PARA QUE 

    VOCê POSSA 

    ''SHARE VALUE OBJECTS SAFELY''...









TIPO ASSIM:




$dimensions = new PackageDimensions(6, 4, 10);

method_1($dimensions);

method_2($dimensions);


// ... more places that use the same dimensions object.











--> OS VALUE OBJECTS 
    SOLUCIONAM UM PROBLEMA 

    CHAMADO DE 

    'ALIASING BOX',




problema em que 


''WHERE THE SAME PACKAGE DIMENSIONS OBJECT 
    IS PASSED AROUND IN MULTIPLE PLACES,
    AND IN ONE OF THESE PLACES THE PACKAGE 
    DIMENSIONS OBJECT GETS UPDATED (tipo o value 
    de width é alterado, por exemplo),
    THIS WOULD ALSO AFFECT THE OTHER PLACES WHERE 
    THE DIMENSIONS PACKAGE OBJECT WAS USED''...









EX:



$dimensions (original variable) ------------
                                            I
$dimensions (in method_1 function) -------  I  --- [ OBJECT IN MEMORY ]
                                            I
$dimensions (in method_2 function) -------  I 










2) ALÉM DE SEREM IMMUTABLE,
    OUTRA CARACTERÍSTICA DE 'VALUE OBJECTS'

    É QUE ___ ELES DEVEM SER 'VALID BY DEFAULT'...





    -> OU SEJA, VALUE OBJECTS 

    ''ARE ALWAYS ASSUMED TO BE IN A __vALID STATE....''



--> ISSO QUER DIZER QUE PODEMOS 
    COLOCAR VALIDATION METHODS DENTRO 
    DOS VALUE OBJECTS...






--> NO CASO, PODEMOS PEGAR UMA BOA PARTE DA LÓGICA DAQUELE METHOD DE 'calculate',

que tínhamos NO BillableWeightCalculatorService,


e colocar diretamente no value object, tipo assim:
















ISTO:



<?php declare(strict_types=1);

namespace App\Services\Shipping;

class BillableWeightCalculatorService
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}















pegamos isTO:


        match (true) {
            $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };










E COLOCAMOS DENTRO 




DO PACKAGEDIMENSION (value object) object:














<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class PackageDimensions
{
    public function __construct(
        private readonly int $width,
        private readonly int $height,
        private readonly int $length,
    ) {

        match (true) {
            $this->width < 0 || $this->width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $this->height < 0 || $this->height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $this->length < 0 || $this->length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            default => true
        };
    }
}










CERTO...






 











3) VALUE OBJECTS TAMBÉM DEVEM SER 
    'SIDE-EFFECT FREE',



    ou seja,


    NÃO DEVEM GERAR SIDE EFFECTS NO CÓDIGO...














-> DIGAMOS QUE QUEREMOS TER 1 METHOD QUE VAI AUMENTAR AS DIMENSIONS,

TALVEZ ESTE AQUI:






 


public function increaseWidth(int $width)
{
    $this->width += $width;
}











--> TENTAMOS COLOCAR ISSO DENTRO DO VALUE OBJECT:





<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class PackageDimensions
{
    public function __construct(
        private readonly int $width,
        private readonly int $height,
        private readonly int $length,
    ) {

        match (true) {
            $this->width < 0 || $this->width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $this->height < 0 || $this->height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $this->length < 0 || $this->length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            default => true
        };
    }




public function increaseWidth(int $width)
{
    $this->width += $width;
}



}












CERTO... MAS GRAÇAS A READ-ONLY PROPERTIES,

ISSO NÃO É POSSÍVEL, AINDA BEM...












--> ou seja,

VALUE OBJECTS 


NÃO DEVEM PERMITIR ESSE TIPO DE CHANGE...


DEVEM SER TOTALMENTE IMMUTABLE, SUAS PROPERTIES...





ex:







<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class PackageDimensions
{
    public function __construct(
        private readonly int $width,
        private readonly int $height,
        private readonly int $length,
    ) {

        match (true) {
            $this->width < 0 || $this->width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $this->height < 0 || $this->height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $this->length < 0 || $this->length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            default => true
        };
    }

    // ! This is not possible (because of the 'readonly' keyword, on the property), and this is good.
    // public function increaseWidth(int $width)
    // {
    //     $this->width += $width;
    // }
}










e é justamente 







POR ISSO QUE READONLY PROPERTIES SÃO UMA ÓTIMA NOVA FEATURE 
DO PHP8... EVITA SIDE EFFECTS,

PQ EVITA ESSAS CHANGES 

INDESEJADAS....













-> SE VC QUER REALMENTE SUPORTAR 1 METHOD COMO 'increaseWidth()'

EM 1 VALUE OBJECT,



E ENTÃO SER CAPAZ DE AUMENTAR A WIDTH,




''INSTEAD OF TRYING TO MODIFY THE INTERNAL STATE OF THE OBJECT,
    WE CAN SIMPLY RETURN A NEW PACKAGEDIMENSION OBJECT,
    WITH THE INCREASED WIDTH AS THE WIDTH ARGUMENT...
    AND ALL THE OTHER ARGUMENTS WOULD BE THE SAME...''










TIPO ASSIM:











    // * This is possible/correct, because we return a new instance of PackageDimensions, with the new, increased width.
    public function increaseWidth(int $width): self
    {
        return new self($this->width + $width, $this->height, $this->length);
    }











OK... E, ANTERIORMENTE, MENCIONAMOS 'UNITS'...











-> PODEMOS ACEITAR UM 4o parameter nesse constructor de 'PackageDimensions',



algo como 


Unit $unit,







talvez fazer com que isso também seja 1 value object,

ou então 1 enum class...

















-> MAS, EM VEZ DISSO, O PROFESSOR QUER GARANTIR QUE 
    A CONVERSÃO EM 'INCHES' OCORRA EM ALGUM OUTRO LUGAR DO CÓDIGO 

    (metric to inches),



    fora dessa class (value object) de 'PackageDimensions'...









-> NO CASO, QUEREMOS QUE ESSE VALUE OBJECT SEMPRE RECEBA OS VALUES EM 
    INCHES...











--> OK... AGORA FALAREMOS SOBRE EQUALITY, E SOBRE COMO
    VALUE OBJECTS ACABAM COMPARADOS...












--> COMO VC SABE, PARA COMPARAR OBJECTS NO PHP,


    VC SEMPRE USA '==' e '==='...















'==' compara property values, loose...









'===' STRICT COMPARISONM --> compares object identity, in objects...  























'==' --> pode parecer 1 boa maneira para comparar 
        value objects,

        pq 
        VALUE OBJECTS 

        SÃO ___ COMPARADOS USANDO SEUS VALUES...







--> MAS O PROBLEMA, AQUI,


É QUE 


'=='




''WOULD COMPARE ITS __  PROPERTIES__ ALSO 

USING __ THE SAME STRATEGY''...









-> ISSO QUER DIZER, EM OUTRAS PALAVRAS,
    QUE SE TIVERMOS 1 OBJECT/ARRAY 
    DENTRO 

    DE UMA DAS PROPERTIES DE NOSSO 

    VALUE OBJECT,



    ESSA PROPERTY/ARRAY TAMBÉM SERÁ COMPARADO 

    USANDO 

    '==' em vez de '===',
     
     em todas as operations de comparação...















-> O PROFESSOR GOSTA DE SEMPRE USAR STRICT COMPARISONS,

E STRICT TYPES...











--> QUER DIZER QUE, EM VEZ DE USAR '==' 

PARA COMPARAR 2 VALUE OBJECTS,

NÓS VAMOS 




TER ''CUSTOM EQUALITY CHECK METHODS'',


DENTRO DE NOSSOS VALUE OBJECTS...










--> PARA ISSO, CRIAMOS UM NOVO METHOD, DE NOME 

'equalTo()'











-> DENTRO DE ESSE METHOD,

ESCREVEMOS TIPO ASSIM:






public function equalTo(PackageDimensions $other) 
{

    return $this->width === $other->width && $this->height === $other--> 
}









Ex:










    // * This is possible/correct, because we return a new instance of PackageDimensions, with the new, increased width.
    public function increaseWidth(int $width): self
    {
        return new self($this->width + $width, $this->height, $this->length);
    }

    // * This lets us compare two PackageDimensions objects' property valeus, and see if they are equal.
    public function equalTo(PackageDimensions $other) 
    {
        return $this->width === $other->width &&
         $this->height === $other->height &&
        $this->length === $other->length;
    }













CERTO... AGORA DEVEMOS AJUSTAR A CLASS DE SERVICE,






aquela linha que calcula o 'dimWeight',

tipo assim:





<?php declare(strict_types=1);

namespace App\Services\Shipping;

use App\Services\Shipping\PackageDimensions;

class BillableWeightCalculatorService
{
    public function calculate(
        // int $width,
        // int $height,
        // int $length,
        PackageDimensions $packageDimensions,  // * Example of value object usage.
        int $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            // $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            // $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            // $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        // * With value objects:
        $dimWeight = (int) round($packageDimensions->width * $packageDimensions->height * $packageDimensions->length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}















OK... MAS AÍ O PROFESSOR QUER FAZER A MESMA COISA COM 'weight'...










ISSO PQ 'weight'

TAMBÉM PODE SER 1 VALUE OBJECT...








--> ISSO PQ ELE TAMBÉM 
    PODE CONTER UNITS,

    E TAMBÉM PQ PODE TER VALIDATION E ETC...











--> É POR ISSO QUE ESCREVEMOS ASSIM:




class BillableWeightCalculatorService
{
    public function calculate(
        // int $width,
        // int $height,
        // int $length,
        PackageDimensions $packageDimensions,  // * Example of value object usage.
        // int $weight,
        Weight $weight,
        int $dimDivisor
    ): int {


    }






E 



ASSIM:









<?php declare(strict_types=1);

namespace App\Services\Shipping;

class Weight
{
    public function __construct(
        public readonly int $weight,
    ) {

    }

}   













NO CASO,
ESSE 

VALUE OBJECT DE 'WEIGHT'


VAI SER EM POUNDS...









-> COLOCAMOS 1 CHECK 
DENTRO DO CONSTRUCTOR,

checando se o value de weight realmente 

É VÁLIDO, TIPO ASSIM:







<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class Weight
{
    public function __construct(
        public readonly int $weight,
    ) {
        if ($this->weight < 0 || $this->weight > 150) {
            throw new \InvalidArgumentException('Invalid package weight ');
        }
    }

    public function equalTo(Weight $other): bool
    {
        return $this->weight === $other->weight;
    }
}


















OK... 












EX:









<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class Weight
{
    public function __construct(
        public readonly int $value,
    ) {
        if ($this->value < 0 || $this->value > 150) {
            throw new \InvalidArgumentException('Invalid package value ');
        }
    }

    public function equalTo(Weight $other): bool
    {
        return $this->value === $other->value;
    }
}





E:








<?php declare(strict_types=1);

namespace App\Services\Shipping;

use App\Services\Shipping\PackageDimensions;
use App\Services\Shipping\Weight;

class BillableWeightCalculatorService
{
    public function calculate(
        // int $width,
        // int $height,
        // int $length,
        PackageDimensions $packageDimensions,  // * Example of value object usage.
        // int $weight,
        Weight $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            // $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            // $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            // $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            // $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        // ! Without value objects:
        // $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        // * With value objects:
        $dimWeight = (int) round($packageDimensions->width * $packageDimensions->height * $packageDimensions->length / $dimDivisor);

        return max($weight->value, $dimWeight);
    }
}















FINALMENTE,

HÁ ESSE 'dimDivisor',


QUE PRECISAMOS


TRANSFORMAR DE ALGUMA FORMA...










''SHOULD WE PUT THIS INTO A VALUE OBJECT,
OR MAYBE KEEP IT THE WAY IT IS?''





O PROFESSOR NÃO QUER USAR VALUE OBJECTS 


PARA CADA PEQUENA COISINHA DE NOSSO CÓDIGO...













--> O PROFESSOR EXPLICA QUE PODEMOS EXTRAIR ISSO PARA 1 CLASS 

DE 'ENUM',


PQ O DIMDIVISOR É 'KINDOF'


1 VALUE ESTÁTICO...









-> SE TRANSFORMARMOS 
    ISSO EM 1  ENUM CLASS,


    NEM MESMO PRECISAREMOS 

    VALIDATE,


PQ AÍ SÓ ALGUNS VALUES SERÃO ACEITOS (os enums em si),



E AÍ TEREMOS TYPEHINTING...






TIPO ASSIM:










<?php declare(strict_types=1);

namespace App\Services\Shipping;

use App\Enums\DimDivisorEnum;
use App\Services\Shipping\PackageDimensions;
use App\Services\Shipping\Weight;

class BillableWeightCalculatorService
{
    public function calculate(
        PackageDimensions $packageDimensions,  // * Example of value object usage.
        Weight $weight,
        DimDivisorEnum $dimDivisor
    ): int {


















OK... MAS A DEFINITION DO ENUM, EM SI,

SERÁ ASSIM:





<?php

declare(strict_types=1);

namespace App\Enums;

enum DimDivisorEnum: int
{
    case FEDEX = 139;
}

















--> ISSO FEITO, LÁ NA CLASS DE 'BillableWeightCalculatorService',



VAMOS ACESSAR ESSE VALUE ASSIM:





        // * With value objects:
        $dimWeight = (int) round($packageDimensions->width * $packageDimensions->height * $packageDimensions->length / $dimDivisor->value);




OU SEJA,


COM 


'$dimDivisor->value'...





















-> COMO VC PODE VER, NOSSO METHOD 


DE CALCULATE FICOU BEM MAIS SIMPLES,
MAIS READABLE,

E LESS-PRONE A BUGS...



EX:





    public function calculate(
        PackageDimensions $packageDimensions,  // * Example of value object usage.
        Weight $weight,  // * Another example of value object usage.
        DimDivisorEnum $dimDivisor  // * This is an enum. Better type hinting.
    ): int {
        $dimWeight = (int) round($packageDimensions->width * $packageDimensions->height * $packageDimensions->length / $dimDivisor->value);

        return max($weight->value, $dimWeight);
    }








-> MAS VC NÃO DEVE CONVERTER TUDO EM VALUE OBJECTS...


 






-> USE VALUE OBJECTS QUANDO FAZ SENTIDO, NO SEU CÓDIGO...








''THINK IF THERE'S MORE TO THAT OBJECT THAN ITS 
SIMPLE SCALAR VALUE/VALUES''...


















VC TAMBÉM NÃO DEVE CRIAR VALUE OBJECTS 

SÓ PQ 

VC QUER TER CADA OBJECT VALIDATED DENTRO 


DO SEU PRÓPRIO CONSTRUCTOR...

 














--> ''IT'S JUST THAT, SOMETIMES,
    VALUE OBJECTS MAKE MORE SENSE''...














--> VALUE OBJECTS SÃO GERALMENTE USADOS
    E SÃO PARTE 


    DO 'DOMAIN-DRIVEN DESIGN',


    de esse tipo de arquitetura aí...








--> MAS ELES PODEM SER USADOS EM OUTROS TIPOS DE ARQUITETURAS,
    E O PROFESSOR JÁ USOU 

    VALUE OBJECTS EM PROJETOS QUE NÃO ERAM DDD...

















--> O PROFESSOR TESTA O CÓDIGO, PARA VER SE AINDA FUNCIONA...














ELE TESTA TIPO ASSIM:







<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Enums\DimDivisorEnum;
use App\Services\Shipping\BillableWeightCalculatorService;
use App\Services\Shipping\PackageDimensions;
use App\Services\Shipping\Weight;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 139;

// ! Without value objects:
// $billableWeight = (new BillableWeightCalculatorService())->calculate(
//     $package['dimensions']['width'],
//     $package['dimensions']['height'],
//     $package['dimensions']['length'],
//     $package['weight'],
//     $fedexDimDivisor
// );

// * With value objects:
$packageDimensions = new PackageDimensions(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length']
);

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $packageDimensions,
    new Weight($package['weight']),
    DimDivisorEnum::FEDEX
);

echo "Billable Weight: $billableWeight\n";















OK...










AÍ RODAMOS ESSE CÓDIGO, NO TERMINAL,


FICAMOS COM '7lb',


E TUDO FUNCIONA...











AGORA DIGAMOS QUE QUEREMOS CALCULAR O BILLABLE WEIGHT DE ESSA PACKAGE, SIM,

MAS QUANDO ELA É 10 INCHES WIDER...










-> PARA ISSO, ESCREVEMOS o call do method de 'increaseWidth()',

TIPO ASSIM:






<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Enums\DimDivisorEnum;
use App\Services\Shipping\BillableWeightCalculatorService;
use App\Services\Shipping\PackageDimensions;
use App\Services\Shipping\Weight;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];



// * With value objects:
$packageDimensions = new PackageDimensions(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length']
);

$packageWeight = new Weight($package['weight']);

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $packageDimensions,
    $packageWeight,
    DimDivisorEnum::FEDEX
);

echo "Billable Weight: $billableWeight\n";

$packageDimensions2 = new PackageDimensions(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length']
);

$packageDimensions2->increaseWidth(10);

$billableWeight2 = (new BillableWeightCalculatorService())->calculate(
    $packageDimensions2,
    $packageWeight,
    DimDivisorEnum::FEDEX
);

echo "Billable Weight: $billableWeight2\n";
;




















OK... FICAMOS COM 14 lb...




''NOTICE THAT THE ORIGINAL BILLABLE WEIGHT IS UNCHANGED...
THIS IS BECAUSE OF IMMUTABILITY, AND THE SIDE-EFFECT FREE 
VALUE OBJECTS...''





-> QUER DIZER QUE O CALL DE 'increaseWidth()',

AQUI, NÃO ALTERA O WIDTH DO OBJECT 'packageDimensions' 

original... o que é ótimo...
















OK... 









MAS QUAIS SÃO AS DIFERENÇAS ENTRE:







1) ENTITIES 




2) DTOs 





3) VALUE OBJECTS...











VALUE OBJECTS VS ENTITIES


-> ENTITIES SÃO IDENTIFICADAS POR IDs...

--> já VALUE OBJECTS SÃO IDENTIFICADOS APENAS 
     PELO CONJUNTO DE SUAS PROPERTIES... ELAS FORMAM 
     SUA IDENTIDADE, NÃO POSSUEM 'ID'...


--> ENTITIES SÃO MUTABLE, ENQUANTO QUE 'VALUE OBJECTS' 
SÃO __IMMUTABLE E __ SIDE-EFFECT FREE...










DTO VS VALUE OBJECTS:



-- DTOs são apenas 'DATA TRANSFER OBJECTS'...



-- DTOs são sempre DUMMY OBJECTS, CUJO ÚNICO PROPÓSITO 
   É TRANSFERIR DATA DE 1 LADO PARA O OUTRO... O ÚNICO 
   FOCO DESSE OBJECT É 'PLAIN DATA', NÃO TEM NENHUM TIPO DE BEHAVIOR,
   NENHUM TIPO DE LÓGICA (nenhum tipo de validate)...




-- JÁ VALUE OBJECTS PODEM TER 1 POUCO DE LÓGICA NO SEU INTERIOR,
    TAMBÉM BEHAVIORS, PQ PODEM RODAR VALIDATION...