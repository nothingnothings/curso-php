








O PHP 8.1 FOI LANÇADO...











--> O PROFESSOR QUERIA FAZER ESTE VÍDEO,
PARA MOSTRAR ALGUMAS DAS FEATURES NOVAS....



--> QUER MOSTRAR ALGUMAS DAS NOVAS FEATURES, ASSIM COMO 
    MOSTRAR ALGUMAS 

    DAS BREAKING CHANGES...












INSTALL PHP 8.1...










--> A PRIMEIRA COISA QUE TEMOS QUE FAZER É INSTALAR A VERSÃO 8.1...










-> LÁ NO DOCKER, ATÉ AGORA USAMOS A VERSÃO php:8.0.2-fpm....









-> AGORA VAMOS INSTALAR O PHP 
    versão 8.1....











-> ESCREVEMOS TIPO ASSIM:



FROM php:8.1

RUN apt-get update && apt-get install -y \
    git \
    curl \
    zip \
    vim \
    unzip

RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

RUN docker-php-ext-install pdo pdo_mysql

WORKDIR /var/www



















8.1...









--> A VERSÃO '8.1'


AINDA NÃO FOI 'TAGGED',

no momento do vídeo...











-> É POR ISSO QUE VAMOS USAR O 'LATEST RELEASE CANDIDATE',

que é 

o 

rc6 



'RELEASE-CANDIDATE' (abreviação, 'rc')..





Release candidate é uma versão de um software que está
 praticamente pronto para ser colocado no mercado. Também pode ser chamado ape.
























--. OK... É POR ISSO QUE RODAMOS TIPO ASSIM:






php:8.1.0RC6-fpm










-> OK... AÍ RODAMOS 'docker-compose up -d --build'..











-> O PROFESSOR ACHA QUE 8.1-fpm 



VAI FICAR DISPONÍVEL LOGO LOGO, NO DOCKERHUB...





EX:








FROM php:8.1-fpm

RUN apt-get update && apt-get install -y \
    git \
    curl \
    zip \
    vim \
    unzip

RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

RUN docker-php-ext-install pdo pdo_mysql

WORKDIR /var/www









--> CERTO..





AÍ RODAMOS docker exec -it programwithgio-app bash...




-> RODAMOS php -v, para ver a version do php...



ex:


root@f4e788278f9b:/var/www# php -v
PHP 8.1.29 (cli) (built: Aug 13 2024 02:34:07) (NTS)
Copyright (c) The PHP Group
Zend Engine v4.1.29, Copyright (c) Zend Technologies




certo, funcionou...









DEPOIS DISSO...






O PROFESSOR NOS FALA DAS FEATURES DO PHP 8.1...











FEATURES:









1) ARRAY UNPACKING, 'BUT WITH ___STRING__ KEYS__...'









-->  EX:






<?php declare(strict_types=1);

$array1 = [1, 2, 3];
$array2 = [4, 5, 6];

$array3 = [...$array1, ...$array2];

print_r($array3);








O RESULTADO FICA ASSIM:




Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
    [5] => 6
)








ISSO NÃO É UMA FEATURE NOVA... É CHAMADA DE 'ARRAY UNPACKING'...









-> BASICAMENTE, VC PODE FAZER SPREAD OPERATOR 
DOS ARRAYS, DENTRO DE 1 NOVO ARRAY...








--> ANTES DO PHP 8.1,   

    SÓ ERA POSSÍVEL CRIAR O ARRAY NOVO 


    COM KEYS DE TIPO 'INDEX' comum (numbers, numeric)...









--> MAS, AGORA, COM O PHP 8.1,

    É POSSÍVEL FAZER ARRAY UNPACKING USANDO ASSOCIATIVE 
    ARRAYS 


    COM 


    STRING KEYS...






tipo assim:









<?php declare(strict_types=1);

// * This is an example of a COMMON array unpacking (without associative arrays, and without strings as keys). - This works on all php versions.
// $array1 = [1, 2, 3];
// $array2 = [4, 5, 6];

// $array3 = [...$array1, ...$array2];

// print_r($array3);

// * This is an example of a ARRAY unpacking, but WITH associative arrays, with strings as keys. THIS WORKS ONLY ON PHP 8.1+.
$array1 = ['a' => 1, 'b' => 2, 'c' => 3];
$array2 = ['d' => 4, 'e' => 5, 'f' => 6];
$array3 = [...$array1, ...$array2];
print_r($array3);






se rodamos no php 8.1,

o print vai ficar assim:






Array
(
    [a] => 1
    [b] => 2
    [c] => 3
    [d] => 4
    [e] => 5
    [f] => 6
)












FICAMOS COM ESTE ERROR, SE TENTAMOS EXECUTAR COM 1 PHP ANTIGO (antes do php 8.1):




Fatal error: Uncaught Error: Cannot unpack array with string keys in D:\PROJETO20-PHP-FROM-THE-GROUND-UP\MODULE-3\php-8.1\app\array-unpacking-example.php:15
Stack trace:
#0 {main}
  thrown in D:\PROJETO20-PHP-FROM-THE-GROUND-UP\MODULE-3\php-8.1\app\array-unpacking-example.php on 
line 15

























ok...





se rodamos isso dentro do nosso docker container,

funciona sem problemas,

justamente 



PQ 

ELE ESTARÁ NA VERSION 8.1..











--> O PROFESSOR ENTÃO NOS MOSTRA 1 SITE ÚTIL PARA RODAR SNIPPETS DE CODE 
PHP,

CHAMADO 


DE 




'3v4l.org'...
















ex:



https://3v4l.org/









-> VC PODE ESCOLHER QUALQUER VERSION DO PHP,

PARA AÍ TESTAR CODE SNIPPETS E COMPATIBILITY...















-> VAMOS USAR 8.0,

para mostrar que isso não funciona, essa feature de 'unpack array with string keys'...















CERTO... O PROFESSOR ENTÃO NOS DÁ OUTRA DICA:














'''NOTE THAT ARRAY UNPACKING WITH STRING KEYS WORKS 
    __ SIMILARLY TO __ ARRAY_MERGE()...''









''THE SIMILARITY IS THAT 
    ""THEY WILL OVERRIDE, IF BOTH ARRAYS HAVE THE SAME 
      STRING KEYS..."" ''








-> TIPO ASSIM:




$array1 = ['a' => 1, 'b' => 2, 'c' => 3];
$array2 = [4, 'b' => 5, 6];
$array3 = [...$array1, ...$array2];
print_r($array3);











NESSE EXEMPLO,


QUANDO FIZERMOS O UNPACK 



DOS 2 ARRAYS, O VALUE DE 'b' do SEGUNDO ARRAy 

        VAI FAZER OVERWRITE DO VALUE DE 'b' DO PRIMEIRO ARRAY...









OU SEJA, ISSO FUNCIONA DE FORMA SIMILAR AO 'ARRAY_MERGE'...









--------------------------------------














A PRÓXIMA FEATURE QUE DEVEMOS VER É 'ENUMERATIONS'...











2) ENUMERATIONS: 





--> FINALMENTE ESTAMOS FICANDO COM NATIVE ENUM SUPPORT NO PHP...







--> É UMA DAS FEATURES NOVAS FAVORITAS DO PROFESSOR...








--> ELE QUER NOS ENSINAR TUDO SOBRE ISSO...








--> MAS ELE QUER SEPARAR 1 VÍDEO INTEIRO PARA ESSE TÓPICO...









-> AGORA ELE SÓ VAI NOS MOSTRAR 1 INTRO RAPIDO...
















ENUMS:








---> '''THEY BASICALLY LET YOU _ HAVE FIXED__ 
        SETS__ OF POSSIBLE VALUES...'''










na minha cabeça, enums possuem este formato:



[val1, val2],



MAS PODERIA ESTAR ERRADO...








Ah... acho que me lembro...





um value é associado como o outro, ou algo assim...














->  EU JÁ VI CÓDIGOS COMO ESTE (como diz o professor):





class PaymentStatus 
{
    public const PAID = 1;
    public const VOID = 2;
    public const DECLINED = 3;
}












-> EM QUE TEMOS A DEFINÇÃO DE 'CONSTS,

e aí 

O USO DESSAS CONSTS,

AO LONGO DE NOSSA CODEBASE,


PARA SUBSTITUIR VALUES/STRINGS HARDCODADAS...













-> UM DOS PROBLEMAS COM ESSE APPROACH É:




''''YOU CANNOT REALLY __ TYPEHINT THIS,
    WHEN THIS IS PASSED AS AN ARGUMENT''''









--> NO CASO, IMAGINE ESTE EXEMPLO:




(index.php):




<?php declare(strict_types=1);

use PHP_8_1_Examples\Enum\Payment;
use PHP_8_1_Examples\Enum\PaymentStatus;

require_once __DIR__ . '/../../vendor/autoload.php';

$payment = new Payment();

$payment->updateStatus(PaymentStatus::PAID);

echo $payment->status() . PHP_EOL;






(Payment.php):





<?php declare(strict_types=1);

namespace PHP_8_1_Examples\Enum;

class Payment
{
    private int $status;

    public function updateStatus(int $status): Payment
    {
        $this->status = $status;

        return $this;
    }

    public function status(): int
    {
        return $this->status;
    }
}









(PaymentStatus.php):










<?php declare(strict_types=1);

namespace PHP_8_1_Examples\Enum;

class PaymentStatus
{
    public const PAID = 1;
    public const VOID = 2;
    public const DECLINEDD = 3;
}














-> NO CASO,





NÓS SEMPRE ESTAMOS CHAMANDO O METHOD DE 'updateStatus'



com 1 value NUMÉRICO,





isso pq 

'PaymentStatus' SÓ TEM AQUELAS 3 CONST...








-> ENTRETANTO, AQUELA FUNCTION ,


updateStatus,

está com o argument TIPADO Como sendo de tipo 'int',


E ISSO 

_ NÃO NOS DIZ NADA 


SOBRE QUE TIPO DE VALUES PODEM SER PASSADOS...















QUER DIZER QUE ISSO É RUIM DE LER...






--> OUTRO PROBLEMA, NO CASO,

É QUE QUALQUER OUTRO STATUS PODERIA SER PASSADO, AQUI,

ALÉM DE 

'1' '2' ou '3'.... E  ISSO AINDA PASSARIA, não iria fail.. a não ser que tenhamos alguma validation
                                                                            EXPLÍCITA DENTRO 
                                                                            DESSE METHOD,

                                                                            PARA CHECAR 


                                                                            POR 

                                                                            1 2 ou 3...






NO CASO, O QUE NÃO QUEREMOS É QUE O DEVELOPER SEJA CAPAZ DE 

RODAR ALGO COMO 



'''''
$payment->updateStatus(5);
'''''







-> É POR ISSO QUE ENUMS SÃO ÚTEIS,
    É PQ AÍ PODEREMOS TIPAR ISSO COMO 'PaymentEnums',

    ou algo assim....














--> É POR ISSO QUE DEVEMOS TIPAR O 'PaymentStatus
    COMO ENUMS,,

    para conseguirmos tipar o argument $status de 'updateStatus'...





TIPO ASSIM:




<?php declare(strict_types=1);

namespace PHP_8_1_Examples\Enum;

// ! Without enums:
// class PaymentStatus
// {
//     public const PAID = 1;
//     public const VOID = 2;
//     public const DECLINED = 3;
// }

// With enums:
class PaymentStatus {}

















E a sintaxe dos ENUMS É PARECIDA COM A SINTAXE DAS CLASSES...







MAS, EM VEZ DE TER A KEYWORD DE 'Class', como nessa parte aí,


TEMOS A KEYWORD DE 'enum',


TIPO ASSIM:






// With enums:
enum PaymentStatus {}















CERTO... E É POSSÍVEL 

TER 


AS CONSTANTS DENTRO Do 'enum' em si...



isso ainda vai funcionar,

MAS, EM VEZ DE 

USAR CONSTANTS,




VC PODE/DEVE 


USAR ALGO CHAMADO DE 'CASES'...












-> É POR ISSO QUE SUBSTITUÍMOS TODAS AS CONSTS POR 'case'...





TIPO ASSIM:








// With enums (we use 'case', instead of 'const'):
enum PaymentStatus {
    case PAID = 1;
    case VOID = 2;
    case DECLINED = 3;
}

















COMO VC PODE VER, É PARECIDO COM 1 CLASS NORMAL...








SEMELHANÇAS:




1) IT HAS NAMESPACES 


2) YOU CAN DECLARE STRICT TYPES 


3) CAN BE AUTOLOADED 



4) CAN IMPLEMENT INTERFACES 



5) CAN HAVE METHODS...


6) ETC...












->_ MAS O QUE É 'case'?







-- 'case'  -------> '''IT'S KINDA LIKE AN OBJECT OF THE __          
                        ENUM CLASS ITSELF...''








-> QUER DIZER QUE 

'PAID', esse case aí,



é apenas um 


OBJECT 

da 'Class' de 'PaymentStatus'...














-> QUER DIZER QUE ISSO NÃO DEIXA DE SER UM PaymentStatus OBJECT...









-> podemos testar isso, por meio do VAR_DUMP 
    de 1 value,


    TIPO ASSIM:






var_dump(PaymentStatus::PAID);












--> ISSO, NO CASO,



NOS PRINTA 




ISTO AQUI:






'enum(PHP_8_1_Examples\Enum\PaymentStatus::PAID
)'










-> QUER DIZER, ENTÃO, QUE ISSO É SIMPLESMENTE 
    UM ENUM OBJECT, COM A CASE DE 'PAID'...








-> MAS A COISA LEGAL, AQUI,

    É QUE PODEMOS FAZER O SIMPLES TYPEHINT 

    DAQUELE METHOD DE 'updateStatus()',


    PARA DIZER QUE 

    O 



ARGUMENT PASSADO A ESSE METHOD __ DEVE_ SER 1 INSTANCE 


DE 

'PaymentStatus',

de esse enum aí...








TIPO ASSIM:








    // * Example with enum usage ($status can be typed as an enum, like 'PaymentStatus')
    public function updateStatus(PaymentStatus $status): Payment
    {
        $this->status = $status;

        return $this;
    }





    TIPO ALGO ASSIM...
















no caso, o código completo fica assim:









<?php declare(strict_types=1);

namespace PHP_8_1_Examples\Enum;

class Payment
{

    // * With enums:
    private PaymentStatus $status;



    // * Example with enum usage ($status can be typed as an enum, like 'PaymentStatus')
    public function updateStatus(PaymentStatus $status): Payment
    {
        $this->status = $status;

        return $this;
    }

    public function status(): PaymentStatus
    {
        return $this->status;
    }
}















-> CERTO...





AÍ, SE TENTARMOS PASSAR 1 ARGUMENT INVÁLIDO, COMO '5',

FICAMOS IMEDIATAMENTE COM UM ERROR...




-> FICAREMOS COM 1 ERROR JUSTAMENTE PQ TIPAMOS 
    QUE O VALUE DEVERÁ SER DE TYPE 'PaymentStatus',

    MAS ESTAMOS PASSANDO 1 INT...











EX:








<?php declare(strict_types=1);

use PHP_8_1_Examples\Enum\Payment;
use PHP_8_1_Examples\Enum\PaymentStatus;

require_once __DIR__ . '/../../vendor/autoload.php';

$payment = new Payment();

// $payment->updateStatus(PaymentStatus::PAID);  // Without enums.

// $payment->updateStatus(5);  // Without enums - this is bad, will cause errors, which can be avoided by using enums.

$payment->updateStatus(5);

$payment->updateStatus(PaymentStatus::PAID);

echo $payment->status() . PHP_EOL;






















CERTO... COM ISSO, SOMOS __ FORÇADOS__ A USAR ALGUM DOS CASES,

DENTRO DE 'PaymentStatus' enum...





PRECISAMOS 


USAR OS CASES COMO SE ESTIVÉSSEMOS USANDO CONSTANTS,


TIPO ASSIM:



$payment->updateStatus(PaymentStatus::PAID);













-> ESTAREMOS BASICAMENTE 
    USANDO ISSO COMO SE FOSSE 1 CONSTANT DE UMA CLASS CHAMADA DE 'PaymentStatus',

    apesar de ser, realmente,
    um ENUM...












---> OK... MAS É CLARO QUE SÓ ESCREVER OS NOMES DOS CASES NÃO É O SUFICIENTE...





NÃO É O SUFICIENTE APENAS ESCREVER ALGO ASSIM:







// With enums (we use 'case', instead of 'const'):
enum PaymentStatus {
    case PAID;
    case VOID;
    case DECLINED;
}










NÃO, PQ ISSO SERÁ 
APENAS 1 OBJECT, O PRÓPRIO OBJECT DE 'PaymentStatus'...









-> PARA QUE ISSO TENHA ALGUM PROPÓSITO,

VC PRECISA DEFINIR 1 VALUE PARA CADA CASE...









-> TIPO ALGO ASSIM:




// With enums (we use 'case', instead of 'const'):
enum PaymentStatus {
    case PAID = 1;
    case VOID = 2;
    case DECLINED = 3;
}




















--> ALÉM DISSO, CADA 

'case' 
DENTRO 



DOS OBJECTS 'enum'


POSSUI UMA PROPERTY DE nome '->name()',




QUE SERVE PARA SIMPLESMENTE 'GET THE NAME OF THE CASE'...












-> NO NOSSO CASO, SE QUISERMOS PEGAR O VALUE DE 'PAID' (a string 'PAID'),



a partir do case de nome 'PAID',




BASTA ESCREVER 





ASSIM:






echo $payment->status()->name . PHP_EOL;











EX:








<?php declare(strict_types=1);

use PHP_8_1_Examples\Enum\Payment;
use PHP_8_1_Examples\Enum\PaymentStatus;

require_once __DIR__ . '/../../vendor/autoload.php';

$payment = new Payment();

// $payment->updateStatus(PaymentStatus::PAID);  // Without enums.

// $payment->updateStatus(5);  // Without enums - this is bad, will cause errors, which can be avoided by using enums.

$payment->updateStatus(5);  // This will fail

$payment->updateStatus(PaymentStatus::PAID);

// echo $payment->status() . PHP_EOL;

echo $payment->status()->name . PHP_EOL;  // each enum has a 'name' property, which can be used to get the NAME of the enum, as a string value.
















-> ISSO VAI PRINTAR 'PAID'...











ALÉM DISSO,



O PROFESSOR DESTACA:





""" ''enum'' classes can have METHODS on THEM...  ''''






--> QUER DIZER QUE PODEMOS ESCREVER/ADICIONAR METHODS DIRETAMENTE 
    NOS NOSSOS ENUMS, E, ENTÃO,

    FAZER __ CALL_ DE ESSES METHODS...













-> DIGAMOS QUE  
    QUEREMOS 


    ''A METHOD TO RETURN THE 
        TEXTUAL REPRESENTATION OF
        THE _ 'PaymentStatus'...''









-> É POR ISSO QUE O PROFESSOR ESCREVE ASSIM:






public function text(): string 
{

}











-> AÍ, DENTRO DISSO, O PROFESSOR DECIDE USAR 1 MAGIC METHOD...









--> ELE RODA 'return match($this)'...








--> NO CASO, ELE USA '$this'

PQ ESTAMOS DENTRO 
DO OBJECT DE 

'PAID' (o case de 'PAID')...






tipo assim:







// With enums (we use 'case', instead of 'const'):
enum PaymentStatus {
    case PAID;
    case VOID;
    case DECLINED;


    public function text(): string 
    {

        return match($this) {
            self::PAID => 'Paid',
            self::VOID => 'Void',
            self::DECLINED => 'Declined'
        };
    }


}















CERTO...





COM ISSO, 







BASTA CHAMAR ESSE METHOD,


TIPO ASSIM:








echo $payment->status()->text() . PHP_EOL;








Ex:








// With enums (we use 'case', instead of 'const'):
enum PaymentStatus {
    case PAID;
    case VOID;
    case DECLINED;

    // Custom method example:
    public function text(): string 
    {
        return match($this) {
            self::PAID => 'Paid',
            self::VOID => 'Void',
            self::DECLINED => 'Declined'
        };
    }
}








ISSO É BOM, SIM, MAS 

NOSSOS ENUM CASES 


NÃO POSSUEM QUAISQUER DEFAULT VALUES ASSOCIADOS A ELES....













-> PARA DEFINIRMOS DEFAULT VALUES, É A MESMA COISA DE SEMPRE,
VISTA COM CONSTANTS,


TIPO ASSIM:







    case PAID = 1;
    case VOID = 2;
    case DECLINED = 3;










--> A GRANDE VANTAGEM É QUE PODEMOS TIPAR...










-> MAS SE TENTAMOS DEFINIR ESSES VALUES COMO OS VALUES DE NOSSOS 
CASES,


FICAMOS 



COM 1 MENSAGEM DE ERROR NO VSCODE:






''Case of non-backed enum MUST NOT HAVE A VALUE...''


















''NON-BACKED'' --> É O TERMO-CHAVE, AQUI...

                    VEREMOS MAIS INFO SOBRE 'BACKED' 

                    E 'NON-BACKED' 

                    ENUMS 

                    NAQUELA AULA SEPARADA...







-> BASICAMENTE, O QUE O VSCODE ESTÁ 
    RECLAMANDO É 



''' BECAUSE WE DEFINED THESE DEFAULT VALUES OF 
    THE CASES, WE ACTUALLY NEED TO TELL __ THE 
    enum class WHAT THE ACTUAL _ TYPES OF _ THE 
    VALUES ARE...'''


    '''AND YOU CANNOT HAVE MULTIPLE TYPES (union),
     THEY MUST BE EITHER INTEGER OR  _STRING_...'' 






A MANEIRA PARA DEFINIR/TELL QUAL SERÁ O TYPE DOS VALUES 
DOS CASES 


É 

ESCREVER 


'enum PaymentStatus: int',



LÁ NA DEFINIÇÃO DO ENUM,

TIPO ASSIM:





enum PaymentStatus: int {
    case PAID = 1;
    case VOID = 2;
    case DECLINED = 3;

    // Custom method example:
    public function text(): string 
    {
        return match($this) {
            self::PAID => 'Paid',
            self::VOID => 'Void',
            self::DECLINED => 'Declined'
        };
    }
}















ex:







enum PaymentStatus: int {
















--> COMO VC PODE VER,

O UNDERLINING VAI SUMIR...











OK... DEFINIDOS ESSES DEFAULT VALUES,

A PERGUNTA AGORA É 




'''HOW WE CAN ACTUALLY ACCESS THESE DEFALT VALUES???'''









-> É POSSÍVEL ACESSAR ESSES VALUES 

    POR MEIO 

    DO ACCESS DA PROPERTY CHAMADA DE 



    '->value()', no object de 'enum',



TIPO ASSIM:









$payment->status()->value . PHP_EOL;









EX:





$payment = new Payment();

$payment->updateStatus(PaymentStatus::PAID);

echo $payment->status()->value . PHP_EOL;  // each enum has a 'value' property, which can be used to get the VALUE of the enum, as an integer value.










NO CASO, RODAMOS O CÓDIGO E FICAMOS COM '1',

que é o value de 'PAID'...







-------------------










DEPOIS DISSO, TEMOS OUTRA FEATURE... A DE 'READONLY PROPERTIES'...













3) READONLY PROPERTIES:










--> É OUTRA DAS FEATURES FAVORITAS DO PROFESSOR...








---> VC PODE, AGORA, MARCAR SUAS PROPERTIES COMO 

    'READONLY',


    O QUE SIGNIFICA QUE,


    ''ONCE A PROPERTY HAS BEEN SET, FOR THE FIRST TIME,

    IT __ CANNOT BE OVERWRITTEN AFTERWARDS...''


















O NOSSO CÓDIGO-EXEMPLO É TIPO ESTE:











<?php declare(strict_types=1);

use PHP_8_1_Examples\ReadOnlyProperty\Address;

require_once __DIR__ . '/../../vendor/autoload.php';

$address = new Address(
    '123 Main Street',
    'Anytown',
    'CA',
    '90210',
    'USA'
);

echo $address->getStreet() . PHP_EOL;











Address.php:






<?php declare(strict_types=1);

namespace PHP_8_1_Examples\ReadOnlyProperty;

class Address
{
    private string $street;
    private string $city;
    private string $state;
    private string $postalCode;
    private string $country;

    public function __construct(string $street,
        string $city,
        string $state,
        string $postalCode,
        string $country)
    {
        $this->street = $street;
        $this->city = $city;
        $this->state = $state;
        $this->postalCode = $postalCode;
        $this->country = $country;
    }

    public function getStreet(): string
    {
        return $this->street;
    }

    public function getCity(): string
    {
        return $this->city;
    }

    public function getState(): string
    {
        return $this->state;
    }

    public function getPostalCode(): string
    {
        return $this->postalCode;
    }

    public function getCountry(): string
    {
        return $this->country;
    }
}












-> ANTES DO PHP8,

UM 

DTO (Data Transfer Object) TÍPICO,


OU QUALQUER CLASS COM GETTERS,




TERIA 

1 FORMATO PARECIDO COM 


O VISTO LOGO ACIMA...














--> TEMOS 1 CLASS TÍPICA,

    COM 1 MONTE DE PROPERTIES,

    AÍ VC 
    SETTA ESSAS PROPERTIES NO CONSTRUCTOR,

    E AÍ 


    VC TEM 1 MONTE DE GETTERS..














--> JÁ NO PHP 8.0,

BEM MAIS TARDE,


AGORA 

TEMOS 'PROMOTED PROPERTIES',

O QUE QUER DIZER QUE 


PODEMOS DEIXAR ESSE CÓDIGO INTEIRO BEM MAIS CONCISO,

AO ESPECIFICAR TUDO NO CONSTRUCTOR,

TIPO ASSIM:










<?php declare(strict_types=1);

namespace PHP_8_1_Examples\ReadOnlyProperty;

class Address
{
    public function __construct(private string $street,
        private string $city,
        private string $state,
        private string $postalCode,
        private string $country) {}

    public function getStreet(): string
    {
        return $this->street;
    }

    public function getCity(): string
    {
        return $this->city;
    }

    public function getState(): string
    {
        return $this->state;
    }

    public function getPostalCode(): string
    {
        return $this->postalCode;
    }

    public function getCountry(): string
    {
        return $this->country;
    }
}












COM ISSO,



REMOVEMOS 1 BOA PARTE DE NOSSO BOILER PLATE CODE...











-----> O PROBLEMA, AQUI, É QUE AINDA TEMOS 

TODOS AQUELES GETTERS...











É CLARO QUE PODERÍAMOS MARCAR 
ESSAS PROPERTIES COMO 'PUBLIC',


PARA NOS LIVRAR DESSES GETTERS INTEIROS...







--> MAS ISSO SERIA MT RUIM, PQ IRIA 'MESS UP THE ENCAPSULATION',

    E PODERIA INTRODUZIR PROBLEMAS EM POTENCIAL,



    EM QUE 

    ''PEOPLE COULD CHANGE THE DATA OF THE OBJECT,
    WHEN THAT SHOULD  NOT BE POSSIBLE/intended...''









-> MAS O PHP 8.1
    ADICIONOU A FEATURE DE 'READONLY' 

    às PROPERTIES...








--> É UMA FEATURE OPCIONAL...







-> PODEMOS NOS LIVRAR DE TODOS AQUELES GETTERS INFERNAIS, TIPO ASSIM:







// * With readonly properties:
class Address
{
    public function __construct(
        public readonly string $street,
        public readonly string $city,
        public readonly string $state,
        public readonly string $postalCode,
        public readonly string $country
    ) {}

    // * with readonly properties (no getter methods needed):
} 











--> COM ISSO,
    PODEMOS SAFELY 

    DEIXAR NOSSAS PROPERTIES COMO 'public',

    PQ MESMO 

    ELAS SENDO ACESSADAS DO LADO DE FORA DIRETAMENTE,

    ELAS NÃO PODERÃO SER MODIFICADAS...






E PODEMOS CONTINUAR ACESSANDO ESSE VALUE, NORMALMENTE...


ex:










<?php declare(strict_types=1);

use PHP_8_1_Examples\ReadOnlyProperty\Address;

require_once __DIR__ . '/../../vendor/autoload.php';

$address = new Address(
    '123 Main Street',
    'Anytown',
    'CA',
    '90210',
    'USA'
);

// echo $address->getStreet() . PHP_EOL; // * getter example (without readonly properties)

echo $address->street;  // * readonly property example (there is no risk of changing the value of the property from outside, you can only access it).

$address->street = '123 asdas';  // * This will not work, because the property is readonly.
 











---------------------------









se vc tenta modificar 1 readonly property,


vc fica com este erro:


'Error: Cannot modify readonly property'...


















CERTO..










''VC PODE USAR o modifier de 'readonly' tanto 
    COM PROMOTED PROPERTIES, como COM PROPERTIES COMUNS..















OUTRO DETALHE:




'''YOU CAN ONLY USE/WRITE THE 'readonly' keyword  
   WHEN YOU HAVE A TYPED PROPERTY... IF THE PROPERTY IS NOT TYPED,
   YOU CANNOT USE IT...''














VC FICA COM O ERROR DE 


''Readonly property must have type''...












CERTO...








OUTRA COISA QUE VC DEVE SABER:







'''YOU __ CANNOT __ HAVE __ DEFAULT VALUES
    WITH _ READONLY PROPERTIES'''...








--> QUER DIZER QUE ISTO AQUI É IMPOSSÍVEL:





// * With readonly properties:
class Address
{

        public readonly string $street;
        public readonly string $city;
        public readonly string $state;
        public readonly string $postalCode;
        public readonly string $country = 'US'; // This will throw an Exception.


    public function __construct(

    ) {}

} 



isso vai nos DAR O ERROR DE 




''$country cannot have default value...'''






















ok... entretanto, por outro lado,


É POSSÍVEL DEFINIR 'DEFAULT VALUES' 



SE __ VC ESTÁ USANDO PROMOTED PROPERTIES,

EM VEZ DE PROPERTIES NORMAIS...


TIPO ASSIM:












// * With readonly properties:
class Address
{
    public function __construct(
        public readonly string $street,
        public readonly string $city,
        public readonly string $state,
        public readonly string $postalCode,
        public readonly string $country = 'US'; // This won't throw an Exception.
    ) {}

    // * with readonly properties (no getter methods needed):
} 











AGORA, SE RODAMOS O CÓDIGO, ISSO FUNCIONA....


















'''THE REASON THIS WORKS __ 
    IS _ BECAUSE WE ARE SETTING THE DEFAULT VALUE
     TO _ THE __ PARAMETER, 

     __ AND__ NOT _ DIRECTLY TO THE PROPERTY...'''














--------------------------------








OK... DEPOIS DISSO, 



TEMOS A QUARTA FEATURE, 









'PURE INTERSECTION TYPES (&)'...






 









4) PURE INTERSECTION TYPES:








-- ''AS YOU KNOW, PHP8 ADDED 
    SUPPORT FOR UNION TYPES...''




-- ''PHP 8.1 ADDED SUPPORT FOR 'INTERSECTION TYPES',
    AS WELL''...















--> ''WHEN YOU HAVE UNION TYPES,
    _ ANY OF THE TYPES DESCRIBED WILL BE ACCEPTED_...'










PARA ISSO, TEMOS ESTE EXEMPLO:







(MyService.php):






<?php declare(strict_types=1);

namespace PHP_8_1_Examples\IntersectionTypes;

class MyService
{
    public function __construct(
        private Syncable|Payable $entity
    ) {}

    public function handle()
    {
        $this->entity->pay();
        $this->entity->sync();
    }
}

















NESSE CASO, SE VC FOR INSTANCIAR 'MyService',



QUALQUER 1 DOS TYPES SERVIRIA... TANTO 'Syncable' como 'Payable'...









--> CERTO...




MAS O PROBLEMA É O METHOD DE 'handle()'...









-> ESSE METHOD EXIGE 'pay' e 'sync'...






-> aí, se tentarmos passar qualquer 1 desses objects, 
    ainda ficaríamos com 1 incompatibilidade 



    com o method de 'handle()'...









--> PARA RESOLVER ISSO,
    PODEMOS TIPAR COM OS 'INTERSECTION TYPES',



    QUE É BASICAMENTE DIZER 

    ''O PARAMETER PRECISA SER DE ESSES 2 TYPES/OBJECTS/INTERFACES 
    PARA CONSEGUIR SER PASSADO COMO PARAMETER''...








TIPO ASSIM:









<?php declare(strict_types=1);

namespace PHP_8_1_Examples\IntersectionTypes;

class MyService
{
    public function __construct(
        private Syncable&Payable $entity
    ) {}

    public function handle()
    {
        $this->entity->pay();
        $this->entity->sync();
    }
}











EX:








<?php declare(strict_types=1);

namespace PHP_8_1_Examples\IntersectionTypes;

// Example of no intersection types:
// class MyService
// {
//     public function __construct(
//         private Syncable|Payable $entity
//     ) {}

//     public function handle()
//     {
//         // * any of the two classes will have problems, because one has sync, the other has pay, but no one has both.
//         $this->entity->pay();
//         $this->entity->sync();
//     }
// }

// * Example of intersection types:
class MyService
{
    public function __construct(
        private Syncable&Payable $entity
    ) {}

    public function handle()
    {
        // * any of the two classes will have problems, because one has sync, the other has pay, but no one has both.
        $this->entity->pay();
        $this->entity->sync();
    }
}   























--> basicamente, isso te deixa anotar de modo que 
    o object terá de implementar ambas interfaces...








-> SE ELE IMPLEMENTAR APENAS 1 ÚNICA INTERFACE, 
    VAI FICAR COM 1 ERROR...










--> ''THIS FEATURE ONLY COMES IN HANDY WHEN YOU ARE WORKING WITH INTERFACES...'''


   ''PRIOR TO THIS FEATURE,

    WHAT YOU WOULD NEED TO DO, TO SUPPORT SOMETHING LIKE THIS,
    IS THE CREATION OF ANOTHER INTERFACE, THEN EXTEND THESE 2 INTERFACES 
    AND THAT INTERFACE, AND THEN TYPEHINT THAT INTERFACE, as the type of the 
    $entity''...













O PROFESSOR DESTACA:





''YOU CANNOT USE THE INTERSECTION TYPES AND UNION TYPES 
    AT THE SAME TIME...''






    (vc não pode escrever algo como 
    
        Syncable&Payable|Invoice
    )





-> ALÉM DISSO,
    APENAS CLASS TYPES 

    SÃO SUPORTADOS 


    PARA OS INTERSECTION TYPES...







    -> QUER DIZER QUE NÃO PODEMOS 

    FAZER ALGO COMO 



    private int&array $entity;






    --> E ISSO FAZ SENTIDO,
        PQ O VALUE NÃO PODE SER TANTO ARRAY E INTERFACE,
        AO MESMO TEMPO...



----------








AÍ TEMOS A 5a feature, chamada de 'NEVER RETURN TYPE'...














5) THE 'NEVER' RETURN TYPE:







--> É UM NOVO RETURN TYPE...




--> ELE INDICA QUE 
    A FUNCTION/METHOD NUNCA VAI RETURN 1 VALUE... 





-> ELE INDICA, NO CASO, QUE A FUNCTION/METHOD VAI __EXIT__ 
    A EXECUTION OU:


    A) VIA EXIT STATEMENT

 
    B) VIA UMA EXCEPTION...












--> PARA EXEMPLIFICAR, O PROFESSOR TEM ESTE CÓDIGO:








<?php declare(strict_types=1);

function foo(): never
{
    echo '1';
}

foo();

echo 'I should *never* be printed';



















-> COM ISSO, 

TEMOS ESSE TYPE DE 'never',


E AÍ 


ESTAMOS CHAMANDO ESSA FUNCTION,


E DEPOIS 


FAZENDO O ECHO DAQUELA MESSAGE...











AO RODARMOS ISSO, FICAMOS COM ESTE ERROR:









Fatal error: Uncaught TypeError: foo(): never-returning function must not implicitly return in /in/FplUr:6
Stack trace:
#0 /in/FplUr(8): foo()
#1 {main}
  thrown in /in/FplUr on line 6












--> A PARTE DE 'I should never be printed'



NÃO DEVE SER ALCANÇADA,


QUANDO USAMOS O RETURN TYPE DE 'never'...













-> ISSO É PQ, QUANDO 'never' é UTILIZADO,

ESPERA-SE QUE A EXECUTION SEJA IMEDIATAMENTE INTERROMPIDA...











->  ''never-returning function must not implicitly return''








''THIS JUST MEANS THAT WE ARE AT THE END OF THE FUNCTION...
AND OUR FUNCTION, THE WHOLE FUNCTION, RETURNS NOTHING...

TO CORRECTLY WRITE CODE FOR FUNCTIONS THAT RETURN 'never',

YOU MUST USE OR 'exit' OR THROW AN EXCEPTION''....














EX:








<?php declare(strict_types=1);

// ! This is wrong (we must or throw an exception, or run 'exit' in the function):
// function foo(): never
// {
//     echo '1';
// }

// * This is correct (throw an exception):
// function foo()
// {
//     echo '1';
//     throw new Exception('generic exception');
// }

// * This is correct (exit):
function foo()
{
    echo '1';
    exit;
}

foo();

echo 'I should *never* be printed';










 






 quais são os use-cases para isso?








'THE USE-CASES ARE:




A) YOU WANT TO REDIRECT THE USER AND EXIT RIGHT AFTER...



B) YOU WANT TO EXIT AND STOP THE SCRIPT EXECUTION,
    AND MAKE SURE THAT CODE DOES NOT CONTINUE EXECUTING AFTER....
















    VOID VS NEVER:









--> VOID NÃO RETORNA COISA ALGUMA, MAS NÃO PRECISA TER 'exit' ou 'exception'...




--> COM 'VOID', SEU CÓDIGO CONTINUA EXECUTANDO 
    DEPOIS QUE A FUNCTION/METHOD É EXECUTADO....






--> JÁ 'never', quando seu return type é de 'never',

    A FUNCTION 'IS EXPECTED TO __STOP THE EXECUTION ENTIRELY__''...


--> QUER DIZER QUE 'NEVER' PARA TUDO, toda a execução...
















DEPOIS DISSO, A PRÓXIMA FEATURE É 

A FUNCTION DE 


'ARRAY_IS_LIST()'...









-------------------------------------------










6) ARRAY_IS_LIST();














-> 'LISTS' SÃO CONSIDERADOS 
    ARRAYS__ EM QUE 
    AS KEYS COMEÇAM 

    EM '0' E VÃO SENDO ORDENADOS NORMALMENTE 



    (ordem 0123456789..., como arrays javascript comuns)...



EX: ['a', 'b', 'c']; /// É UM ARRAY DE TIPO 'LIST'...
    [1, 2, 3]; // É UM ARRAY DE TIPO 'LIST'...





-> NO CASo,
    
    ASSOCIATIVE ARRAYS 

    E 

    'ARRAYS WITH UNORDERED KEYS' 


NÃO SÃO CONSIDERADOS COMO arrays de tipo 'list'...



EX:
    ['firstName' => 'Gio']; // NÃO É UM ARRAY DE TIPO 'LIST'
    ['a', 3 => 'b', 'c'];  // NÃO É UM ARRAY DE TIPO 'LIST'













COMO EXEMPLO DISSO, O PROFESSOR TEM ESTE CÓDIGO:












<?php declare(strict_types=1);

$list = ['a', 'b', 'c'];  // this is an array of type 'list'. It is considered a list.

$list2 = [1, 2, 3];  // this is an array of type 'list'. It is considered a list.

$notList = ['a' => 1, 'b' => 2, 'c' => 3];  // this is an ASSOCIATIVE ARRAY. It is NOT considered a list.

$notList2 = ['a', 'b' => 2, 'c'];  // this is an UNORDERED ARRAY. It is NOT considered a list.

var_dump(array_is_list($list));  // Will return true
var_dump(array_is_list($list2));  // Will return true
var_dump(array_is_list($notList));  // Will return false
var_dump(array_is_list($notList2));  // Will return false

// OUTPUT:
// bool(true)
// bool(true)
// bool(false)
// bool(false)


























--> isso é útil pq ÀS VEZES VC __ VAI QUERER 

    __GARANTIR _ QUE 1 GIVEN ARRAY SERÁ UMA LIST...


    COM ISSO, VC __ GARANTE QUE OS VALUES NO ARRAY 
    TERÃO INDEXES/KEYS QUE SERÃO 'ORDERED SEQUENTIALLY'...








--> EX: ''WHEN YOU USE THE 
            ARRAY_FILTER() FUNCTION,

            TO FILTER OUT THE VALUES,
            
            IT __ DOES _ NOT RE-ORDER 

            THE VALUES... AND TO CHECK THAT
            THEY ARE NOT RE-ORDERED,


            WE CAN USE 'array_is_list()'... '''




            ''AND IF WE FIND OUT THAT THE LIST 
            IS NOT RE-ORDERED CORRECTLY,
            WE CAN CORRECT THAT, BY 
            USING THE 

            array_values() function...'''
        








EX:






<?php declare(strict_types=1);

$list = ['a', 'b', 'c'];  // this is an array of type 'list'. It is considered a list.

$list2 = [1, 2, 3];  // this is an array of type 'list'. It is considered a list.

$notList = ['a' => 1, 'b' => 2, 'c' => 3];  // this is an ASSOCIATIVE ARRAY. It is NOT considered a list.

$notList2 = ['a', 'b' => 2, 'c'];  // this is an UNORDERED ARRAY. It is NOT considered a list.

var_dump(array_is_list($list));  // Will return true
var_dump(array_is_list($list2));  // Will return true
var_dump(array_is_list($notList));  // Will return false
var_dump(array_is_list($notList2));  // Will return false

// OUTPUT:
// bool(true)
// bool(true)
// bool(false)
// bool(false)

$list = array_filter($list, fn(string $value) => $value !== 'b');  // * 'array_filter()' will return an UNORDERED ARRAY, as the 'b' element will be removed, and the indexes won't be updated.

var_dump(array_is_list($list));  // * This will return false, as the array is now an UNORDERED ARRAY.

// TODO - To fix that, we can RE-ORDER THE ARRAY, using the function array_values():

$list = array_values($list);  // * This will return an ORDERED ARRAY.

var_dump(array_is_list($list));  // * Will return true















CERTO... ISSO REALMENTE FUNCIONOU...








O 'array_values()'

RE-ORDENOU O ARRAY...






AÍ, DEPOIS DISSO, USEI 'array_is_list()'

PARA CHECAR 

SE O NEGÓCIO FICOU REALMENTE UMA LIST, UMA 'ORDERED LIST'... UM 

ARRAY ORDERED PROPERLY...








------------------------------------











DEPOIS DISSO, TEMOS A 7a nova feature, que é 



'FIRST-CLASS CALLABLE SYNTAX'....












7) FIRST-CLASS CALLABLE SYNTAX:













-> O CÓDIGO-EXEMPLO É ASSIM:











<?php declare(strict_types=1);

function sum(float ...$num): float
{
    return array_sum($num);
}

$closure = Closure::fromCallable('sum');

var_dump($closure);

echo $closure(2, 5) . PHP_EOL;


















EXPLICAÇÃO



'''WE COULD CREATE CLOSURES 
    FROM CALLABLES, BEFORE, BY CALLING THE 




    ''::fromCallable()'' 

    METHOD, ON THE 'Closure' CLASS...






---> TIPO ASSIM:





$closure = Closure::fromCallable('sum');












-> MAS AGORA HÁ UMA 
'FIRST-CLASS CALLABLE SYNTAX',


QEU NOS DEIXA FAZER A MESMA COISA,
 




MAS SEM TODO ESSE OVERHEAD 



DE 




TER DE ESCREVER 'Closure::' antes do call de 'fromCallable()'...















-> NÓS COBRIMOS CLOSURES 
    E CALLABLES 


    __ NA PRIMEIRA PARTE DO CURSO...










--> AÍ O PROFESSOR FAZ 1 VAR DUMP DA CLOSURE,


E 1 ECHO DA CLOSURE DEPOIS 



DE CHAMARMOS ELA, COM ALGUNS VALUES...








EX:


var_dump($closure);

echo $closure(2, 5) . PHP_EOL;



















-> É CLARO QUE ESSA SINTAXE DE 

'''
$closure = Closure::fromCallable('sum');

'''




É A SINTAXE __ANTIGA_...









A SINTAXE QUE É POSSÍVEL, AGORA,








É ESCREVER SIMPLESMENTE ASSIM:









$closure = sum(...);









EX:










<?php declare(strict_types=1);

function sum(float ...$num): float
{
    return array_sum($num);
}

$closure = Closure::fromCallable('sum');  // *Old Syntax/way of creating a Closure.

$closure = sum(...);  // * New Syntax/way of creating a Closure.

var_dump($closure);

echo $closure(2, 5) . PHP_EOL;

















mas o que são closures?









são isto:









In PHP, a closure is a type of anonymous
 function that can capture variables from its surrounding scope. 
 Closures are particularly useful when you need to create a function that maintains
  access to variables outside of its immediate scope, which is often useful in callbacks, 
  functional programming, and working with higher-order functions.

Here’s a basic overview of how closures work in PHP:

Creating a Closure
You can create a closure in PHP using the function keyword without giving the function a name:



$myClosure = function($name) {
    return "Hello, $name!";
};









PARA ACESSAR VARIABLES NO OUTSIDE SCOPE, COM CLOSURES, ESCREVEMOS ASSIM ('use'):





$x = 1;


// This type of anon function is called a closure. It is a function that has access to variables outside of its local scope (global scope, for example), with the 'use()' keyword.
$sum5 = function (int|float ...$numbers) use ($x): void { // THIS WILL ALLOW US TO ACCESS A VARIABLE NOT DEFINED IN THIS SCOPE 
    echo $x;
};

















BASICAMENTE, USAMOS CLOSURES QUANDO QUEREMOS 1 COMPORTAMENTO DE FUNCTION SIMILAR 

AO VISTO NO JAVASCRIPT (em que podemos acessar variables externas a nossas functions)...













CERTO...










E, AGORA, PORTANTO,


PARECE QUE PODEMOS 



USAR 



''''


$closure = funcName(...); 


''''







PARA CRIAR CLOSURES...














EX:



You’re right, and I apologize for the 
confusion earlier. PHP 8.1 introduced a new feature called "first-class callable syntax,"
which allows you to reference functions or methods in a more concise way.
This syntax lets you use 'function_name(...)' to create callable references,
which is what you were referring to.













PARECE QUE USAR 'use()' com essa sintaxe NÃO FUNCIONA...

(quer dizer que o acesso a variables OUTSIDE THE SCOPE OF THE CLOSURE 
    não funciona, com essa sintaxe... devemos usar a VELHA SINTAXE)










DEPOIS DISSO, TEMOS A FEATURE 8...







A FEATURE 8 É 





''THE ABILITY TO USE THE 'new' KEYWORD _ ALSO __ IN INITIALIZERS....''








-------------------------------










8) 'new' KEYWORD IN INITIALIZERS:










--> COMO VC SABE,
    NÃO ERA POSSÍVEL __ USAR A KEYWORD DE 'new' QUANDO 

    ERA O MOMENTO DE DEFINIR OS DEFAULT VALUES 

    NO CONSTRUCTOR (com a feature das promoted properties, por exemplo)






DESDE O PHP 8.1, ISSO É POSSÍVEL, MAS SOMENTE COM AS 
PROMOTED PROPERTIES...
 







eX:




<?php declare(strict_types=1);

require_once __DIR__ . '/../../vendor/autoload.php';

$customer = new Customer();

var_dump($customer->address);




E ISTO:





<?php declare(strict_types=1);

class Customer
{
    // OLD SYNTAX
    public function __construct(public ?Address $address = null) 
    {
        $this->address ??= new Address();
    }
}















BASICAMENTE, NESSE EXEMPLO:





''WE HAVE A CUSTOMER CLASS, AND AN ADDRESS CLASS...''





''THE POINT IS THAT, FROM WITHIN OUR CUSTOMER CLASS,
    WE HAVE A CONSTRUCTOR __ WHERE __ 

    WE ARE ACCEPTING AN OBJECT OF THE 'ADDRESS CLASS',

    AND THEN SETTING THAT AS THE VALUE OF THE '$address' property...''






-> IF NOTHING IS PASSED, WE ARE MAKING THIS AS NULLABLE...
    ALL SO THAT YOU CAN CREATE AN OBJECT OF 'CUSTOMER' WITHOUT 
    PASSING ANYTHING IN THE CONSTRUCTOR... -> AND __IF THAT'S 

    THE CASE, IF THE '$address' PARAMETER IS NOT PASSED/NULL,

    WE ARE SIMPLY CREATING A NEW __ BLANK __ ADDRESS OBJECT...











--> THERE IS NOTHING WRONG WITH THIS SYNTAX, BUT THERE IS A 
    BETTER WAY OF WRITING IT, IN PHP 8.1...









COM ISSO, PODEMOS DEIXAR NOSSO CÓDIGO ASSIm:





// * Since PHP 8.1, we can use the 'new' keyword in the initializer of a property, to create an object, and assign it to the property, as a default value:
class Customer
{
    public function __construct(public Address $address = new Address()) {}
}











E ISSO TERÁ O MESMO EFEITO DE ANTES,


1 DEFAULT VALUE OF 'empty address object',



mas com bem menos boilerplate code...










MAS A PERGUNTA QUE VC PODE TER, AQUI, É:









''''DOES THIS HAVE ANY EFFECT ON THE PERFORMANCE??

    DOES THE NEW OBJECT OF THE 'ADDRESS' CLASS ACTUALLY GET CREATED?

    DOES IT __ GET CREATED _ EVERY SINGLE TIME THE 'Customer' OBJECT IS CREATED?'''




    A RESPOSTA:



''''NO, IT DOES _ NOT __ GET CREATED 
    EVERY TIME A 'Customer' OBJECT IS CREATED (class is instantiated)...'''





''IT ONLY CREATED WHEN __ THE 'Customer' OBJECT _IS CREATED 
    AND __ NO ARGUMENT_ IS PASSED IN FOR THE '$address' parameter...''





-> NO NOSSO CASO,
    COMO ESTAMOS CHAMANDO DE FORMA SECA,

    SEM PROVIDENCIAR ARGUMENTS,


    1 NOVO 'ADDRESS OBJECT' CERTAMENTE SERÁ CRIADO...






EX:





<?php declare(strict_types=1);

require_once __DIR__ . '/../../vendor/autoload.php';

$customer = new Customer();

var_dump($customer->address);





E EX:






// * Since PHP 8.1, we can use the 'new' keyword in the initializer of a property, to create an object, and assign it to the property, as a default value:
class Customer
{
    public function __construct(public Address $address = new Address()) {}
}





















MAS SE PASSÁSSEMOS 1 OBJECT COMO PARAMETER DE 'new Customer',


TIPO ASSIM:





<?php declare(strict_types=1);

require_once __DIR__ . '/../../vendor/autoload.php';

$customer = new Customer(new Address('Example Street', 12312));

var_dump($customer->address);










bem, se fizermos isso,


O CÓDIGO 

QUE DEFINE O VALUE DEFAULT DE '$address' 


como sendo 
'new Address()'



NÃO SERÁ EXECUTADO...




(PQ 1 VALUE REALMENTE FOI PASSADO, COMO ARGUMENT )....



















OUTRO DETALHE:






'''SOMETHING TO NOTE ABOUT THE 'new' KEYWORD, IN THE INITIALIZERS,
    IS THAT _ WE ARE STILL _ NOT ABLE TO USE the 'new' KEYWORD 
    IN PROPERTIES AND CONSTANTS...''





--> ''HERE, IT IS ONLY ALLOWED BECAUSE WE ARE USING THE _ PROMOTED __ PROPERTIES 
    FEATURE... AND THE DEFAULT VALUE GETS SET TO THE PARAMETER, AND THEN GETS ASSIGNED 
    TO THE PROPERTY....''













QUER DIZER QUE ALGO COMO ISTO NÃO É SUPORTADO:



// * Since PHP 8.1, we can use the 'new' keyword in the initializer of a property, to create an object, and assign it to the property, as a default value:
class Customer
{

    public Address $address = new Address(); // THIS IS NOT SUPPORTED.

    public function __construct() {};
}















ficamos com 1 error de 


'Expression is not allowed as FIELD DEFAULT VALUE...''















CERTO...














DEPOIS DISSO, TEMOS A FEATURE 9, QUE É 'final constants'...
























9) 'FINAL CONSTANTS'








--> É A ABILIDADE 
    PARA _ MARCAR __ CLASS CONSTANTS COMO SENDO 'FINAL'...









-> ''AS WE KNOW,
     CLASS CONSTANTS COULD BE OVERRIDEN WHEN USING 
     INHERITANCE (we covered that on the 2nd section of the series)....''









--> ''TO AVOID THAT,
        YOU CAN NOW MARK VARIABLES, USING THE 'final' keyword,

        TO _ AVOID_  CONSTANT OVERRIDING...









TIPO ASSIM:






<?php declare(strict_types=1);

use PHP_8_1_Examples\FinalConstant\InvoiceQuery;

require_once __DIR__ . '/../../vendor/autoload.php';

echo InvoiceQuery::DEFAULT_LIMIT;











E ASSIM:







<?php declare(strict_types=1);

namespace PHP_8_1_Examples\FinalConstant;

class InvoiceQuery extends TableQuery
{
    public const DEFAULT_LIMIT = 50;
}




E ASSIm:








<?php declare(strict_types=1);

namespace PHP_8_1_Examples\FinalConstant;

class TableQuery
{
    public const DEFAULT_LIMIT = 25;
}
















 -> CERTO...








 NO CASO,
  


TEMOS 2 CLASSES, A 'InvoiceQuery' E A 'TableQuery'...











-> o que está acontecendo, no caso,


é o INHERIT, DA CLASS DE 'InvoiceQuery',


DA CLASS DE 'TableQuery' (parent)....







-> NO CASO, AO ACONTECER ESSE INHERIT, O VALUE DA CONSTANT 
    DE 'DEFAULT_LIMIT' DA 'TableQuery'

    ESTÁ 

    SENDO _ OVERRIDEN PELO VALUE 


    DE 'DEFAULT_LIMIT' DA 'InvoiceQuery'..













->  É CLARO QUE ESSE 



    echo,

    de 





echo InvoiceQuery::DEFAULT_LIMIT;






VAI FAZER O PRINT DE 50,


PQ ESSE É O VALUE 


DA CHILD CLASS, QUE FEZ COM QUE ESSA SUA PROPERTY 

FIZESSE OVERRIDE DO VALUE DA PARENT CLASS...


















''''TO PREVENT OVERRIDING AND _ ENSURE __       
    THAT CONSTANTS __ CANNOT _ BE OVERRIDEN WHEN 
    USING INHERITANCE, WE CAN CONSTANTS BE FINAL, LIKE THIS:''


    



<?php declare(strict_types=1);

namespace PHP_8_1_Examples\FinalConstant;

class TableQuery
{
    // public const DEFAULT_LIMIT = 25; // * No 'final' keyword - this means that the constant can be changed by the child class, during runtime.
    final public const DEFAULT_LIMIT = 25;  // * 'final' keyword present - this means that the constant CANNOT be changed by the child class, during runtime. If you try to do so, an exception gets thrown.
}


















HÁ ALGUMAS OUTRAS CHANGES QUE PODEMOS VER NO CHANGELOG DO PHP 8.1...






COMO 'fsync()',


'fibers',

etc...










-> A RAZÃO DE O PROFESSOR NÃO 
    FALAR DE 'FIBERS' AQUI
    É QUE 

    ESSE TÓPICO EXIGE 1 VIDEO/SERIE INTEIRA SEPARADA,




ISSO 


PQ 


''ASYNC PHP''

É SUA PRÓPRIA COISA,

MAGIC BOX...








-> E O ASYNC PHP INCLUI A FEATURE DE 'FIBERS'...




''FIBERS'' -> ARE AN ADVANCED FEATURE THAT MOST USERS WILL NOT USE DIRECTLY..''









-> FIBERS WILL MOSTLY BE USED THROUGH FRAMEWORKS/PACKAGES....












-> UM FRAMEWORK QUE USA ISSO AÍ BASTANTE 

É 

'REACTPHP'... 












REACTPHP ---------> É UMA LIBRARY...








FRAMEWORK X --> É UM FRAMEWORK NOVO, QUE UTIILIZA ESSA FEATURE, DE FIBERS, ASYNC...











-> O PROFESSOR NÃO FEZ MT ASYNC PHP...









--> HÁ ALGUMAS BACKWARD INCOMPATIBLE CHANGES 
    E DEPRECATIONS... DEVEMOS ESTUDÁ-LAS...










ALGUMAS DELAS:












-- ''STATIC VARIABLES IN _ INHERITED METHODS __ 
    ARE __ NOW SHARED, WHEN THEY ARE NOT OVERRIDEN....''












'''When a method using static variables IS INHERITED (but not overriden), 
    THE INHERITED METHOD WILL NOW __SHARE__ STATIC VARIABLES 
    WITH THE PARENT METHOD...''











PARA ENTENDER ISSO, DEVEMOS VER 1 EXEMPLO DO 

'PHP MIGRATION GUIDE'...









O EXEMPLO É ESTE:







<?php 




class A {

    public static function counter() {
        static $counter = 0;
        $counter++;
        return $counter;
    }
}



class B extends A {};

var_dump(A::counter()); // int(1)
var_dump(A::counter()); // int(2)
var_dump(B::counter()); // int(3), previously int(1)
var_dump(B::counter()); // int(4), previously int(4)










''THIS MEANS THAT STATIC VARIABLES IN METHODS NOW BEHAVE THE _ SAME WAY 
AS STATIC PROPERTIES...''

















--> O PROFESSOR PRIMEIRAMENTE RODA ISSO EM 'PHP 8.0'..





NO PHP 8.0,

ESTAMOS FICANDO COM 


int 1 
int 2 
int 1 
int 2 












EXPLICAÇÃO:





''''WE ARE DEFINING THE __ "COUNTER" 
    VARIABLE, WHICH IS A __ STATIC VARIABLE, 
    WITHIN THE STATIC METHOD 'counter',   
    IN THE 

    CLASS 'A''''..




''WE ARE, THEN, INCREMENTING THAT COUNTER, AND THEN RETURNING IT...'''









-> AÍ TEMOS A CLASS B, 
    QUE INHERITA A CLASS B...







O NEGÓCIO FICOU 1 2 1 2 





JUSTAMENT PQ 



AQUELA STATIC VARIABLE, DE '$counter',
NÃO VAI 

SER SHARED 



ENTRE AS CLASSES, MESMO SENDO 'STATIC'...





(ESSENTIALLY, ''WE ARE KEEPING TWO DIFFERENT STATIC VARIABLES,
INSTEAD OF ONE... THEY ARE NOT BEING SHARED...'' )



-> ENTRETANTO, COM O PHP 8.1,



FICAMOS 

QUE 

A STATIC VARIABLE DE 

'$counter'

É SHARED 

ENTRE AS CLASSES A E B....



É POR ISSO QUE FICAMOS 


COM O PRINT DE 1 2 3 4....

















E É POR ISSO QUE ESSA É UMA BREAKING CHANGE...














-> AÍ TEMOS OUTRAS BACKWARDS INCOMPATIBLE CHANGES...















--> A OUTRA CHANGE É 

A RESPEITO DO 'PDO'...









-> ''PDO... --> AS YOU REMEMBER, THE TEACHER    
                TALKED ABOUT THE EMULATED PREPARES...

                AND THAT, IF YOU TURN OFF THE EMULATION
                AND USE THE 

                __NATIVE PREPARE STATEMENTS, 

                THE RETURNED _ INTEGERS AND FLOATS 
                FROM QUERIES ARE RESPECTED... 







                ''WHEN YOU HAD EMULATED PREPARES ENABLED, THE 
                RETURNED INTEGERS AND FLOATS WERE ALWAYS CONVERTED 
                INTO STRINGS...'''







            --> AGORA, COM A NOVA MUDANÇA,


            ''EVEN WITH THE EMULATED PREPARES ENABLED, 
                THE INTEGERS AND FLOATS, WHEN __ RETURNED 
                FROM THE QUERIES, WILL BE RETURNED AS 
                NATIVE PHP TYPES (and not converted into strings)...''






-----------------------------






AGORA, DEPOIS DISSO, FALAREMOS SOBRE 'DEPRECATIONS'...









DEPRECATIONS:












-- 'IMPLEMENTING Serializable CLASS without 
    the '__serialize()' and '__unserialize()' METHODS

    HAS BEEN __DEPRECATED...





-- ''Passing 'null' to non-nullable parameters 
    of BUILT-IN FUNCTIONS....''  ALSO DEPRECATED.





-- ''Implicit incompatible flaot to int conversions'' ALSO DEPRECATED.









--> COMO VC SABE, 

O PHP FAZ 

MT 'IMPLICIT TYPE CONVERSIONS'...













''AND, WHEN IT COMES TO FLOATS TO INT CONVERSIONS,
SOMETIMES IT CAN RESULT IN THE LOSS OF PRECISION''...








EX:









function foo (int $x)
{
    echo $x. PHP_EOL;
}




foo(2); 












ESSA É UMA FUNCTION QUE APENAS FAZ O ECHO OUT DE ESSE INTEGER...





--> MAS SE PASSARMOS 1 VALUE COMO '2.5',

    VAMOS FICAR COM 'LOSS OF PRECISION'...






EX:







function foo (int $x)
{
    echo $x. PHP_EOL;
}




foo(2.5); 















ISSO ACONTECE/ACONTECERÁ JUSTAMENTE PQ 


'2.5'


SERÁ 


'IMPLICITLY CONVERTED' 


EM 1 INTEGER, E AÍ 
ESSE '0.5'



SERÁ _ IGNORED _ AND REMOVED...

















--------> MAS SE TENTAMOS EXECUTAR ESSE MESMO CÓDIGO NO PHP 8.1,


            FICAMOS COM ESTE ERROR:







            ''Deprecated: Implicit Conversion from float 2.5 to int LOSES precision...''

        






--> JÁ EM PHP 8.0,

ficamos 

com 2.0...








-> É CLARO QUE, SE VC TIVER STRICT TYPES ENABLED,

VC NEM MESMO PODERIA RODAR ISSO AÍ...







''SO THE DEPRECATION APPLIES ONLY WHEN STRICT TYPES ARE NOT ENABLED...''






''NOTE THAT, IF THE IMPLICIT CONVERSION DOES NOT RESULT IN THE LOSS OF 
PRECISION (like 2.0), NOTHING WILL BE LOST, AND NO DEPRECATION ERROR 
WILL BE THROWN'...







ACABAMOS...