






HOJE VEREMOS A FEATURE ADICIONADA NO PHP 8,


OS 'ATTRIBUTES'...











--> PARA ISSO, ABRIMOS OS DOCS, E LEMOS A DEFINIÇÃO:












ATTRIBUTES:






-- Attributes offer the ability to add STRUCTURED, MACHINE-READABLE METADATA 
INFORMATION on DECLARATIONS in code: Classes, methods, functions, parameters,
properties and class constants can be the TARGET of an attribute. The metadata 
defined by attributes can then be inspected, at runtime, using the REFLECTION 
APIs...


Attributes could, therefore, be thought of as a CONFIGURATION LANGUAGE 
embedded directly into the code...
















-> ISSO PARECE BEM STRAIGHTFORWARD,
    MAS NÃO É TANTO ASSIM..









-> PARECEM SER UM CONCEITO SIMILAR A ANNOTATIONS (@)...









--> ANNOTATIONS TAMBÉM PODEM 
    SER USADAS PARA 



    ''ADD METADATA'',



E JÁ FORAM USADAS EM DIVERSOS FRAMEWORKS E PACKAGES,


COMO 'DOCTRINE', 'SYMFONY', ETC...










-> É CLARO QUE EXISTEM VÁRIAS DESVANTAGENS EM POTENCIAL,
    NO USO DE ANNOTATIONS, COM O APPROACH DE ANNOTATIONS..












-- VÁRIAS DESVANTAGENS, AINDA QUE ELAS 
    SERÃO UTILIZADAS POR MTOS ANOS...









--> DESVANTAGEM 1:





''We ADD annotations ALONG WITH COMMENTS, 
AND A WHOLE DOCBLOCK WITH ANNOTATIONS AND 
COMMENTS  __ NO LONGER__ SERVES THE PURPOSE 
OF "just providing information about the class/properties''...





EX:


class InvoiceController {

    /**
    * Processes the associated invoice payment 
    * (... some other informational comments ...)
    *
    * @Route ('/invoices/${id}/process', 'POST')
    */
    protected function process()
    {

    }

}




--> QUANDO VC ADICIONA ANNOTATIONS,
    ESSE BLOCO, QUE DEVERIA SER APENAS DE 'INFO',

    PASSA 


    A TER ALGUNS EFEITOS MALUCOS (behaviors),

    QUANDO DEVERIA SER APENAS INFO ADICIONAL...








--> DESVANTAGEM 2:



--> PARA QUE ESSAS ANNOTATIONS TENHAM ALGUM EFEITO REAL,
    SEMPRE 'SOME KIND OF PARSING NEEDS TO HAPPEN', para handlar 
    essas complex annotations...



















--> PARA CONSERTAR ISSO, CRIARAM UMA NOVA FEATURE DO 
    PHP,


    OS ATTRIBUTES...













--> ''THERE IS A BETTER WAY, WHICH IS NOW DIRECTLY BUILT-IN, AS A FIRST-CLASS 
CITIZEN, INTO PHP SINCE VERSION 8.0, WHICH IS __ ATTRIBUTES__...''



















ANNOTATION EXAMPLE:


class InvoiceController extends AbstractController 
{
    /**
    * @Route("/invoices", name="invoices_list")
    */
    public function index()
    {
        //...
    }


}













    * @Route("/invoices", name="invoices_list")






--> isso aí, essa __ANNOTATION__, É USADA 

    PARA 'EMBED THE METADATA INTO THE CODE'...




--> ESSE É UM EXEMPLO __ TIRADO __ DO FRAMEWORK 
    DO 'SYMFONY'...



--> ESSA METADATA, EMBEDADA NO CÓDIGO, 
É ENTÃO 'PARSED' E _ USADA_ PARA REGISTRAR A ROUTE...









-> MAS O SYMFONY JÁ ADICIONOU SUPORTE A ATTRIBUTES...

    ESSE MESMO CÓDIGO,

    COM ATTRIBUTES,


    FICA TIPO ASSIM:







    
class InvoiceController extends AbstractController 
{
    
    #[Route("/invoices", name="invoices_list")]
    public function index()
    {
        //...
    }


}














COMO VC PODE OBSERVAR, ATTRIBUTES E ANNOTATIONS 

SÃO _ PARECIDOS_,


MAS NÃO SÃO IGUAIS...






--> ''THEY PROVIDE THE SAME FUNCTIONALITY: PROVIDING METADATA...''






--> ''THE SAME FUNCTIONALITY, 
        BUT __ ATTRIBUTES _ HAVE MORE FEATURES, AND PROVIDE A BETTER 
        STRUCTURE AND VALIDATION...''








    



AGORA DEVEMOS CRIAR ALGUNS ATTRIBUTES,

E EXAMINAR A SINTAXE...










VAMOS USAR O MESMO CÓDIGO DE ROUTER DAS AULAS ANTERIORES...







TIPO ASSIM:







<?php

declare(strict_types = 1);

use App\App;
use App\Config;
use App\Container;
use App\Controllers\GeneratorExampleController;
use App\Controllers\HomeController;
use App\Router;

require_once __DIR__ . '/../vendor/autoload.php';

$dotenv = Dotenv\Dotenv::createImmutable(dirname(__DIR__));
$dotenv->load();

define('STORAGE_PATH', __DIR__ . '/../storage');
define('VIEW_PATH', __DIR__ . '/../views');

$container = new Container();
$router    = new Router($container);

$router
    ->get('/', [HomeController::class, 'index'])
    ->get('/examples/generator', [GeneratorExampleController::class, 'index']);

(new App(
    $container,
    $router,
    ['uri' => $_SERVER['REQUEST_URI'], 'method' => $_SERVER['REQUEST_METHOD']],
    new Config($_ENV)
))->run();













CERTO...





É UM ROUTER SIMPLES...







--> funciona por meio do register e resolve das routes...









-> VAMOS PLAY AROUND COM NOSSA IMPLEMENTAÇÃO DE ROUTER,
    PARA QUE ELE FUNCIONE COM ATTRIBUTES....





--> ''THE GOAL IS TO NOT HAVE TO REGISTER 
    ROUTES MANUALLY LIKE WE ARE DOING 

    (
        com este trecho:

        '''

        $router
    ->get('/', [HomeController::class, 'index'])
    ->get('/examples/generator', [GeneratorExampleController::class, 'index']);


            ''''

    ),


    BUT, INSTEAD, EMBED THE ROUTE METADATA __ DIRECTLY WITHIN 
    THE CONTROLLER METHODS...










-> OK... A PRIMEIRA COISA QUE FAZEMOS É ABRIR 

O CONTROLLER DE 'HomeController':




<?php

declare(strict_types = 1);

namespace App\Controllers;

use App\Services\InvoiceService;
use App\View;

class HomeController
{
    public function __construct(private InvoiceService $invoiceService)
    {
    }

    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }
}









-> TEMOS ESSE METHOD AÍ, DE 'index()'...










--> QUEREMOS ADICIONAR O 'ATTRIBUTE METADATA'

DIRETAMENTE A ESSE METHOD, NO HOME CONTROLLER...







--> PARA ESCREVER A SINTAXE DE ATTRIBUTES, FAZEMOS ASSIM:







#[] 










--> DEPOIS DISSO, DENTRO DOS BRACKETS,

    TEMOS QUE ESPECIFICAR 


    ''THE ATTRIBUTE'S CLASS''...





--> NO NOSSO CASO,
    DEFINIMOS QUE TEREMOS ALGUM 


    TIPO DE 'Route' attribute:









#[Route] 








--> CERTO... 








--> AÍ, OPCIONALMENTE, PODEMOS USAR '()' 

    E PASSAR CONSTRUCTOR ARGUMENTS...





--> AÍ, NESSE SLOT, VAMOS PASSAR O 'ROUTE PATH',
    COMO CONSTRUCTOR ARGUMENT...






--> PRIMEIRAMENTE, COLOCAREMOS A ROUTE DE '/'... (home)..





TIPO ASSIM:





    #[Route('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }













--> COM ESSE ATTRIBUTE/ANNOTATION,
    FAREMOS COM QUE 

    O CONTROLLER DE 'HOME CONTROLLER'

    FAÇA 

    'LISTEN TO' 

    A 
    ESSA ROUTE ESPECÍFICA...









-> DEPOIS DISSO, PRECISAMOS ACTUALLY CRIAR ESSA CLASS,
    A CLASS DE 'Route',
    referenciada nesse ATTRIBUTE...









--> PARA ISSO, CRIAMOS ESSA CLASS, DENTRO DO NAMESPACE DE 'Attributes',

DENTRO DA PASTA DE 'Attributes',

TIPO ASSIM:












<?php declare(strict_types=1);

namespace App\Attributes;

class Route
{
    public function __construct(public string $routePath, string $method = 'get') {}
}












-> ou seja,
 
 terá 2 parameters,


 o 'routePath' e o 'method'...




 --> O VALUE DEFAULT SERÁ DE 'get'...









 --> MAS É CLARO QUE ISSO AÍ 

    _NÃO SERÁ UMA ATTRIBUTE CLASS, AINDA...









--> NO CASO, ISSO AINDA É UMA REGULAR PHP CLASS...









--> PARA __ FAZER_ COM QUE _ ISSO SEJA 
    1 ATTRIBUTE CLASS,


    PRECISAMOS __ ADICIONAR 


    O ATTRIBUTE DE 'Attribute'

    A ELA...





--> NO CASO,

    DEVEMOS ADICIONAR OUTRO 


    "#[]",




MAS NA CLASS EM SI...









TIPO ASSIM:





<?php declare(strict_types=1);

namespace App\Attributes;

// This is an example of how to create an attribute (and use it, in the HomeController.php file)

#[\Attribute]
class Route
{
    public function __construct(public string $routePath, string $method = 'get') {}
}














começamos assim, basicamente...










--> ISSO FEITO,


LÁ NO CONTROLLER DE HOMECONTROLLER,

PODEMOS IMPORTAR ESSA CLASS,

TIPO ASSIM:





<?php declare(strict_types=1);

namespace App\Attributes;

// This is an example of how to create an attribute (and use it, in the HomeController.php file)

#[\Attribute]
class Route
{
    public function __construct(public string $routePath, string $method = 'get') {}
}












E ASSIM:






<?php declare(strict_types=1);

namespace App\Controllers;

use App\Services\InvoiceService;
use App\View;

class HomeController
{
    public function __construct(private InvoiceService $invoiceService) {}

    #[Route('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }
}







MAS  ISSO NÃO É O BASTANTE...






É PQ __ ATTRIBUTES 'ARE JUST METADATA'...











--> WE NEED TO BUILD _ THE ACTUAL HANDLING 
    ON WHAT TO DO WITH THIS METADATA...











--> O QUE PRECISAMOS FAZER, PARA QUE ISSO FUNCIONE,

É:





''''WE NEED, SOME WAY OR ANOTHER, 
    TO GET __ THE ROUTE ATTRIBUTES FROM __ ALL THE METHODS,
    OF ALL THE CONTROLLERS, AND REGISTER THE ROUTES 
    AUTOMATICALLY....''
















--> BASICAMENTE, PRECISAMOS GANHAR ACESSO ao 'Route' attribute...   
    COM ACESSO A ESSE ATTRIBUTE, PRECISAMOS GANHAR 
    ACESSO 

    AO 'Route',



    E AÍ, DE ALGUMA FORMA, REGISTRAR __ ESSA ROUTE (de '/'), 

    COM O METHOD DE 'index()',

    
    NO CONTROLLER DE 

    HOMECONTROLLER...






--> BASICAMENTE, PRECISAMOS REPRODUZIR, COM ATTRIBUTES,
ESTE CÓDIGO AQUI:



$router
    ->get('/', [HomeController::class, 'index'])
    ->get('/examples/generator', [GeneratorExampleController::class, 'index']);














--> MAS PRECISAMOS FAZER ISSO AUTOMATICAMENTE,
    SEM MANUALMENTE REGISTRAR TODAS AS ROUTES...










--> PARA ACESSAR ATTRIBUTES,
    PRECISAMOS USAR A __ REFLECTION API_...










--> SE ABRIMOS OS DOCS DE REFLECTION API,



ENCONTRAMOS QUE 


''ReflectionClass has a method called '::getAttributes()''...







--> ESSE METHOD FAZ O RETURN DE 1 ARRAY __DE ATTRIBUTE 
OBJECTS (no caso, 'ReflectionAttribute')..





---> AÍ, COM ISSO,


    PODEMOS CHAMAR OS METHODS DE '->getName()' 

                                    E 

                                '->getArguments()',

                                nesse object, para 

                                CONSEGUIRMOS FURTHER INFORMATION...









--> OK... MAS A PERGUNTA É: ONDE DEVEMOS CONSTRUIR ESSA LÓGICA?












--> O LUGAR MAIS ÓBVIO SERIA O NOSSO 'Router.php',
    A CLASS,

    pq 

    É 

    NESSE LOCAL QUE 

    ESTAMOS CONSTRUINDO A ROUTING LOGIC..








-> ATUALMENTE, O CÓDIGO DESSE ROUTER ESTÁ ASSIM:













<?php

declare(strict_types=1);

namespace App;

use App\Exceptions\RouteNotFoundException;

class Router
{
    private array $routes = [];

    public function __construct(private Container $container)
    {
    }

    public function register(string $requestMethod, string $route, callable|array $action): self
    {
        $this->routes[$requestMethod][$route] = $action;

        return $this;
    }

    public function get(string $route, callable|array $action): self
    {
        return $this->register('get', $route, $action);
    }

    public function post(string $route, callable|array $action): self
    {
        return $this->register('post', $route, $action);
    }

    public function routes(): array
    {
        return $this->routes;
    }

    public function resolve(string $requestUri, string $requestMethod)
    {
        $route = explode('?', $requestUri)[0];
        $action = $this->routes[$requestMethod][$route] ?? null;

        if (! $action) {
            throw new RouteNotFoundException();
        }

        if (is_callable($action)) {
            return call_user_func($action);
        }

        [$class, $method] = $action;

        if (class_exists($class)) {
            $class = $this->container->get($class);

            if (method_exists($class, $method)) {
                return call_user_func_array([$class, $method], []);
            }
        }

        throw new RouteNotFoundException();
    }
}


















--> OK...









--> O PROFESSOR EXPLICA QUE PODEMOS ADICIONAR 1 METHOD DENTRO DESSA CLASS,

1 METHOD DE NOME 


 

 'registerRoutesFromAttributes() {}'













 --> O PROFESSOR ESCREVE ASSIM:









 public function registerRoutesFromControllerAttributes() {

 }











EX:





<?php declare(strict_types=1);

namespace App;

use App\Exceptions\RouteNotFoundException;

class Router
{
    private array $routes = [];

    public function __construct(private Container $container) {}

    public function registerRoutesFromControllerAttributes() {}
















OK... MAS PRECISAMOS DE ALGUM TRUQUE 

PARA  

CONSEGUIR 

ACESSAR 

TODOS OS CONTROLLERS DE NOSSO APP...





--> PRECISAMOS ACESSAR TODOS ESSES CONTROLLERS PARA QUE 
    CONSIGAMOS CRIAR 'ReflectionClass' objects (para que consigamos pegar os ReflectionAttribute dessas classes/controllers)...










--> BEM, HÁ 
    ALGUMAS MANEIRAS DE FAZER ISSO...








    AS MANEIRAS SÃO:






1) ''ITERATE OVER THE CONTROLLERS DIRECTORY, AND THEN GET ALL CONTROLLERS THAT WAY...''





    --> OK... MAS, PARA ISSO, PRECISARÍAMOS GARANTIR QUE 
        O RESULT SEJA CACHEADO EM ALGUM LUGAR, TUDO PARA QUE 
        NÃO TENHAMOS QUE FAZER ISSO 'EVERY SINGLE TIME' que 1 request chega,

        para que não enfrentemos performance issues... (pq, dependendo de nosso use-case,
                                                        o folder de controllers pode ficar bem largo)



2) ''WE CAN ACCEPT A LIST OF CONTROLLERS, VIA CONSTRUCTOR, 
    WITHIN OUR ROUTER CLASS, OR VIA the registerRoutesFromControllerAttributes method...''



        --> IN THIS CASE, THE TEACHER IS GOING TO ACCEPT IT IN THE METHOD...



        --> WE ACCEPT AN ARRAY OF CONTROLLERS, IN THIS METHOD...



        --> AND THEN WE CALL THAT METHOD, FROM 'index.php'...



        TIPO ASSIM:





    




    public function registerRoutesFromControllerAttributes(array $controllers) {}











E ASSIM:






<?php declare(strict_types=1);

use App\Controllers\GeneratorExampleController;
use App\Controllers\HomeController;
use App\App;
use App\Config;
use App\Container;
use App\Router;

require_once __DIR__ . '/../vendor/autoload.php';

$dotenv = Dotenv\Dotenv::createImmutable(dirname(__DIR__));
$dotenv->load();

define('STORAGE_PATH', __DIR__ . '/../storage');
define('VIEW_PATH', __DIR__ . '/../views');

$container = new Container();
$router = new Router($container);

$router->registerRoutesFromControllerAttributes([
    HomeController::class,
    GeneratorExampleController::class,
]);

(new App(
    $container,
    $router,
    ['uri' => $_SERVER['REQUEST_URI'], 'method' => $_SERVER['REQUEST_METHOD']],
    new Config($_ENV)
))->run();













CERTO...










-> PASSAMOS NOSSOS CONTROLLERS LÁ...










 
O PROFESSOR ESCLARECE QUE HÁ MTAS MANEIRAS DIFERENTES DE IMPLEMENTAR 

ISSO... E ESTA IMPLEMENTAÇÃO NÃO DEVE SER USADA EM PRODUCTION....






PQ ELA NÃO TEM VÁRIAS FEATURES, COMO:




1) ROUTE PARAMETERS 


2) GROUPING 


3) MIDDLEWARE SUPPORT...









-> PARA PRODUCTION, DEVEMOS USAR AS ROUTING LIBRARIES MAIS WELL-MAINTAINED 
E USED...







CERTO...









--> ESTE É APENAS UM EXEMPLO DE COMO ATTRIBUTES PODEM SER USADOS...










->  COMEÇAMOS COM ESTE CÓDIGO:




    public function registerRoutesFromControllerAttributes(array $controllers) {}














--> e queremos LOOPAR POR DENTRO DE CADA CONTROLLER...








-> PARA ISSO, USAMOS 'foreach()',


TIPO ASSIM:








    public function registerRoutesFromControllerAttributes(array $controllers) {

        foreach($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);
        }

    }











--> CRIAMOS UM OBJECT DE 'ReflectionClass'


para cada 


CONTROLLER 



QUE FOI PASSADO...









EX:








    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);
        }
    }














com isso, estamos usando a REFLECTION API...










-> DEPOIS DISSO, O PROFESSOR DECIDE FAZER LOOP THROUGH ALL THE METHODS 
OF EACH CONTROLLER,

TIPO ASSIM:






    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);

            foreach ($reflectionController->getMethods() as $method) {
            }
        }
    }















DEPOIS DISSO, PODEMOS USAR '$method->getAttributes()',

PARA CONSEGUIR TODOS ATTRIBUTES DE CADA METHOD...



ex:






    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // * With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);

            // * Get all methods, of each controller.
            foreach ($reflectionController->getMethods() as $method) {
                // * Get all attributes, of each method.
                $attributes = $method->getAttributes();
            }
        }
    }















OK... MAS 1 PROBLEMA, AQUI, É QUE 

'getAttributes()'


RETORNA __ TODOS __ OS ATTRIBUTES ASSOCIADOS COM CADA METHOD... 


ENTRETANTO, NESSE CASO AQUI, SÓ NOS IMPORTAMOS COM OS METHODS RELACIONADOS COM 
'Route' (Route-specific)..





É POR ISSO QUE ESCREVEMOS ASSIM:








    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // * With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);

            // * Get all methods, of each controller.
            foreach ($reflectionController->getMethods() as $method) {
                // * Get all attributes related to the 'Route' attribute, routing-related, of each method.
                $attributes = $method->getAttributes(Route::class);
            }
        }
    }
















    --> ISSO É POSSÍVEL PQ A DEFINIÇÃO DE 

    'getAttributes' é assim:






    public function getAttributes(?string $name = null, int $flags = 0): array {}








    ISSO SIGNIFICA QUE O PRIMEIRO PARAMETER É UM NAME,

    É UM FULLY QUALIFIED CLASSNAME...






--> ''THE NAME OF AN ATTRIBUTE CLASS'' -> é por isso que podemos PASSAR O CLASSNAME DE 

'Route',


aquela class lá, que criamos antes:





<?php declare(strict_types=1);

namespace App\Attributes;

// This is an example of how to create an attribute (and use it, in the HomeController.php file)

#[\Attribute]
class Route
{
    public function __construct(public string $routePath, string $method = 'get') {}
}
















OK.... AGORA QUE TEMOS ACESSO A TODOS OS ROUTE ATTRIBUTES,

PRECISAMOS FAZER LOOP POR CADA ROUTE ATTRIBUTE,



''AND WE NEED TO CREATE AN INSTANCE OF THE ACTUAL ROUTE ATTRIBUTE CLASS,

TO HAVE ACCESS TO ITS PROPERTIES AND METHODS''...





ou seja,

uma instance da class mostrada  acima...





PRECISAMOS DE ACESSO A ELA PARA QUE TENHAMOS 
ACESSO 

AO '$routePath' e 

ao 


'$RouteMethod' parameters...







PRECISAMOS ACESSAR ISTO:




    public function __construct(public string $routePath, string $method = 'get') {}


PARA QUE CONSIGAMOS 


'REGISTER OUR ROUTES AUTOMATICALLY'....












É POR ISSO QUE VAMOS RODAR TIPO 



foreach($attributes as $attribute) {

    $route = $attribute->newInstance();
}









OU SEJA,



USAMOS 'newInstance()'

PARA CRIAR 

1 NOVA INSTANCE 



DE CADA 'ATTRIBUTE'...




(que será 1 object com routePath e routeMethod)...











CERTO... 








AÍ O PROFESSOR DESTACA:



'''THE VALIDATION ON THE 
    ATTRIBUTE CLASS __ DOES NOT _ HAPPEN 

    UNTIL A _NEW _INSTANCE_ OF THE _ ATTRIBUTE 
    IS CREATED....'''




    ''THIS MEANS THAT IF WE DID SOME MISTAKE FROM 
    WITHIN OUR 'ROUTE' CLASS, WITHIN THE CONSTRUCTOR 
    OR SOMETHING LIKE THAT, WE _ WOULD NOT BE ABLE TO 
    KNOW OR CATCH THE ERROR UNTIL A NEW INSTANCE OF THE 
    ATTRIBUTE CLASS GOT CREATED'''...






ok... o código inteiro ficou tipo assim:










    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // * With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);

            // * Get all methods, of each controller.
            foreach ($reflectionController->getMethods() as $method) {
                // * Get all attributes related to the 'Route' attribute, routing-related, of each method.
                $attributes = $method->getAttributes(Route::class);

                foreach ($attributes as $attribute) {
                    // * Get all routes, using each attribute.
                    $route = $attribute->newInstance();
                }
            }
        }
    }










    --> ok... 





AGORA QUE TEMOS UMA INSTANCE DA CLASS DE 'ATTRIBUTE',


FINALMENTE PODEMOS ACESSAR AS PROPERTIES DE 'routePath' e 'routeMethod'...





-> ALÉM DISSO, TAMBÉM TEMOS ACESSO AO 'CONTROLLER' 
                E ACESSO AOS METHOD NAMES,

                JUSTAMENTE PQ TEMOS ACESSO à '$controller' e '$method'...




        




--> É POR ISSO QUE JÁ PODEMOS 
    RODAR 

    '$this->register($route->method, $route->routePath);














NO CASO, O CÓDIGO COMPLETO FICA TIPO:



                    $this->register($route->method, $route->routePath, [$controller, $method->getName()]);











E TIPO ASSIM:





    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // * With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);

            // * Get all methods, of each controller.
            foreach ($reflectionController->getMethods() as $method) {
                // * Get all attributes related to the 'Route' attribute, routing-related, of each method.
                $attributes = $method->getAttributes(Route::class);

                foreach ($attributes as $attribute) {
                    // * Get all routes, using each attribute.
                    $route = $attribute->newInstance();

                    // Register each route:
                    $this->register($route->method, $route->routePath, [$controller, $method->getName()]);
                }
            }
        }
    }














OK... REFRESHAMOS A PÁGINA,
E TUDO FUNCIONA 

COMO ESPERADO..









--> DEPOIS DISSO, O PROFESSOR FAZ 1 DUMP DO ARRAY DE ROUTES,

PARA QUE CONSIGAMOS 

''SEE THE ROUTES BEING REGISTERED,
    WITHOUT THE NEED TO 'HIT' EVERY SINGLE 
    ROUTE THAT WE ARE GOING TO BE REGISTERING THROUGH 
    THE CONTROLLERS''





O PROFESSOR QUER DEMONSTRAR QUE ISSO ESTÁ FUNCIONANDO


SEM FAZER GET REQUESTS E ETC....








ELE ESCREVE TIPO ASSIM:




// *  With Attributes feature
$router->registerRoutesFromControllerAttributes([
    HomeController::class,
    GeneratorExampleController::class,
]);

print_r($router->routes());










CERTO...








AÍ ENXERGAMOS ISTO:





Array (
    
 [get] => Array (
     [/] => Array (
         [0] => App\Controllers\HomeController
          [1] => index 
          ) 
          ) )











    ou seja,


    É UM ASSOCIATIVE ARRAY,

    COM APENAS 1 ÚNICA ROUTE, QUE É A ROUTE DE 

    '/'....



    É A ÚNICA ROUTE QUE FOI REALMENTE REGISTERED...










--> CERTO... DEVEMOS REGISTRAR MAIS ALGUMAS ROUTES...






-> PODEMOS ADICIONAR A ROUTE DE 'index()'


LÁ DO 'GeneratorExampleController'...


TIPO ASSIM:













<?php declare(strict_types=1);

namespace App\Controllers;

use App\Attributes\Route;
use App\Models\Ticket;
use Generator;

class GeneratorExampleController
{
    public function __construct(private Ticket $ticketModel) {}

    // * Example of using attributes to implement routing:
    #[Route('/examples/generator')]
    public function index()
    {
        $tickets = $this->ticketModel->all();

        foreach ($tickets as $ticket) {
            echo $ticket['id'] . ': ' . substr($ticket['content'], 0, 15) . '<br />';
        }
    }

    private function lazyRange(int $start, int $end): Generator
    {
        for ($i = $start; $i <= $end; $i++) {
            yield $i * 5 => $i;
        }
    }
}














-> COMO ISSO, FICO COM ESTE PRINT, JÁ DE CARA:


















Array (
    [get] => Array (
         [/] => Array ( 
            [0] => App\Controllers\HomeController 
            [1] => index 
        )
    [/examples/generator] => Array (
         [0] => App\Controllers\GeneratorExampleController
         [1] => index 
          ) 
          ) 
        )










OU SEJA,

AGORA FICAMOS COM 2 ROUTES...




/ 

e 

/examples/generator...











--> CERTO... MAS AGORA O PROFESSOR QUER ADICIONAR MAIS ALGUMAS ROUTES,
    MAS ROUTES DE 'POST' E DELETE...









TIPO ASSIM:






<?php declare(strict_types=1);

namespace App\Controllers;

use App\Attributes\Route;
use App\Services\InvoiceService;
use App\View;

class HomeController
{
    public function __construct(private InvoiceService $invoiceService) {}

    #[Route('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }

    #[Route('/', 'post')]
    public function store() {}

    #[Route('/update', 'put')]
    public function update() {}
}















-> É CLARO QUE 'post'

NÃO PRECISARIA SER HARDCODADO AQUI...

PODERÍAMOS UTILIZAR ENUMS, POR EXEMPLO...







--> MAS VAMOS DEIXAR SÓ ASSIM, POR ENQUANTO...







SE REFRESHAMOS A PAGE, FICAMOS COM ISTO:
















Array ( 
    [get] => Array ( 

        [/] => Array ( 
            [0] => App\Controllers\HomeController 
            [1] => index ) 

        [/examples/generator] => Array (
             [0] => App\Controllers\GeneratorExampleController 
             [1] => index 
             ) ) 

    [post] => Array ( 
        [/] => Array ( 
            [0] => App\Controllers\HomeController 
            [1] => store ) )
            
    [put] => Array (
        [/update] => Array ( 
            [0] => App\Controllers\HomeController 
            [1] => update ) )
            
             )








COMO VC PODE VER, AGORA TEMOS ESSAS ROUTES DE 'POST' E 'PUT'...


















CERTO... AGORA DEVEMOS CONTINUAR...







OUTRO TÓPICO:












'''YOU CAN, ALSO, USE INHERITANCE AND IMPLEMENT 
    INTERFACES IN YOUR ATTRIBUTES, IF NEEDED...''









'''FOR EXAMPLE, WE COULD CREATE A 'RouteInterface',
    AND THEN __IMPLEMENT__ THAT INTERFACE IN THE Route 
    ATTRIBUTE...''''










tipo assim:







<?php declare(strict_types=1);

namespace App\Attributes;

// This is an example of how to create an attribute (and use it, in the HomeController.php file)

#[\Attribute]
class Route implements RouteInterface
{
    public function __construct(public string $routePath, public string $method = 'get') {}
}
















--> OK... AÍ PODEMOS CRIAR ESSA INTERFACE...








--> CRIAMOS 
ESSA INTERFACE NA PASTA DE 'INTERFACES'....






EX:








<?php declare(strict_types=1);

namespace App\Interfaces;

interface RouteInterface {}











E TUDO VAI FUNCIONAR, CONFORME O ESPERADO...















-- ''WE CAN ALSO CREATE 
    SUB-CLASSES, FOR SPECIFIC REQUEST METHODS...''





''RIGHT NOW, WE ARE HARCODING 'post' and 'put'...''










--> NO MOMENTO, ESTAMOS ESCREVENDO ASSIM:




    #[Route('/', 'post')]
    public function store() {}

    #[Route('/update', 'put')]
    public function update() {}













--> MAS SERIA LEGAL SE PUDÉSSEMOS ESCREVER ALGO COMO 




    #[Get('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }


    #[Post('/')]
    public function store() {}

    #[Put('/update')]
    public function update() {}












COM ISSO, O CÓDIGO FICARIA __ BEM MAIS STREAMLINED...










--> MAS COMO PODERÍAMOS FAZER ISSO FUNCIONAR?












-> PARA FAZER ISSO FUNCIONAR, 
    PODERÍAMOS CRIAR ESSES 3 ATTRIBUTE CLASSES,

    E AÍ __ FAZER __ EXTEND_ DA CLASS DE 'Route',


    TIPO ASSIM:









<?php declare(strict_types=1);

namespace App\Attributes;

#[\Attribute]
class Put extends Route
{
    public function __construct(public string $path)
    {
        parent::__construct($path, 'put');
    }
}











E, DEPOIS, ASSIM:








<?php declare(strict_types=1);

namespace App\Controllers;

use App\Attributes\Get;
use App\Attributes\Post;
use App\Attributes\Put;
use App\Attributes\Route;
use App\Services\InvoiceService;
use App\View;

class HomeController
{
    public function __construct(private InvoiceService $invoiceService) {}

    // #[Route('/')]
    #[Get('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }

    // #[Route('/', 'post')]
    #[Post('/')]
    public function store() {}

    // #[Route('/update', 'put')]
    #[Put('/update')]
    public function update() {}
}


















OK... E AÍ TESTAMOS...







MAS FICAMOS COM 1 ERROR:




Array ( ) 404 Page Not Found











--> QUER DIZER QUE A INHERITANCE FALHOU, DE CERTA FORMA...











-> quer dizer que todas nossas routes com o formato de 


''


    #[Get('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }

    #[Post('/')]
    public function store() {}

    #[Put('/update')]
    public function update() {}



'''







NÃO FORAM REGISTRADAS..








MAS PQ ISSO N FUNCIONOU?












-> A RAZÃO DE ISSO NÃO TER FUNCIONADO É 






'''WE ARE TELLING PHP, IN OUR Router.php 
class/file,

to get ATTRIBUTES (getAttributes()) from the 

ROUTER CLASS:''







               $attributes = $method->getAttributes(Route::class);








''HOWEVER, THE ATTRIBUTES IN THE HOMECONTROLLER 
 ARE ___NOT EXACTLY__ ROUTE OBJECTS, EVEN THOUGH 
 THEY EXTEND THE 'Route' ATTRIBUTE CLASS...''










 ''what we need to do, here, is tell the REFLECTION 
   METHOD TO 'GIVE US ANY __ ATTRIBUTE __ THAT EXTENDS THE 
   Route CLASS, OR ANY ATTRIBUTE THAT IS 'instanceof' the 
   Route class''...











--> para conseguir expressarmos isso,
    precisamos do SEGUNDO PARAMETER DE 'getAttributes',

    que é 


    '$flags'... 





    '$flags'--> 'IS THE CRITERIA BY _ WHICH_ THE ATTRIBUTE IS __ SEARCHED''..







-> QUER DIZER QUE PODEMOS 
    PASSAR UMA 'FLAG CONSTANT',
    PARA ESPECIFICAR QUE 




'''WE WANT ANY ATTRIBUTE __ 
    THAT __ IS __ INSTANCEOF the 
    'Route' class....''









--> ESSA FLAG CONSTANT, NO CASO,
    É UMA INT,

    MAS É UMA INT REPRESENTADA 


    PELA EXPRESSÃO 


    '\ReflectionAttribute::IS_INSTANCEOF'...




TIPO ASSIM:



            // * Get all methods, of each controller.
            foreach ($reflectionController->getMethods() as $method) {
                // * Get all attributes related to the 'Route' attribute, routing-related, of each method.
                $attributes = $method->getAttributes(Route::class, \ReflectionAttribute::IS_INSTANCEOF);














COM ISSO,


''NOW, EVERY ATTRIBUTE CLASS THAT IS _ INSTANCEOF _ THE 
'Route' CLASS _ SHOULD BE RETURNED...''













OK... COM ISSO, RECARREGAMOS A PÁGINA, E TUDO VOLTA A FUNCIONAR...
















OK... MAS HÁ MAIS ALGUMAS COISAS QUE O PROFESSOR QUER NOS MOSTRAR,

ANTES DE ACABARMOS...















OUTRA COISA:








''WE CAN LIMIT/RESTRICT 
    _ WHERE __ AN ATTRIBUTE_ 
    CAN BE USED....''








POR EXEMPLO, PODEMOS DIZER QUE 

O ATTRIBUTE DE 


'#[Get()]'



SÓ 

PODE SER USADO NOS METHODS,




E NÃO PODE SER LUGADO EM NENHUM OUTRO LUGAR...













-> ISSO PQ, ATUALMENTE,
    ESTAMOS UTILIZANDO OS ATTRIBUTES DE POST, GET E PUT 

    nos methods, sim,

    E NÃO EM CLASSES... NO CASO,
    NÃO HÁ RAZÃO PARA UTILIZÁ-LOS EM CLASSES...










--> SE ENTRAMOS NO CÓDIGO DE 'Get.php',

TEMOS ISTO:







<?php declare(strict_types=1);

namespace App\Attributes;

#[\Attribute]
class Get extends Route
{
    public function __construct(public string $path)
    {
        parent::__construct($path, 'get');
    }
}












--> COMO VC PODE VER, ESTAMOS USANDO 
    ESSE ATTRIBUTE DIRETAMENTE NA CLASS..


    ISSO ACONTECE/ACONTECEU 

    PQ 

    __REALMENTE É POSSÍVEL _ UTILIZAR 
    ATTRIBUTES 
    NAS CLASSES...






 
-->  CERTO, MAS 
    NO CASO DE 'GET/POST/PUT',

    NÃO QUEREMOS QUE ELES SEJAM UTILIZADOS EM COISAS QUE NÃO SEJAM METHODS..











-> ISSO PQ ATTRIBUTES PODEM SER UTILIZADOS 

    EM DIVERSAS COISAS DIFERENTES...



    AS COISAS POSSÍVEIS SÃO:




    _CLASS_ 
    _FUNCTION_
    _METHOD_
    _PROPERTY_
    _CLASS_CONSTANT_
    _PARAMETER_
    _ALL_
    _IS_REPEATABLE_






    public const TARGET_CLASS = 1;
    public const TARGET_FUNCTION = 2;
    public const TARGET_METHOD = 4;
    public const TARGET_PROPERTY = 8;
    public const TARGET_CLASS_CONSTANT = 16;
    public const TARGET_PARAMETER = 32;
    public const TARGET_ALL = 63;
    public const IS_REPEATABLE = 64;


    public function __construct(int $flags = self::TARGET_ALL)
    {
        $this->flags = $flags;
    }






--> NO CASO,


O DEFAULT É 


'TARGET_ALL'...










-> PODEMOS, COM ISSO,

    DECLARAR QUE NOSSO ATTRIBUTE 
    SÓ PODE SER USADO EM PROPERTIES,

    CLASSES,
    FUNCTIONS,


    METHODS,

    ETC ETC... OU, ENTÃO,

    COM TUDO ('ALL')...













--> PARA RESTRINGIR OS LOCAIS EM QUE SEU ATTRIBUTE PODE SER USADO,


BASTA ESCREVER '()',

E ENTÃO 



ALGUM VALUE COMO 'Attribute::TARGET_METHOD''..











TIPO ASSIM:











<?php declare(strict_types=1);

namespace App\Attributes;

#[\Attribute(Attribute::TARGET_METHOD)]  // with 'Attribute::TARGET_METHOD', we state that this attribute can only be used on methods.
class Get extends Route
{
    public function __construct(public string $path)
    {
        parent::__construct($path, 'get');
    }
}















--> COM ISSO,
    SE VC TENTAR USAR ESSE ATTRIBUTE EM QUALQUER LUGAR QUE N SEJA UM METHOD,

    VC FICARÁ COM 1 EXCEPTION...  





    -> MAS AQUI HÁ 1 CATCH:

            ''The exception will ONLY BE THROWN WHEN 
            THE INSTANCE IS CREATED...''











--> SE TENTAMOS COLOCAR ESSE ATTRIBUTE EM 1 PROPERTY, POR EXEMPLO,

FICAMOS 

COM UM WARNING, NO IDE:








''Attribute cannot be applied to a property because it does not 
contain the 'Attribute::TARGET_PROPERTY'' flag''..

















certo... mas para tentarmos forçar 1 error,


escrevemos assim:







<?php declare(strict_types=1);

namespace App\Controllers;

use App\Attributes\Get;
use App\Attributes\Post;
use App\Attributes\Put;
use App\Attributes\Route;
use App\Services\InvoiceService;
use App\View;

class HomeController
{
    #[Get('/')]
    private int $x;

}











(OU SEJA, ESCREVEMOS ESSE ATTRIBUTE, DESTINADO APENAS A METHODS,
EM 1 DE NOSSAS PROPERTIES)










-> OK... MAS MESMO COM ISSO, NÃO FICAMOS COM O THROW DE 1 EXCEPTION..








MAS PQ?





EXPLICAÇÃO:




'''AS WE EXPLAINED MINUTES AGO,
    THE __ VALIDATION__ ONLY HAPPENS_ 
    WHEN _A NEW __ INSTANCE_ IS CREATED...''




''THIS MEANS THAT WHEN 
    A NEW INSTANCE IS CALLED,


    IN THE HOMECONTROLLER,

    IN THE '$route = $attribute->newInstance()',


    THAT'S WHEN THE ACTUAL VALIDATION HAPPENS...''





''AND THIS IS ACTUALLY NEVER CALLED, FOR THIS 'private int $x' property...
    BECAUSE WE ARE ITERATING OVER THE CONTROLLERS' METHODS,
    AND WE ARE NOT GETTING THE CONTROLLERS' PROPERTIES...''

EX:









    public function registerRoutesFromControllerAttributes(array $controllers)
    {
        // * With this, we get access to each controller object of our app.
        foreach ($controllers as $controller) {
            $reflectionController = new \ReflectionClass($controller);

            // * Get all methods, of each controller.
            foreach ($reflectionController->getMethods() as $method) {
                // * Get all attributes related to the 'Route' attribute, routing-related, of each method.
                $attributes = $method->getAttributes(Route::class, \ReflectionAttribute::IS_INSTANCEOF);

                foreach ($attributes as $attribute) {
                    // * Get all routes, using each attribute.
                    $route = $attribute->newInstance();

                    // Register each route:
                    $this->register($route->method, $route->routePath, [$controller, $method->getName()]);
                }
            }
        }
    }







COMO RESULTADO DISSO,



''WE ARE NOT INSTANTIATING THAT attribute object,
  WHICH MEANS THE PROPER VALIDATION IS NOT BEING EXECUTED,
  WHICH IS WHY AN EXCEPTION IS NOT BEING THROWN...''










--> PARA TRIGGAR ESSA EXCEPTION,
    TERÍAMOS DE CHAMAR '->newInstance()'


    NO 'PROPERTY ATTRIBUTE'...







--> PARA TESTAR ISSO, PODEMOS RAPIDAMENTE PEGAR AS PROPRIEDADES 
    DO REFLECTED OBJECT...



    NO CASO, A PROPRIEDADE '$x',

    E AÍ TENTAR PEGAR O ATTRIBUTE DELA...





TIPO ASSIM:






$reflectionController = new \ReflectionClass($controller);


$property = $reflectionController->getProperty('x');


$attributes = $property->getAttributes(Route::class, \ReflectionAttribute::IS_INSTANCEOF);

foreach($attributes as $attribute) {

    $route = $attribute->newInstance();  /// ! THIS WILL RESULT IN AN EXCEPTION...
}









-> COM ISSO, COM ESSE SNIPPET AÍ,

FICAREMOS/FICARÍAMOS COM UMA EXCEPTION...







-> NO CASO, O FATAL ERROR SERÁ DE 



''Uncaught Error: Attribute "App\Attributes\Get" cannot target 
    property (allowed targets: method)''...







OU SEJA,

OS ÚNICOS NEGÓCIOS QUE PODEM SER TARGETTADOS SÃO METHODS,


POR CONTA DE NOSSA RESTRIÇÃO...










-> CERTO... 




OUTRO DETALHE:







    public const TARGET_CLASS = 1;
    public const TARGET_FUNCTION = 2;
    public const TARGET_METHOD = 4;
    public const TARGET_PROPERTY = 8;
    public const TARGET_CLASS_CONSTANT = 16;
    public const TARGET_PARAMETER = 32;
    public const TARGET_ALL = 63;
    public const IS_REPEATABLE = 64;













-> todas essas CONSTANTS são __BITMAPS__...







-> SIGNIFICA QUE PODEMOS USAR BITWISE OPERATIONS COM ELAS...



(tipo aquilo que vimos de ~EXCEPTION, e coisas assim, na parte de error handling)..










-> PODEMOS, COM ISSO, DIZER QUE ''TODOS OS TIPOS SÃO ACEITOS, MENOS METHOD, ETC ETC''..











--> PODEMOS DIZER ''QUEREMOS QUE SEJAM TARGETTAVEIS APENAS CLASSES, METHODS E CONSTANTS''.








-> TIPO ASSIM:




Attribute::TARGET_METHOD|Attribute::TARGET_CLASS









-> E ISSO FUNCIONA...













CERTO....









AGORA DEVEMOS SEGUIR EM FRENTE...











--> NESSAS CONSTANTS, TEMOS UMA INTERESSANTE,

QUE É 

'IS_REPEATABLE'...










-> EXPLICAÇÃO:






''BY DEFAULT, WE ARE ONLY ALLOWED 
  __ TO __ USE ATTRIBUTES__ ONE TIME __ 

  PER DECLARATION...''









COMO ASSIM?












-> BEM, PARA DEMONSTRAR, O PROFESSOR COMEÇA:









''LET'S SAY THAT WE WANT __ TO HAVE ANOTHER ROUTE
    LISTENING TO THE METHOD OF 'index()' on the 'HomeController''...









OU SEJA,

QUEREMOS ALGO TIPO ASSIM:






    #[Get('/')]
    #[Get('/home')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }









OU SEJA,


QUEREMOS QUE ESSAS 2 ROUTES SEJAM REGISTERED E QUE DISPAREM 

O METHOD DE 'index()', essa action aí...










-> o nosso IDE JÁ MARCA QUE 


''Attribute is not repeatable because it does NOT CONTAIN THE 
'Attribute::IS_REPEATABLE flag''...








-> E, SE RECARREGAMOS A PAGE, FICAMOS COM 1 ERROR...










--> PARA RESOLVER ISSO,
    DEVEMOS ADICIONAR A FLAG DE 'IS_REPEATABLE' ao attribute,

    TIPO ASSIM:









<?php declare(strict_types=1);

namespace App\Attributes;

#[\Attribute(\Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]  // with 'Attribute::TARGET_METHOD', we state that this attribute can only be used on methods.
class Get extends Route
{
    public function __construct(public string $path)
    {
        parent::__construct($path, 'get');
    }
}


















AGORA, SE VOLTAMOS AO HOME CONTROLLER,

PERCEBEMOS QUE O UNDERLINE SUMIU,

E QUE 

AGORA ESSAS 2 ROUTES 

APONTAM PARA O MESMO METHOD,

O INDEX METHOD, NO HOME CONTROLLER...








EX:








<?php declare(strict_types=1);

namespace App\Controllers;

use App\Attributes\Get;
use App\Attributes\Post;
use App\Attributes\Put;
use App\Attributes\Route;
use App\Services\InvoiceService;
use App\View;

class HomeController
{
    // #[Get('/')]
    // private int $x;

    public function __construct(private InvoiceService $invoiceService) {}

    // #[Route('/')]
    #[Get('/')]
    #[Get('/home')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }

    // #[Route('/', 'post')]
    #[Post('/')]
    public function store() {}

    // #[Route('/update', 'put')]
    #[Put('/')]
    public function update() {}
}














OK... TEMOS MAIS 1 DETALHE:








-- 'PLEASE NOTE THAT BOTH 
    POSITIONAL AND NAMED ARGUMENTS 
    __CAN __ BE USED, WHEN USING ATTRIBUTES 
    AND PASSING ARGUMENTS...''








OU SEJA,

PODERÍAMOS ESCREVER ALGO COMO 



#[Get(routePath: '/home')] 









ISSO PODE SER ÚTIL QUANDO VC TEM MTOS VALUES DIFERENTES A SEREM PASSADOS,
A 1 MESMO ATTRIBUTE...








-> OUTRO DETALHE:



''YOU COULD HAVE MULTIPLE DIFFERENT ATTRIBUTES 
    __ PER DECLARATION... YOU DON'T NEED IS_REPEATABLE 
    TO BE ENABLED, TO DO THAT...''








-> OU SEJA,
PODEMOS ESCREVER ALGO COMO:









    #[Get('/')]
    #[Post('/')]
    public function index(): View
    {
        $this->invoiceService->process([], 25);

        return View::make('index');
    }













ISSO FUNCIONA/FUNCIONARIA, PQ NÃO ESTAMOS REPETINDO 1 MESMO ATTRIBUTE,
E SIM ESTAMOS 


USANDO ATTRIBUTES DIFERENTES, EM 1 MESMO METHOD...














---> POR FIM, O PROFESSOR QUER NOS APONTAR QUE 


EXISTEM ALGUNS 'BUILT-IN ATTRIBUTES' NO PHP... 









-> O PROFESSOR ACHA QUE MAIS VÃO EXISTIR, NAS VERSIONS FUTURAS...







-> OS ATTRIBUTES 
    QUE JÁ EXISTEM 


    SÃO:





#[Deprecated]


e 


#[Jit] (just in time)...














OK... ACABAMOS...