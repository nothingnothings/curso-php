











NAS ÚLTIMAS AULAS, APRENDEMOS:






1) DATABASE ABSTRACTION LAYER (DBAL) 



2) DATA MAPPER PATTERN 





3) OBJECT RELATIONAL MAPPING (ORM)




4) MIGRATIONS 





5) ETC...











USAMOS LIBRARIES DO DOCTRINE COMO EXEMPLO,

PARA COBRIR ESSES TÓPICOS...















--> MAS AINDA NÃO COBRIMOS O 'ACTIVE RECORD PATTERN'...
















ACTIVE RECORD PATTERN --> É UMA OUTRA MANEIRA/STRATEGY 
                        USADA PARA IMPLEMENTAR 
                        ORMs...





LARAVEL FRAMEWORK ----> UTILIZA-SE 
                        DE 

                        ACTIVE RECORD PATTERN 

                        PARA 'POWER' 


                        SUA PRÓPRIA 

                        PACKAGE DE ORM,


                        QUE É O 'ELOQUENT'...














-> NESSE VIDEO E NO PRÓXIMO,
    APRENDEREMOS 1 POUCO SOBRE 'ELOQUENT'...











OK, MAS O QUE É 'ACTIVE RECORD PATTERN'?









--> descrição:


''The active record pattern is an approach to accessing data in a database.
    A database table or VIEW is  WRAPPED INTO A CLASS... Thus,
    an OBJECT INSTANCE is tied to a SINGLE ROW in the table. After the 
    creation of an object, a NEW ROW is added to the table, upon save. Any 
    object loaded gets its information from the database. When an object 
    is updated, the corresponding row in the table is also updated. The 
    wrapper class implements ACESSOR METHODS or properties for 
    EACH COLUMN IN THE TABLE OR VIEW...''











-> isso parece straightforward...










''UNLIKE DATA MAPPER PATTERN,
  WHERE THE PERSISTENCE/DATABASE LAYER 

  IS _ SEPARATED_ FROM THE OBJECTS/ENTITIES'',



 ''IN ''ACTIVE RECORD PATTERN'', THE DATABASE 
  IS TIED _DIRECTLY _ TO THE OBJECT....''










''WHEN YOU CREATE AN OBJECT 
    AND CALL SOME KIND OF 'save()' method,
    A NEW _ ROW _ IS REALLY ADDED TO THE TABLE...''





''THESE OBJECTS HAVE THE SAME METHODS, IN THE ACTIVE RECORD..'''










''BUT IN DATA MAPPER PATTERN, 
    IN THE DOCTRINE ORM,

    WE HAD ENTITIES WHERE THE _ PROPERTIES WERE 
    MAPPED TO TABLE COLUMNS, LIKE THIS:


    #[Column('amount', type: Types::DECIMAL, precision: 10, scale: 2)]
    private float $amount;  // using float for money is not a good idea, it's better to use decimal or string, in your database and your code.

    #[Column('invoice_number')]
    private string $invoiceNumber;

    #[Column('status')]
    private InvoiceStatus $status;



''












''BUT THE PERSISTENCE 
    OF ALL OF IT, TO BE ABLE TO PERSIST THESE OBJECTS 
    IN THE DATABASE, WE 

    __HAD__ TO USE ANOTHER SERVICE,


    LIKE THE 'EntityManager' class...''




EX:







$entityManager = \Doctrine\ORM\EntityManager::create(
    $params,
    \Doctrine\ORM\Tools\Setup::createAttributeMetadataConfiguration([__DIR__ . '/src/Entity'], true)
);


$invoice = (new Invoice())
            ->setAmount(45)
            ->setInvoiceNumber('1')
            ->setStatus(InvoiceStatus::Pending);

        

$entityManager->persist($invoice);









OU SEJA,



TÍNHAMOS DE USAR ESSE SERVICE AÍ,

QUE HANDLAVA 

'THE DATABASE RELATED STUFF'...









-> quer dizer que 

''WE WERE NOT 
    CALLING ANY 

    'save()' or 'update()'

    METHODS IN THE OBJECTS THEMSELVES...''









--> ''THE ENTITIES WERE/ARE 
    JUST LIKE PLAIN PHP OBJECTS,
    IN DOCTRINE ORM... THEY HAVE 
    NO IDEA HOW THE DATA IS PERSISTED''...










---> COM O ACTIVE RECORD, ENTRETANTO,
     OS OBJECTS SÃO CAPAZES DE 

     __REALIZAR_ ACTUAL _ DATABASE QUERIES,

     INCLUSIVE/INCLUDING 


     A ACTUAL_ _ABILIDADE DE 'persist' 

     a data, por meio do method de '->save()'...





    TIPO ASSIM:





    
$invoice = (new Invoice())
            ->setAmount(45)
            ->setInvoiceNumber('1')
            ->setStatus(InvoiceStatus::Pending)
            ->save();

        











--> CERTO...

    ESSA É UMA DAS MAJOR DIFFERENCES 


    ENTRE 'DATA MAPPER PATTERN' 

    E 

        'ACTIVE RECORD PATTERN'...















OBS::


não vamos cobrir tudo sobre o 'eloquent' nessa aula,


PQ ESSE CURSO NÃO É FOCADO NO LARAVEL/ELOQUENT...








VEREMOS APENAS OS BASICS DO ELOQUENT,


PARA SABER:


1) WHAT IT IS 


2) HOW IT WORKS 


3) HOW THE ACTIVE RECORD PATTERN IS IMPLEMENTED...













PODEMOS ACTUALLY USAR O 'ELOQUENT'


EXTERNAMENTE AO LARAVEL...








-> 'ITS KINDOF A COMPONENT ITSELF'...






--> QUER DIZER QUE PODEMOS INSTALÁ-LO EM UM PROJETO 

PHP VANILLA...











MAS EM 1 APP DE VERDADE,
VC NAO VAI FAZER ISSO, PQ FARÁ MT MAIS SENTIDO 

USAR 

O LARAVEL FRAMEWORK INTEIRO, QUE JÁ TEM ESSE ELOQUENT EMBUTIDO...












--> MAS, AQUI, O PROFESSOR QUER INSTALAR O ELOQUENT COMO STANDALONE PACKAGE,
    nessa aula, pq ele só quer cobrir a parte do eloquent, nessa série..








-> PQ O SETUP DO LARAVEL É BEM EXTENSO...












--> PARA SETUPPAR 
    O ELOQUENT, PRECISAMOS:






1) DO COMPONENT 'DATABASE' DO LARAVEL,
    QUE EXISTE 



    em 

    'Illuminate/database'...







2) DO package de 'events' 
    DO LARAVEL,

    PARA CONSEGUIRMOS FAZER 'HOOK IN' AOS 

    EVENTS DO ELOQUENT...



    isso em 

    'Illuminate/events'











INSTALAMOS OS DOIS COM 



composer require Illuminate/database Illuminate/events







--> VAMOS USAR o arquivo 'eloquent_example.php' como 
    teste,

    PARA DEMONSTRA ALGUMAS DAS FEATURES DO ELOQUENT,
    ASSIM COMO FIZEMOS COM O DOCTRINE...







-- VAMOS COMPARAR O EXEMPLO DOCTRINE ORM 


COM O EXEMPLO ELOQUENT, PARA VER AS DIFERENÇAS 

ENTRE 



O DATA MAPPER E O ACTIVE RECORD PATTERNS...









--> NO DOCTRINE ORM, 

CRIAMS 1 INVOICE, E AÍ 

INVOICE ITEMS, USANDO O ENTITY MANAGER,

E AÍ 

OS ASSOCIAMOS, UM COM O OUTRO...





FIZEMOS ISSO COM ESTE CÓDIGO:






$invoice = (new \App\Entity\Invoice())
    ->setAmount(100)
    ->setInvoiceNumber('1')
    ->setStatus(InvoiceStatus::Pending)
    ->setCreatedAt(new \DateTime());

foreach ($items as [$description, $quantity, $unitPrice]) {
    $invoiceItem = (new \App\Entity\InvoiceItem())
        ->setDescription($item[0])
        ->setQuantity($item[1])
        ->setUnitPrice($item[2]);

    $invoice->addItem($invoiceItem);

    $invoice->getItems()->get(0)->setDescription('Foo bar');

    $invoice->flush();
    // $entityManager->persist($invoiceItem); // This is not needed, because we have 'cascade' set to 'persist' in the 'OneToMany' annotation, in the '$items' property, in the 'Invoice' entity.

    // $invoice->addItem($invoiceItem);
}

// This doesn't actually create data in the database, it just 'queues' the creation of the data, in the database.
$entityManager->persist($invoice);

$entityManager->flush();  // This actually creates the data in the database







-> VAMOS IMPLEMENTAR A MESMA COISA, MAS COM O ELOQUENT...











-> PARA COMEÇAR, PRECISAMOS DE UMA CONNECTION...











-> aBRIMOS O GITHUB REPO DO 
    'ILLUMINATE/DATABASE',

    PARA VER COMO PODEMOS SETTAR 1 CONNECTION..









---> EM USAGE INSTRUCTIONS,

    TEMOS ISTO:







First, create a new "Capsule" manager instance. Capsule aims to make configuring the library for usage outside of the Laravel framework as easy as possible.




use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Events\Dispatcher;
use Illuminate\Container\Container;
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();











podemos copiar e  colar esse snippet lá no arquivo eloquent_example.php.






tipo assim:












<?php declare(strict_types=1);

require_once './vendor/autoload.php';

use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Container\Container;
use Illuminate\Events\Dispatcher;

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();





















O CAPSULE MANAGER, NO CASO,


É 

'KINDOF' 

UM __ CENTRAL POINT,




EM QUE VC VAI SETTAR TUDO...










----> criamos o capsule com 


$capsule = new Capsule;











-> COMO ESTAMOS USANDO ENVIRONMENT VARIABLES,


TEMOS QUE EDITAR ESTE TRECHO AQUI:







$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);












VAMOS CARREGÁ-LOS DO ARQUIVO DE ENV,


USANDO PHPDOTENV....








EX:







<?php declare(strict_types=1);

use Dotenv\Dotenv;

require_once './vendor/autoload.php';

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Container\Container;
use Illuminate\Events\Dispatcher;

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















CERTO... MAS PRECISAMOS  AJUSTAR ALGUMAS DAS KEYS, AQUI...








AJUSTAMOS ELA, E DEIXAMOS ASSIM:













$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Container\Container;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;

$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();






















OK...











A PRÓXIMA PARTE É 



O _ sETUP _ DO EVENT DISPATCHER,

QUE É USADO PELOS MODELS DO ELOQUENT...












--> ISSO É FEITO COM ESTA LINHA:






$capsule->setEventDispatcher(new Dispatcher(new Container));














--> DEPOIS DISSO, 
    DEVEMOS SETTAR O 'capsule' COMO SENDO GLOBAL,
    CONTEXTO GLOBAL:





// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();












--> OK....












--> POR FIM, 

    ELE CHAMA O METHOD DE 'bootEloquent()',


    PARA SETTUPAR O ORM...




EX:






$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















CERTO...








COM ISSO, TEMOS O SETUP BÁSICO DO CAPSULE/ELOQUENT...












-> O PROFESSOR DECIDE FAZER OUTSOURCE 
    DE ESSE CÓDIGO DE SETUP EM 1 ARQUIVO SEPARADO...











--> ELE FAZ ISSO COM UM ARQUIVO DE 'eloquent.php',
    NO ROOT DO PROJETO...








TIPO ASSIM:








<?php declare(strict_types=1);

use Dotenv\Dotenv;

require_once './vendor/autoload.php';

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Container\Container;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;

$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















NO 'eloquent_example',


VAMOS IMPORTAR ESSE 'eloquent.php',



TIPO ASSIM:







<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';













É CLARO QUE EM 1 APP DE VERDADE, ISSO SERIA SETTADO 


DE FORMA 1 POUCO DIFERENTE...



NÓS FARÍAMOS O SETUP DO ELOQUENT 


NO MOMENTO DO BOOTSTRAP DE NOSSO APP...






--> VEREMOS UM EXEMPLO DISSO NA PRÓXIMA AULA,
    EM QUE VAMOS REFATORAR NOSSO MINI-APP PARA USAR 
    O ELOQUENT, EM VEZ DE DOCTRINE....









-> ANTES DE MAIS NADA, PRECISAMOS CRIAR ALGO CHAMADO DE 'MODELS'...









-> PODEM APARENTAR SER ENTITIES, MAS SÃO DIFERENTES...








-> DIFERENÇA:


''ENTITIES ARE JUST PLAIN PHP CLASSES,
 AND WE USE THE DATA MAPPER TO 
 MAP THE PROPERTIES TO DATA COLUMNS...''