











NAS ÚLTIMAS AULAS, APRENDEMOS:






1) DATABASE ABSTRACTION LAYER (DBAL) 



2) DATA MAPPER PATTERN 





3) OBJECT RELATIONAL MAPPING (ORM)




4) MIGRATIONS 





5) ETC...











USAMOS LIBRARIES DO DOCTRINE COMO EXEMPLO,

PARA COBRIR ESSES TÓPICOS...















--> MAS AINDA NÃO COBRIMOS O 'ACTIVE RECORD PATTERN'...
















ACTIVE RECORD PATTERN --> É UMA OUTRA MANEIRA/STRATEGY 
                        USADA PARA IMPLEMENTAR 
                        ORMs...





LARAVEL FRAMEWORK ----> UTILIZA-SE 
                        DE 

                        ACTIVE RECORD PATTERN 

                        PARA 'POWER' 


                        SUA PRÓPRIA 

                        PACKAGE DE ORM,


                        QUE É O 'ELOQUENT'...














-> NESSE VIDEO E NO PRÓXIMO,
    APRENDEREMOS 1 POUCO SOBRE 'ELOQUENT'...











OK, MAS O QUE É 'ACTIVE RECORD PATTERN'?









--> descrição:


''The active record pattern is an approach to accessing data in a database.
    A database table or VIEW is  WRAPPED INTO A CLASS... Thus,
    an OBJECT INSTANCE is tied to a SINGLE ROW in the table. After the 
    creation of an object, a NEW ROW is added to the table, upon save. Any 
    object loaded gets its information from the database. When an object 
    is updated, the corresponding row in the table is also updated. The 
    wrapper class implements ACESSOR METHODS or properties for 
    EACH COLUMN IN THE TABLE OR VIEW...''











-> isso parece straightforward...










''UNLIKE DATA MAPPER PATTERN,
  WHERE THE PERSISTENCE/DATABASE LAYER 

  IS _ SEPARATED_ FROM THE OBJECTS/ENTITIES'',



 ''IN ''ACTIVE RECORD PATTERN'', THE DATABASE 
  IS TIED _DIRECTLY _ TO THE OBJECT....''










''WHEN YOU CREATE AN OBJECT 
    AND CALL SOME KIND OF 'save()' method,
    A NEW _ ROW _ IS REALLY ADDED TO THE TABLE...''





''THESE OBJECTS HAVE THE SAME METHODS, IN THE ACTIVE RECORD..'''










''BUT IN DATA MAPPER PATTERN, 
    IN THE DOCTRINE ORM,

    WE HAD ENTITIES WHERE THE _ PROPERTIES WERE 
    MAPPED TO TABLE COLUMNS, LIKE THIS:


    #[Column('amount', type: Types::DECIMAL, precision: 10, scale: 2)]
    private float $amount;  // using float for money is not a good idea, it's better to use decimal or string, in your database and your code.

    #[Column('invoice_number')]
    private string $invoiceNumber;

    #[Column('status')]
    private InvoiceStatus $status;



''












''BUT THE PERSISTENCE 
    OF ALL OF IT, TO BE ABLE TO PERSIST THESE OBJECTS 
    IN THE DATABASE, WE 

    __HAD__ TO USE ANOTHER SERVICE,


    LIKE THE 'EntityManager' class...''




EX:







$entityManager = \Doctrine\ORM\EntityManager::create(
    $params,
    \Doctrine\ORM\Tools\Setup::createAttributeMetadataConfiguration([__DIR__ . '/src/Entity'], true)
);


$invoice = (new Invoice())
            ->setAmount(45)
            ->setInvoiceNumber('1')
            ->setStatus(InvoiceStatus::Pending);

        

$entityManager->persist($invoice);









OU SEJA,



TÍNHAMOS DE USAR ESSE SERVICE AÍ,

QUE HANDLAVA 

'THE DATABASE RELATED STUFF'...









-> quer dizer que 

''WE WERE NOT 
    CALLING ANY 

    'save()' or 'update()'

    METHODS IN THE OBJECTS THEMSELVES...''









--> ''THE ENTITIES WERE/ARE 
    JUST LIKE PLAIN PHP OBJECTS,
    IN DOCTRINE ORM... THEY HAVE 
    NO IDEA HOW THE DATA IS PERSISTED''...










---> COM O ACTIVE RECORD, ENTRETANTO,
     OS OBJECTS SÃO CAPAZES DE 

     __REALIZAR_ ACTUAL _ DATABASE QUERIES,

     INCLUSIVE/INCLUDING 


     A ACTUAL_ _ABILIDADE DE 'persist' 

     a data, por meio do method de '->save()'...





    TIPO ASSIM:





    
$invoice = (new Invoice())
            ->setAmount(45)
            ->setInvoiceNumber('1')
            ->setStatus(InvoiceStatus::Pending)
            ->save();

        











--> CERTO...

    ESSA É UMA DAS MAJOR DIFFERENCES 


    ENTRE 'DATA MAPPER PATTERN' 

    E 

        'ACTIVE RECORD PATTERN'...















OBS::


não vamos cobrir tudo sobre o 'eloquent' nessa aula,


PQ ESSE CURSO NÃO É FOCADO NO LARAVEL/ELOQUENT...








VEREMOS APENAS OS BASICS DO ELOQUENT,


PARA SABER:


1) WHAT IT IS 


2) HOW IT WORKS 


3) HOW THE ACTIVE RECORD PATTERN IS IMPLEMENTED...













PODEMOS ACTUALLY USAR O 'ELOQUENT'


EXTERNAMENTE AO LARAVEL...








-> 'ITS KINDOF A COMPONENT ITSELF'...






--> QUER DIZER QUE PODEMOS INSTALÁ-LO EM UM PROJETO 

PHP VANILLA...











MAS EM 1 APP DE VERDADE,
VC NAO VAI FAZER ISSO, PQ FARÁ MT MAIS SENTIDO 

USAR 

O LARAVEL FRAMEWORK INTEIRO, QUE JÁ TEM ESSE ELOQUENT EMBUTIDO...












--> MAS, AQUI, O PROFESSOR QUER INSTALAR O ELOQUENT COMO STANDALONE PACKAGE,
    nessa aula, pq ele só quer cobrir a parte do eloquent, nessa série..








-> PQ O SETUP DO LARAVEL É BEM EXTENSO...












--> PARA SETUPPAR 
    O ELOQUENT, PRECISAMOS:






1) DO COMPONENT 'DATABASE' DO LARAVEL,
    QUE EXISTE 



    em 

    'Illuminate/database'...







2) DO package de 'events' 
    DO LARAVEL,

    PARA CONSEGUIRMOS FAZER 'HOOK IN' AOS 

    EVENTS DO ELOQUENT...



    isso em 

    'Illuminate/events'











INSTALAMOS OS DOIS COM 



composer require Illuminate/database Illuminate/events







--> VAMOS USAR o arquivo 'eloquent_example.php' como 
    teste,

    PARA DEMONSTRA ALGUMAS DAS FEATURES DO ELOQUENT,
    ASSIM COMO FIZEMOS COM O DOCTRINE...







-- VAMOS COMPARAR O EXEMPLO DOCTRINE ORM 


COM O EXEMPLO ELOQUENT, PARA VER AS DIFERENÇAS 

ENTRE 



O DATA MAPPER E O ACTIVE RECORD PATTERNS...









--> NO DOCTRINE ORM, 

CRIAMS 1 INVOICE, E AÍ 

INVOICE ITEMS, USANDO O ENTITY MANAGER,

E AÍ 

OS ASSOCIAMOS, UM COM O OUTRO...





FIZEMOS ISSO COM ESTE CÓDIGO:






$invoice = (new \App\Entity\Invoice())
    ->setAmount(100)
    ->setInvoiceNumber('1')
    ->setStatus(InvoiceStatus::Pending)
    ->setCreatedAt(new \DateTime());

foreach ($items as [$description, $quantity, $unitPrice]) {
    $invoiceItem = (new \App\Entity\InvoiceItem())
        ->setDescription($item[0])
        ->setQuantity($item[1])
        ->setUnitPrice($item[2]);

    $invoice->addItem($invoiceItem);

    $invoice->getItems()->get(0)->setDescription('Foo bar');

    $invoice->flush();
    // $entityManager->persist($invoiceItem); // This is not needed, because we have 'cascade' set to 'persist' in the 'OneToMany' annotation, in the '$items' property, in the 'Invoice' entity.

    // $invoice->addItem($invoiceItem);
}

// This doesn't actually create data in the database, it just 'queues' the creation of the data, in the database.
$entityManager->persist($invoice);

$entityManager->flush();  // This actually creates the data in the database







-> VAMOS IMPLEMENTAR A MESMA COISA, MAS COM O ELOQUENT...











-> PARA COMEÇAR, PRECISAMOS DE UMA CONNECTION...











-> aBRIMOS O GITHUB REPO DO 
    'ILLUMINATE/DATABASE',

    PARA VER COMO PODEMOS SETTAR 1 CONNECTION..









---> EM USAGE INSTRUCTIONS,

    TEMOS ISTO:







First, create a new "Capsule" manager instance. Capsule aims to make configuring the library for usage outside of the Laravel framework as easy as possible.




use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Events\Dispatcher;
use Illuminate\Container\Container;
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();











podemos copiar e  colar esse snippet lá no arquivo eloquent_example.php.






tipo assim:












<?php declare(strict_types=1);

require_once './vendor/autoload.php';

use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Container\Container;
use Illuminate\Events\Dispatcher;

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();





















O CAPSULE MANAGER, NO CASO,


É 

'KINDOF' 

UM __ CENTRAL POINT,




EM QUE VC VAI SETTAR TUDO...










----> criamos o capsule com 


$capsule = new Capsule;











-> COMO ESTAMOS USANDO ENVIRONMENT VARIABLES,


TEMOS QUE EDITAR ESTE TRECHO AQUI:







$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);












VAMOS CARREGÁ-LOS DO ARQUIVO DE ENV,


USANDO PHPDOTENV....








EX:







<?php declare(strict_types=1);

use Dotenv\Dotenv;

require_once './vendor/autoload.php';

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Container\Container;
use Illuminate\Events\Dispatcher;

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















CERTO... MAS PRECISAMOS  AJUSTAR ALGUMAS DAS KEYS, AQUI...








AJUSTAMOS ELA, E DEIXAMOS ASSIM:













$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Container\Container;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;

$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();






















OK...











A PRÓXIMA PARTE É 



O _ sETUP _ DO EVENT DISPATCHER,

QUE É USADO PELOS MODELS DO ELOQUENT...












--> ISSO É FEITO COM ESTA LINHA:






$capsule->setEventDispatcher(new Dispatcher(new Container));














--> DEPOIS DISSO, 
    DEVEMOS SETTAR O 'capsule' COMO SENDO GLOBAL,
    CONTEXTO GLOBAL:





// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();












--> OK....












--> POR FIM, 

    ELE CHAMA O METHOD DE 'bootEloquent()',


    PARA SETTUPAR O ORM...




EX:






$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















CERTO...








COM ISSO, TEMOS O SETUP BÁSICO DO CAPSULE/ELOQUENT...












-> O PROFESSOR DECIDE FAZER OUTSOURCE 
    DE ESSE CÓDIGO DE SETUP EM 1 ARQUIVO SEPARADO...











--> ELE FAZ ISSO COM UM ARQUIVO DE 'eloquent.php',
    NO ROOT DO PROJETO...








TIPO ASSIM:








<?php declare(strict_types=1);

use Dotenv\Dotenv;

require_once './vendor/autoload.php';

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Container\Container;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;

$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















NO 'eloquent_example',


VAMOS IMPORTAR ESSE 'eloquent.php',



TIPO ASSIM:







<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';













É CLARO QUE EM 1 APP DE VERDADE, ISSO SERIA SETTADO 


DE FORMA 1 POUCO DIFERENTE...



NÓS FARÍAMOS O SETUP DO ELOQUENT 


NO MOMENTO DO BOOTSTRAP DE NOSSO APP...






--> VEREMOS UM EXEMPLO DISSO NA PRÓXIMA AULA,
    EM QUE VAMOS REFATORAR NOSSO MINI-APP PARA USAR 
    O ELOQUENT, EM VEZ DE DOCTRINE....









-> ANTES DE MAIS NADA, PRECISAMOS CRIAR ALGO CHAMADO DE 'MODELS'...









-> PODEM APARENTAR SER ENTITIES, MAS SÃO DIFERENTES...








-> DIFERENÇA:


''ENTITIES ARE JUST PLAIN PHP CLASSES,
 AND WE USE THE DATA MAPPER TO 
 MAP THE PROPERTIES TO TABLE COLUMNS...''









 -> JÁ OS MODELS, NO ELOQUENT,

 POSSUEM ACESSO à DATABASE,

 E USAM 'MAGIC' 

 PARA HYDRATE OS MODELS...





 --> OS MESMOS MODELS PODEM SER USADOS 
    PARA RUN E BUILD QUERIES, E ASSIM POR DIANTE...












--> VAMOS CRIAR 1 MODEL PARA A INVOICE...





--> É POR ISSO QUE, NA PASTA DE 'Models',

criamos 'Invoice.php'...





EX:







<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{


    public function __construct() {}
}













podemos definir as partes específicas 
desse model por meio do override de certas 
propriedades, do base model,


e por meio do define de certos methods...









--> a primeira coisa que 


DEVEMOS FAZER É 


DEFINIR 

1 TABLE...





fazemos isso com a 
property 


protected $table = 'invoices';











O LARAVEL 

USA 'CONVENTION-BASED CONFIGURATIONS'


EM UM MONTE DE PARTES,

INCLUSIVE 


NO ELOQUENT...






--> SE VC SEGUE AS STANDARD 
CONVENTIONS,

VC NEM MESMO PRECISA 
SETTAR 1 BOA PARTE DO BOILERPLATE 
CODE...






--> NESSE CASO, POR EXEMPLO,


''We don't even need to define 
the property value of '$table' with 
our table name,

BECAUSE __THE__ CLASS NAME 
IS ALREADY GOING TO BE TURNED 
INTO PLURAL, CONVERTED INTO snake_case 
AND USED AS THE TABLE NAME''...






QUER DIZER QUE ISTO AQUI JÁ É LIDO 
AUTOMATICAMENTE:




class Invoice extends Model













--> OK....












--> PODERÍAMOS NOS 
    LIVRAR DA PROPERTY, MAS EU DEIXO 
    ELA ALI, MESMO ASSIM....











-> HÁ ALGUMAS OUTRAS COISAS QUE 
O LARAVEL ELOQUENT ASSUME, POR CONVENÇÃO...



EX:


''LARAVEL ELOQUENT 
    ASSUMES THAT THE ID 
    OF THE TABLE IS 
    THE __ PRIMARY_ _KEY,
    BY DEFAULT...''







'''IF WE HAVE/HAD ANOTHER KEY AS THE PRIMARY KEY
IN THE TABLE, WE CAN USE 
THE PROPERTY "protected $primaryKey = 'column_name'"
TO __ OVERRIDE THAT PRIMARY KEY DEFAULT...''












-> O ELOQUENT TAMBÉM 
    ASSUME QUE 
    SUAS PRIMARY 
    KEYS SÃO AUTOINCREMENTED 
    INTEGERS (convenção)






-> ''BUT IF WE HAVE/HAD A 
    NON-INCREMENTING PRIMARY KEY,
    WE CAN __ TURN THIS DEFAULT 
    OFF,

    WITH THE PROPERTY 

    '' public $incrementing = false; ''
















VAI FICANDO TIPO ASSIM:









<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    public function __construct() {}

}















CERTO...












--> TAMBÉM PODEMOS USAR '$keyType,'

PARA DEFINIR O TYPE DA PRIMARY 
KEY 

COMO SENDO ALGO DIFERENTE DE 'INTEGER',

como, por exemplo, 'string'...






EX:









<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.


    public function __construct() {}
}













O ELOQUENT TAMBÉM,

POR DEFAULT,




ESPERA QUE ALGUMAS 

COLUMNS DE TIPO 'timestamp'

VÃO EXISTIR NA SUA TABLE...










--> NO CASO,
 ELE ESPERA QUE JÁ EXISTIRÃO
 AS COLUMNS 


 DE 

 'created_at'

 e 


 'updated_at'...













--> ESSAS COLUMNS SERÃO SETTADAS 
AUTOMATICAMENTE PELO 
_ELOQUENT,
SEMPRE QUE

OS MODELS FOREM 'CREATED' OU 'UPDATED'...









--> NO NOSSO CASO,

    A TABLE DE 'invoices' 
    
    SÓ TEM A COLUMN DE 'created_at',
    E NÃO  TEM A COLUMN 


    DE 


    'updated_at'...






-> ISSO QUER DIZER QUE, SE 

TENTÁSSEMOS CRIAR OU UPDATAR 

1 MODEL NESSE EXATO MOMENTO,

ACABARÍAMOS TRIGGANDO 


1 ERROR DO LARAVEL ELOQUENT....










--> PARA CONTORNAR ESSE ERRO, PODEMOS:








1) ADICIONAR UM FIELD DE 'updated_at'
    NA NOSSA TABLE...






2) DESABILITAR COMPLETAMENTE ESSA FEATURE 
    DE 'created_at' e 'updated_at'
    TIMESTAMP FIELDS,



    por meio da property 

    de 


    'public $timestamps = false;'




    TIPO ASSIM:






<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}
}













CERTO...








OU, ALTERNATIVAMENTE,


PODEMOS DESABILITAR 
APENAS COLUMNS ESPECÍFICAS,



COMO 'CREATED_AT',




por meio da definição das CONSTANTS...










--> AS CONSTANTS SÃO:





1) const CREATED_AT 



2) const UPDATED_AT







--> vc pode OVERWRITTAR ELAS,
    deixar outros string values

    nelas (se vc quer definir sua column 
    correspondente como detentora de um 
    nome diferente dos defaults 'created_at' e 'updated_at'),


OU, ALTERNATIVAMENTE,

PODE DEFINIR SEUS VALUES COMO 'null',

PARA DESABILITÁ-LAS INTEIRAMENTE:









<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}


    const CREATED_AT = 'created_date';

    const UPDATED_AT = null;
}






















--> É POR ISSO QUE DEIXEI ESSA 


CONSTANT DE 'UPDATED_AT'



COMO SENDO null,

PARA DESABILITAR 



ESSE FIELD AÍ, pq não temos ele,

nessa table de nosso db...














--> CERTO...












--> AGORA VAMOS CRIAR O MODEL DE 'InvoiceItem'...











--> CRIAMOS ELE TIPO ASSIM:








<?php 


declare(strict_types=1);

namespace App\Models;

use App\Model;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly
}













--------> não precisamos especificar a table 
    property,

    mas eu especifico mesmo assim, 

    só para garantir...








--> O PROFESSOR APONTA QUE NÃO PRECISAMOS 

ESPECIFICAR 

$primaryKey 



ou 

$incrementing,



PQ ESSA TABLE TAMBÉM TEM OS DEFAULTS...












--> MAS PRECISAMOS DESLIGAR OS TIMESTAMPS,

PQ NÃO TEMOS NEM O FIELD DE 'created_at'

 nem o de 'updated_at'



 NA NOSSA TABLE..











 -> FAZEMOS ISSO TIPO ASSIM:




<?php


declare(strict_types=1);

namespace App\Models;

use App\Model;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;
}










CERTO...












isso feito,
 


 PRECISAMOS CRIAR A RELATIONSHIP 


 ENTRE A INVOICE 

 E OS INVOICE ITEMS...










 --> COM 'ENTITIES',


 TÍNHAMOS DEFINIDO 



 QUE A RELATION ERA 

 DE 



 ONE-TO-MANY....












 -> AGORA PRECISAMOS FAZER ISSO COM O LARAVEL..









 --> ABRIMOS OS DOCS DO LARAVEL ELOQUENT...
















-> OK...








--> TEMOS 'ONE-TO-MANY'...








One-TO-many 



e 


'ONE-TO-MAN (inverse) / Belongs to' 






SÃO AS NECESSÁRIAS NO NOSSO EXEMPLO...










--> PRECISAMOS USAR O 

METHOD DE '->hasMany()',


PARA AÍ 

ESPECIFICARMOS 


O RELATED MODEL...













-> PARA ISSO, VAMOS PRECISAR DE UM NOVO 


METHOD, lá em 'Invoice',



CUJO NOME SERÁ 'items()'....






TIPO ASSIM:






<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.



    public function items() {
        
    }
}










--> CERTO...







NOSSO MODEL, DO ELOQUENT,


SEMPRE TERÁ ESSE METHOD DE 'hasMany'....






NESSE METHOD DE 'items()',



PODEMOS 



fazer return de 


'$this->hasMany()',



E PASSAMOS 



O MODEL DE 'invoiceItem' 




COMO PARAMETER,

TIPO ASSIM:











    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }








OK... ISSO RETORNA A RELATION DE 'HASMANY'....







NOVAMENTE, O ELOQUENT ASSUME 


OS COLUMN NAMES POR CONVENTION,

MAS PODERÍAMOS OVERWRITTAR, 

SE QUISÉSSEMOS...










--> OS COLUMN NAMES, NESSE CASO,

SÃO 'PRESUMED' COMO SENDO:





1) em 'invoice_item', a column 'invoice_id', que é a foreign_key de invoice...



'foreignKey' -> é a PRIMARY KEY DO ''PARENT MODEL''... (o id)


2) 'localKey' --> é a key do 'invoice_item'...





''IF WE HAD DIFFERENT NAMES FOR THE PRIMARY KEYS 
AND WE WERE NOT USING THE PRIMARY KEY PROPERTY, 
WE COULD SPECIFY THERE 'foreignKey' and 'localKey' 
here....''








MAS COMO NÃO ESTAMOS FAZENDO ISSO, AQUI,

PODEMOS 

SIMPLESMENTE USAR OS DEFAULTS...











--> AGORA QUE SETTAMOS ESSE 'items'

    no invoice,


    DEVEMOS FAZER O INVERSO, MAS LÁ 

    NO 'invoiceItems'...






-> PRECISAMOS ESCREVER O 


'OneToMany (Inverse) / Belongs to ''











-> PARA ISSO, DEVEMOS CRIAR 

1 METHOD E RETORNAR ESSE TIPO DE RELATION,


TIPO ASSIM:





<?php


declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;

    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function invoice(): BelongsTo
    {

        return $this->belongsTo(Invoice::class);
    }
}







CERTO...






QUER DIZER QUE O COMBO É ESTE:



<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.


    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }
}


<?php


declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;

    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function invoice(): BelongsTo
    {

        return $this->belongsTo(Invoice::class);
    }
}










CERTO... AGORA DEVEMOS COMPARAR 



O INVOICE MODEL VS INVOICE ENTITY...













--> A DIFERENÇA ENTRE OS 2:





<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.


    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }
}













VS









#[Entity]
#[Table('invoices')]  // The table name to be used, for this entity ('Invoice' will be equal to the entries in the 'invoices' table).
#[HasLifecycleCallbacks]  // Needed to make the 'onPrePersist' method work.
class Invoice
{
    #[Id]
    #[Column('id'), GeneratedValue(strategy: 'AUTO')]  // GeneratedValue is an attribute that makes it so that the value of that column is automatically generated by the database. The default is 'AUTO', which is good enough for 'ID' fields...
    private int $id;

    #[Column('amount', type: Types::DECIMAL, precision: 10, scale: 2)]
    private float $amount;  // using float for money is not a good idea, it's better to use decimal or string, in your database and your code.

    #[Column('invoice_number')]
    private string $invoiceNumber;

    #[Column('status')]
    private InvoiceStatus $status;

    #[Column('created_at')]
    private \DateTime $createdAt;

    #[Column('due_date')]
    private \DateTime $dueDate;

    #[OneToMany(targetEntity: InvoiceItem::class, mappedBy: 'invoice', cascade: ['persist', 'remove'])]
    private Collection $items;

    public function __construct()
    {
        $this->items = new ArrayCollection();
    }

    public function getId(): int
    {
        return $this->id;
    }

    public function getAmount(): float
    {
        return $this->amount;
    }

    public function getInvoiceNumber(): string
    {
        return $this->invoiceNumber;
    }

    public function getStatus(): InvoiceStatus
    {
        return $this->status;
    }

    public function getCreatedAt(): \DateTime
    {
        return $this->createdAt;
    }

    public function setAmount(float $amount): self
    {
        $this->amount = $amount;

        return $this;
    }

    public function setInvoiceNumber(string $invoiceNumber): self
    {
        $this->invoiceNumber = $invoiceNumber;

        return $this;
    }

    public function setStatus(InvoiceStatus $status): self
    {
        $this->status = $status;

        return $this;
    }

    #[PrePersist]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        $this->createdAt = new \DateTime();
    }


    public function addItem(InvoiceItem $item): self
    {
        $item->setInvoice($this);  // this is the call that establishes the relationship between the 'Invoice' and 'InvoiceItem' entities.

        $this->items->add($item);

        return $this;
    }
}














COMO VC PODE VER,

FICAMOS COM MT MENOS CÓDIGO DO QUE O 

CÓDIGO 

DAS ENTITIES...






-> MT MENOS BOILERPLATE CODE...










--> ISSO PQ, COM ENTITIES,

TUDO É PRATICAMENTE 

'EXPLICITLY MAPPED' 

E 

'EXPLICITLY CONFIGURED'...









--> OUTRO DETALHE:



COM ENTITIES, NÓS TEMOS 1 MONTE DE PROPERTIES ESPECIFICADAS,

COM OS ATTRIBUTES EM CIMA...












--> JÁ COM Models do ELOQUENT,
    TEMOS NENHUMA DAQUELAS PROPERTIES ESPECIFICADAS...






---> ISSO É PQ, 
COM DATA MAPPER,

''WE MAP DATA PROPERTIES TO COLUMNS IN THE TABLES'...







POR OUTRO LADO, 

COM ACTIVE RECORD,


''THE TABLE COLUMNS 
    __BECOME _ THE 
    OBJECT'S PROPERTIES''...










->> HÁ UM POUCO DE MÁGICA, AQUI,

E VEREMOS ISSO EM AÇÃO LOGO LOGO...













--> COMO O PROFESSOR MENCIONOU ANTES,

AS TABLE COLUMNS SE TRANSFORMAM AS PROPERTIES DOS OBJECTS..










--> ISSO QUER DIZER QUE PODEMOS 

DEFINIR OS VALUES 

DE ESSAS PROPERTIES 



NO NOSSO CÓDIGO...











-> DIGAMOS QUE TEMOS A TABLE DE INVOICES..











--> FIELDS DE 




ID,
AMOUNT,
INVOICE_NUMBER,
status,
CREATED_AT,
DUE_DATE...







--> NÃO PRECISAMOS SETTAR AS COLUMNS DE 'ID' 
E 'CREATED_AT',

PQ 

AMBAS 

SERÃO 



SETTADAS AUTOMATICAMENTE, PARA NÓS,

PELO ELOQUENT,


MAS 

PODEMOS 
SETTAR O RESTO DAS COLUMNS...








--> BASTA ESCREVERMOS ASSIM:



<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';




$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
$invoice->due_date = new \DateTime('2023-01-01');















MAS VAMOS SETTAR 1 VALUE DIFERENTE EM 'due_date'...







-> QUEREMOS SETTAR O DUE DATE COMO SENDO 

10 DIAS NO FUTURO...









--> O LARAVEL USA UMA LIBRARY CHAMADA DE 'CARBON' 

PARA TRABALHAR 
COM DATES...







---> O CARBON É COMO UM NICE WRAPPER 
    AO REDOR DOS OBJECTS 'DATE' DO PHP,

    QUE PROVIDENCIA HELPER E FLUENT METHODS QUE 
    DEIXAM O TRABALHO COM DATES MAIS FÁCIL...






->  ALTERNATIVAMENTE,
    PODEMOS INSTANCIAR UM NOVO DATETIME OBJECT 
    E ENTAO USAR INTERVALS PARA ADICIONAR DAYS A ELE...




    OU, COM O CARBON, DE FORMA BEM MAIS FACILITADA,


    BASTA ESCREVER ASSIM:







$invoice->due_date = (new \Carbon\Carbon())->addDays(10);











PODEMOS INSTALAR O CARBON ASSIM:



composer require nesbot/carbon










FICA TIPO ASSIM:











<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';




$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
// $invoice->due_date = new \DateTime('2023-01-01'); // without Carbon.
$invoice->due_date = (new \Carbon\Carbon())->addDays(10);







CERTO...






FINALMENTE, DEPOIS DE RODARMOS O QUE QUERÍAMOS COM O MODEL 
DO INVOICE,


BASTA CHAMAR O METHOD DE 'save()',

PARA SALVAR AS CHANGES E ADICIONAR ESSE OBJECT NA DATABASE...






->  para isso, escrevemos 


'$invoice->save();'










 ISSO VAI ACABAR CRIANDO O RECORD NA TABLE...









 -> MAS ANTES DE CHAMARMOS ESSE 'save(),

 DEVEMOS ADICIONAR/CRIAR INVOICE ITEMS RELACIONADOS A ELE,


 E ASSOCIÁ-LOS A ELE...
















 -> PARA ISSO, ESCREVEMOS ASSIM:





 <?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';




$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
// $invoice->due_date = new \DateTime('2023-01-01'); // without Carbon.
$invoice->due_date = (new \Carbon\Carbon())->addDays(10);



$invoice->save();



$items = [['Item 1', 1, 15] , ['Item 2', 2, 20], ['Item 3', 3, 25]];

foreach($items as [$description, $quantity, $unitPrice]) {
    $item = new \App\Models\InvoiceItem();
    $item->description = $description;
    $item->quantity = $quantity;
    $item->unit_price = $unitPrice;
    $item->invoice_id = $invoice->id;
    $item->save();
}







EX:







$items = [['Item 1', 1, 15] , ['Item 2', 2, 20], ['Item 3', 3, 25]];

foreach($items as [$description, $quantity, $unitPrice]) {
    $item = new \App\Models\InvoiceItem();
    $item->description = $description;
    $item->quantity = $quantity;
    $item->unitPrice = $unitPrice;
    $item->invoice_id = $invoice->id;
    $item->save();
}










PODERÍAMOS TER ESSA LINHA,


''     $item->invoice_id = $invoice->id; '',




QUE DEFINIRIA O VALUE DO invoice_id 

de esses records como sendo 


o id daquele invoice anterior, sim,


MAS O PROFESSOR APONTA QUE 





''it is better to create 
    a proper association, by calling 
    THE RELATION-SPECIFIC METHOD...''








-> OK, ENTÃO... 






-_> PARA AS RELATIONS DE 'BELONGSTO',

    O METHOD ADEQUADO PARA ISSO É 


    'associate()'....




-_> É POR ISSO QUE CHAMAMOS 




$item->invoice()->associate($invoice);







-> COM ISSO, ASSOCIAMOS ESSE ITEM 

A ESSE INVOICE ESPECÍFICO....







FICA TIPO ASSIM:







$items = [['Item 1', 1, 15] , ['Item 2', 2, 20], ['Item 3', 3, 25]];

foreach($items as [$description, $quantity, $unitPrice]) {
    $item = new \App\Models\InvoiceItem();
    $item->description = $description;
    $item->quantity = $quantity;
    $item->unitPrice = $unitPrice;
    // $item->invoice_id = $invoice->id; // Instead of doing it like this, manually, use the 'associate' method, inside the object you want to relate this item to, as seen below, with 'associate()':
    $item->invoice()->associate($invoice);
    
    $item->save();
}










por fim, o method de 'save()'


É CHAMADO NO INVOICE ITEM,


para salvá-lo À database...













AGORA DEVEMOS TESTAR TUDO ISSO...











--> RODAMOS, E AÍ FICAMOS COM 
    1 ERRO...











--> É PQ O PROFESSOR ESCREVEU
 




$item->unitPrice,




QUANDO 



O NOME DEVERIA TER SIDO 'unit_price',


PARA SEGUIR O NAMING 

DA TABLE (que é o que conta,

nesse approach active record...)..













É POR ISSO QUE O CÓDIGO COMPLETO FICA ASSIM:



$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
// $invoice->due_date = new \DateTime('2023-01-01'); // without Carbon.
$invoice->due_date = (new \Carbon\Carbon())->addDays(10);



$invoice->save();



$items = [['Item 1', 1, 15] , ['Item 2', 2, 20], ['Item 3', 3, 25]];

foreach($items as [$description, $quantity, $unitPrice]) {
    $item = new \App\Models\InvoiceItem();
    $item->description = $description;
    $item->quantity = $quantity;
    $item->unit_price = $unitPrice;
    // $item->invoice_id = $invoice->id; // Instead of doing it like this, manually, use the 'associate' method, inside the object you want to relate this item to, as seen below, with 'associate()':
    $item->invoice()->associate($invoice);

    $item->save();
}















AÍ VC PODE ESTAR SE PERGUNTANDO:










'OK, MAS COMO DIABOS O LARAVEL SABE, DE CARA,
QUE ESSAS PROPERTIES 
SÃO MAPPEADAS A TABLE COLUMNS??W''







ISSO PQ NÓS NÃO CRIAMOS NENHUM TIPO DE MAPPING 
ENTRE 
AS PROPERTIES 

E AS TABLE COLUMNS...



E TAMBÉM NÃO TEMOS PROPERTIES ALGUMAS, NOS MODELS...









--> SE NENHUM MAPPING FOI CODADO,
    E SE NENHUMA PROPERTY FOI ESCRITA 
    DENTRO DOS MODELS,

    COMO ELE ESTÁ CONSIDERANDO TUDO ISSO?




--> COMO PODEMOS ACESSAR E MODIFICAR
    TODAS ESSAS TABLE COLUMNS, DESSA FORMA??




    PROFESSOR:

    ''THIS MUST MEAN THERE ARE SOME MAGIC GETTER 
    AND SETTER METHODS SET UP SOMEWHERE IN THE CLASS''....











--> JÁ COBRIMOS MAGIC SETTER E GETTER METHODS 
    EM AULAS ANTERIORES... 











--> O PROFESSOR ENTRA DENTRO DA CLASS DE 
    'Model'

    DO ELOQUENT...










-_> DENTRO DELA, ELE ENCONTRA 


UM MAGIC GETTER METHOD:







    /**
     * Dynamically retrieve attributes on the model.
     *
     * @param  string  $key
     * @return mixed
     */
    public function __get($key)
    {
        return $this->getAttribute($key);
    }











OK... 



TAMBÉM TEMOS O __set method...










BASICAMENTE, 


''WHENEVER WE SET A NON-EXISTING PROPERTY 
IN THIS OBJECT,
 
 IT ADDS A NEW 'ATTRIBUTE' 

 TO AN 'ATTRIBUTES' ARRAY... 


 ''




 ''AND, WHEN WE TRY TO ACCESS
  A NOT-EXISTING PROPERTY, 

  IT TRIES TO ACCESS THAT FROM THE ATTRIBUTES 
  ARRAY,


  WITH 


  'return $this->getAttribute($key);'










COMO ESTAMOS TRABALHANDO 


COM __ MAGIC _ PROPERTIES,



SEMPRE É MELHOR 


ADICIONAR DOC BLOCKS AOS NOSSOS MODELS,

PARA AJUDAR NOSSO IDE COM O AUTO-COMPLETE,


E PARA NOS AJUDAR NO FUTURO... 






PQ NÓS, NO FUTURO,

SABEREMOS QUE COLUMNS EXISTEM...












--> TUDO PARA TER AUTOCOMPLETE E UNDERLINING NO VSCODE...








--> PARA CONSERTAR ISSO, PODEMOS ADICIONAR OS DOC BLOCKS 


NOS MODELS,

TIPO ASSIM:






<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

// * Doc blocks should be provided, with your Eloquent Models, to generate better autocomplete for your fellow developers (and yourself):
/**
 * @property int $id
 * @property string $invoice_number
 * @property float $amount 
 * @property InvoiceStatus $status
 * @property Carbon $created_at
 * @property Carbon $due_date
 */
class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.


    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }
}













CERTO...











PODEMOS FAZER A MESMA COISA NO MODEL DE 'INVOICEITEM',

TIPO ASSIM:





<?php


declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;


/**
 * @property int $id 
 * @property int $invoice_id
 * @property string $description
 * @property int $quantity
 * @property float $unit_price
 */
class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;

    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function invoice(): BelongsTo
    {

        return $this->belongsTo(Invoice::class);
    }
}
















SE VOLTAMOS AO MAIN FILE DE NOSSO APP,


PERCEBEMOS QUE O AUTOCOMPLETE FOI ADICIONADO...







EX:










<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';




$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
// $invoice->due_date = new \DateTime('2023-01-01'); // without Carbon.
$invoice->due_date = (new \Carbon\Carbon())->addDays(10);



$invoice->save();



$items = [['Item 1', 1, 15] , ['Item 2', 2, 20], ['Item 3', 3, 25]];

foreach($items as [$description, $quantity, $unitPrice]) {
    $item = new \App\Models\InvoiceItem();
    $item->description = $description;
    $item->quantity = $quantity;
    $item->unit_price = $unitPrice;
    
    // $item->invoice_id = $invoice->id; // Instead of doing it like this, manually, use the 'associate' method, inside the object you want to relate this item to, as seen below, with 'associate()':
    $item->invoice()->associate($invoice);

    $item->save();
}

















CERTO... 













MAS É UMA IDEIA MELHOR EXECUTAR ESSE BLOCO DE CÓDIGO 

COMO 1 TRANSACTION....




ISSO PQ 

'IF SOMETHING GOES WRONG WHILE TRYING TO CREATE
THE INVOICEITEM,
NOTHING WILL HAPPEN (rollback)',


o que É MELHOR...










--> PODEMOS  CHAMAR TRANSACTION-RELATED 
METHODS 


LÁ __ DA CONNECTION EM SI....












--> PARA CONSEGUIR A CONNECTION EM SI,
    NESSE APPROACH DO ELOQUENT,


    DEVEMOS USAR 



A ESCRITA DE 



\Illuminate\Database\Capsule\Manager::connection();















EX


\Illuminate\Database\Capsule\Manager::connection(); // This provides us access to the database connection, which is used by the Eloquent ORM. We can use it to call rollback(), commit() and 'transaction()' (which works like transactional, will run a closure, everything inside of it, commit if everything goes right, and rollback if something goes wrong).













-_> vamos ESCREVER O CALL DO METHOD '->transaction()'...











'transaction()',


POR SUA VEZ,

EXIGE 1 CLOSURE,


POR ISSO VAMOS PASSAR TODO NOSSO CÓDIGO ANTERIOR,

DE CREATE DO INVOICE E CREATE DOS INVOICE ITEMS,

TIPO ASSIM:















\Illuminate\Database\Capsule\Manager::connection()->transaction(function() {

    $invoice = new \App\Models\Invoice();

    $invoice->amount = 45;
    $invoice->invoice_number = '1';
    $invoice->status = \App\Enums\InvoiceStatus::Pending;
    // $invoice->due_date = new \DateTime('2023-01-01'); // without Carbon.
    $invoice->due_date = (new \Carbon\Carbon())->addDays(10);
    $invoice->save();

    $items = [['Item 1', 1, 15] , ['Item 2', 2, 20], ['Item 3', 3, 25]];

    foreach($items as [$description, $quantity, $unitPrice]) {
        $item = new \App\Models\InvoiceItem();
        $item->description = $description;
        $item->quantity = $quantity;
        $item->unit_price = $unitPrice;
        // $item->invoice_id = $invoice->id; // Instead of doing it like this, manually, use the 'associate' method, inside the object you want to relate this item to, as seen below, with 'associate()':
        $item->invoice()->associate($invoice);
        $item->save();
    }
});









CERTO...











RODAMOS O CÓDIGO, E TUDO FUNCIONA...









CERTO...










OK... APRENDEMOS A CRIAR MODELS...







AGORA DEVEMOS VER COMO FUNCIONAM 'UPDATES'

COM ESSE SISTEMA...





DIGAMOS QUE QUEREMOS UPDATAR 


O STATUS 
DE UM 

DOS INVOICES,

DEIXAR COMO 'PAID'...






-> SE TEMOS ACESSO AO MODELO DE 'INVOICES',

ISSO É FÁCIL, 

PQ PODEMOS SIMPLESMENTE DEFINIR A PROPRIEDADE 'status' como paid,


depois chamar '->save()',

e aí acabamos...










--> MAS SE TEMOS APENAS 1 invoice_id,
    ou outro tipo de info,

    temos que fazer de forma diferente...











TEMOS ALGUMAS MANEIRAS DIFERENTES DE FAZER ISSO:









1) FAZENDO O RUN DE UM UPDATE, RAW,

COM A CLAUSE DE 'WHERE', COM O ID...





--> PARA ISSO, VAMOS USAR O 
MODEL DE 'Invoice'


COMO QUERY BUILDER, BASICAMENTE...






--> PARA ISSO,


PODEMOS ESCREVER ASSIM:









Invoice::query()-> 








ESSE STATIC METHOD, DE 'query()',

RETORNA UM _ QUERY BUILDER....






(É BEM PARECIDO COM O QUERY BUILDER 
DO DOCTRINE)








--> ASSIM COMO O QUERY BUILDER DO DOCTRINE,
    ESSES QUERY BUILDERS DOS MODELS DO ELOQUENT 
    FORNECEM 

    __FLUENT__ METHODS, QUE PODEM SER USADOS PARA CONSTRUIR 
    NOSSAS QUERIES...










-> NO NOSSO CASO, VAMOS CONSTRUIR UMA 

UPDATE QUERY, TIPO ASSIM:








Invoice::query()->where('id', '=', $invoiceId);










CERTO... DEPOIS DISSO, PRECISAMOS DO METHOD DE 'update()',

TIPO ASSIM:






Invoice::query()->where('id', '=', $invoiceId)->update();





EX:









Invoice::query()->where('id', '=', $invoiceId)->update();







DENTRO DE 'update()',



PRECISAMOS 


PASSAR __ 


1 LISTA DE VALUES QUE QUEREMOS UPDATAR...








NO NOSSO CASO, QUEREMOS UPDATAR 'status',

deixar como 'InvoiceStatus:Paid'...









Ex:





Invoice::query()->where('id', '=', $invoiceId)->update(['status' => InvoiceStatus::Paid]);
 








 OK... MAS AGORA FALTA O 'invoiceId'...








 --> fazemos hardcode do id, tipo assim:





Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);










OK... 









O OPERATOR É USADO NORMALMENTE...












--> SE DEIXAMOS SEM NENHUM OPERATOR COMO SEGUNDO PARAMETER,

O LARAVEL automaticamente ASSUME QUE 


ESTAMOS PEDINDO O OPERATOR DE '='...








ou seja:





ISTO:





Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);






É IGUAL A ISTO:







Invoice::query()->where('id', 5)->update(['status' => InvoiceStatus::Paid]);




















CERTO...











O PROFESSOR DESTACA, TAMBÉM, QUE 


QUANDO ESCREVEMOS ASSIM:





Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);









NÓS NÃO ESTAMOS USANDO PLACEHOLDERS...





QUER DIZER QUE NÃO ESTAMOS FAZENDO ALGO COMO ISTO:

Invoice::query()->where('id', '=', '?')










--> e isso torna nosso código VULNERÁVEL A SQL INJECTION...












--> QUER DIZER QUE ESTAMOS PASSANDO O VALUE DIRETAMENTE NO 
QUERY BUILDER...









--> A VANTAGEM, AQUI, É QUE O  LARAVEL 

''BINDS THE PARAMETERS, BEHIND THE SCENES, FOR US...''...







 
 --> PARA VISUALIZAR ISSO, PODEMOS USAR O METHOD DE 

 '->toSql()',


 PARA PEGAR O ACTUAL SQL CRIADO POR ESSE STATEMENT:



echo Invoice::query()->where('id', '=', 5)->toSql();











 -> PODEMOS FAZER ISSO,
    VER O QUE ACONTECE..









O QUE É printado é isto:







select * from 'invoices' where 'id' = ? 













OK.... QUER DIZER QUE ESSAS QUERIES SÃO 
BUILDADAS JÁ CONSIDERANDO PLACEHOLDERS, O QUE É ÓTIMO...









TIRAMOS ESSE 'toSql',

E AÍ RODAMOS ASSIM:



Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);









ISSO NOS RETORNA 


UM VALUE DE '1',


QUE É 

O NÚMERO 
DE ROWS 

AFETADOS POR ESSE UPDATE STATEMENT...















CERTO...







AQUI ESTAMOS FAZENDO UMA QUERY SIMPLES DE UPDATE,

MAS PODERÍAMOS ESCREVER QUERIES COMPLEXAS,
TANTO PARA SELECT COMO PARA UPDATES...









-> PODEMOS FAZER GROUP BYS,

JOINS,

COISAS NOS RELATED MODELS,

ETC...






--> ''NOW WE'LL CHANGE ANOTHER OF THE INVOICESTATUS 
    AS PAID,

    AND WE'LL ALSO FETCH ALL THE PAID INVOICES RIGHT BELOW,
    TO THEN DISPLAY THEIR ID, STATUS AND CREATED DATES...''











PARA ISSO, ESCREVEMOS TIPO ASSIM:








$invoiceId = 28;

Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);










AÍ VAMOS QUERER FETCHEAR TODAS AS PAID INVOICES...







PARA ISSO, ESCREVEMOS ASSIM:







$invoiceId = 28;

Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);


// Select all paid invoices:
Invoice::query()->where('status', InvoiceStatus::Paid)->select(['id', 'status', 'created_at']);











TIPO ISSO, ACHO...








o 'where' method RETORNA A BUILDER INSTANCE EM SI....




--> PARA ACTUALLY FETCHEAR AS 
    INVOICES, PRECISAMOS DO METHOD DE 'get()',

    e não 'select()'...



--> ESSE 'get()'

    RETORNA __ UMA COLLECTION _ DE INVOICE MODELS,

    UMA 'COLLECTION INSTANCE'...





--> O LARAVEL TEM UMA IMPLEMENTAÇÃO DE 'COLLECTION' PRÓPRIA...
    PODEMOS VER ISSO NOS DOCS...









--> PODEMOS ITERATE DIRETAMENTE SOBRE A COLLECTION,
    OU PODEMOS CHAMAR O METHOD DE 

    'each()'


    NESSA INstance de 'Collection',

    TIPO ASSIM:



// Select all paid invoices:
Invoice::query()
->where('status', InvoiceStatus::Paid)
->get()
->each(
    
);









O METHOD DE 'each()'
requer que vc passe 1 CLOSURE...







COMO PARAMETER DE ESSA CLOSURE,

VC DEVE 

TIPAR O MODEL QUE VC SELECIONOU (no caso, 'Invoice')...




EX:



// Select all paid invoices:
Invoice::query()
->where('status', InvoiceStatus::Paid)
->get()
->each(
    function(Invoice $invoice) {

    }
);












--> AÍ, DENTRO DE ESSE CLOSURE,
PODEMOS FAZER WHATEVER WE WANT COM ESSA INSTANCE 

DE INVOICE...








-> como queremos fazer ECHO do invoice id e status,


ESCREVEMOS TIPO ASSIM:





// Select all paid invoices:
Invoice::query()
->where('status', InvoiceStatus::Paid)
->get()
->each(
    function(Invoice $invoice) {
        echo $invoice->id . ', ' . $invoice->status->toString() . ', ' . $invoice->created_at->format('m/d/Y') . PHP_EOL;
    }
);





// * Update a specific invoice:
Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);

// * Select all paid invoices, then print them out:
Invoice::query()
    ->where('status', InvoiceStatus::Paid)
    ->get()
    ->each(
        function (Invoice $invoice) {
            echo $invoice->id . ', ' . $invoice->status->toString() . ', ' . $invoice->created_at->format('m/d/Y') . PHP_EOL;
        }
    );
















--> OK... MAS AO TENTARMOS FAZER ISSO, 

FICAMOS COM 1 ERROR, ESTE:









'Call to a member function toString() on int'...







--> BASICAMENTE, ISSO QUER DIZER QUE 
    O VALUE DE 'STATUS' ESTÁ SENDO 'HYDRATED' COMO 

    INTEGER,

    E NÃO ESTÁ SENDO CASTADO COMO 1 PROPER 'ENUM CASE'...



--> ISSO QUER DIZER QUE '->status'

NÃO É CONSIDERADO/CRIADO COMO 1 ENUM OBJECT,

E SIM É CONSIDERADO/CRIADO COMO 1 INTEGER...







QUER DIZER QUE NOSSO TYPEHINTING, LÁ EM 'Invoice',



DE TIPO 


''''
@property InvoiceStatus $status
'''




NÃO TEVE/TEM EFEITO ALGUM SOBRE O ACTUAL VALUE RETORNADO AQUI...








BASICAMENTE, OS VALUES SÃO HYDRATED 
SEM SER CASTADOS AOS TYPES APROPRIADOS...









--> OK... MAS O ELOQUENT NOS DEIXA 
    A OPÇAÕ DE DEFINIR O CASTING MANUALMENTE...










--. PARA ISSO, DEVEMOS IR ATÉ 

O MODEL DE 'Invoice',


E AÍ 

ADICIONAR 1 PROPERTY de '$casts',

EM QUE 

DEFINIREMOS AS PROPER CASTING RULES...






tipo assim:






/**
 * @property int $id
 * @property string $invoice_number
 * @property float $amount
 * @property InvoiceStatus $status
 * @property Carbon $created_at
 * @property Carbon $due_date
 */
class Invoice extends Model
{
    protected $casts = [];
















OK...







AQUI, NO CASO,


VAMOS DEFINIR QUE AS DATES DEVEM SER CASTADAS COMO 'datetime',




QUE 'due_date' deve ser castada como  'datetime' também,


e que 

status deve ser castado como aquele enum de InvoiceStatus,

TIPO ASSIM:








/**
 * @property int $id
 * @property string $invoice_number
 * @property float $amount
 * @property InvoiceStatus $status
 * @property Carbon $created_at
 * @property Carbon $due_date
 */
class Invoice extends Model
{
    protected $casts = [
        'created_at' => 'datetime',
        'due_date' => 'datetime',
        'status' => InvoiceStatus::class
    ];











CERTO...








COM ISSO, SE TENTAMOS RODAR O CÓDIGO DE ANTES,


NÃO FICAMOS MAIS COM 1 ERROR,


PQ AGORA 





O NEGÓCIO NÃO SERÁ MAIS 1 INTEGER,


E SIM 


SERÁ RETORNADO COMO 1 OBJECT DE 'InvoiceStatus' (enum)...







-> E AÍ É CONVERTIDO, O QUE FAZ COM QUE NÃO FIQUEMOS COM AQUELE ERROR...












---> OK.. AÍ TUDO FUNCIONA...











O PROFESSOR DESTACA QUE PODEMOS EXECUTAR ALGUNS 

METHODS ESTATICAMENTE NO MODEL DE 'Invoice',


EM VEZ DE CHAMAR O METHOD DE 'query()'

ANTES...











---> EXEMPLO:




PODEMOS CHAMAR 



'Invoice::where()',

DIRETAMENTE,


QUE ISSO AINDA FUNCIONARIA, 


MESMO SEM O CALL DE '::query()'
antes...




ou seja:







ISTO FUNCIONA:



Invoice::query()->where('id', '=', 5)





E ISTO TAMBÉM FUNCIONA:






Invoice::where('id', '=', 5)














ISSO TAMBÉM FUNCIONA...









---> MAS MESMO NÓS ESCREVENDO ASSIM,

    NÃO PODEMOS 

    CLICAR NO METHOD DE 'where' para abrir 
    sua definição,

    PQ ELE NÃO EXISTE DIRETAMENTE NO 


    MODEL DE 'Invoice'..









-> MAS, ENTÃO, COMO ISSO FUNCIONA?





--> ISSO FUNCIONA PQ HÁ 1 POUCO DE MÁGICA ENVOLVIDA...









---> SE ABRIMOS A CLASS DE 'Model' base,

    e aí 
    procuramos 

    pelo 
    magic method de 



    '__callStatic()',


    PERCEBEMOS QUE ELA TEM ESTE FORMATO:






    public static function __callStatic($method, $parameters)
    {
        return (new static)->$method(...$parameters);
    }








-> OU SEJA,

ELA BASICAMENTE 


instancia o MODEL EM SI,

E AÍ 
DEFERE 


A EXECUÇÃO DO METHOD CALL...





QUER DIZER QUE ELE ESTÁ BASICAMENTE TRADUZINDO SEU CÓDIGO,



PARA QUE ELE EXECUTE ISTO:




(new Invoice())->where();








OU SEJA,


ELE ESTÁ INSTANCIANDO A CLASS DE 'Invoice' mesmo assim...
 







 --> E É POR ISSO QUE 
 O METHOD de 'where()' (e outros)


 PODE SER CHAMADO DIRETAMENTE DEPOIS DE 'Invoice::',


 ''''ESTATICAMENTE''',


 TUDO POR CONTA DO MAGIC METHOD DE '__callStatic()'...








--> TAMBEM HÁ O MAGIC METHOD DE '__call()',




que acaba fazendo com que sua query fique com este formato:








(new Invoice())->newQuery()->where();
















-> O PROFESSOR ESTÁ 
    MOSTRANDO TUDO ISSO PARA NOS MOSTRAR 


    QUE NÃO HÁ NENHUMA MAGIA NEGRA,


    E
     SIM 



     A UTILIZAÇÃO DE MAGIC METHODS...










--> AGORA TEMOS MAIS 1 EXEMPLO DE UPDATE,
MAS, DESSA VEZ,

DA 'description'



DOS INVOICEITEMS....













--> PODERÍAMOS PROCURAR POR 1 InvoiceItem COM O INVOICE_ID,
    E AÍ UPDATAR A DESCRIPTION E AÍ 

    RODAR SAVE, SIM...










-> MAS PODEMOS TAMBÉM FAZER 1 UPDATE USANDO 

O MODEL DE 'Invoice',


em vez do model de 'InvoiceItem'...









--> QUEREMOS



''UPDATE 

    THE DESCRIPTION OF THE FIRST INVOICE ITEM,
    OF EACH INVOICE model...''
    ,


    DENTRO DE ESTE LOOP:





    ->each(
        function (Invoice $invoice) {
            echo $invoice->id . ', ' . $invoice->status->toString() . ', ' . $invoice->created_at->format('m/d/Y') . PHP_EOL;
        }
    );





OK, MAS COMO PODEMOS ACESSAR OS RELATED ITEMS,


DE CADA INVOICE?






-->  NÃO PODEMOS CHAMAR '$invoice->items()',


PQ ISSO NÃO VAI RETORNAR O 'InvoiceItem' model...




-> EM VEZ DISSO,
    ISSO RETORNA A RELATION DE 'HASMANY'...







--> ESSA RELATION É KINDOF UM QUERY BUILDER,
    O QUE QUER DIZER QUE 
    
    PODEMOS CONSTRUIR 1 QUERY COM ELE,

    PARA AÍ CHAMARMOS '->get()'


    PARA PEGAR A COLLECTION DE ITEMS....





tipo algo como 





$invoice->items()->where('description', 'awdwdwas')->update(['description' => 'foo bar']);












E ISSO FUNCIONARIA, SIM...


MAS O PROFESSOR QUER SER CAPAZ DE 


'ACCESS ALL OF THE INVOICE ITEM MODELS,
FROM THE INVOICE MODEL'...













--> PARA VER COMO FAZER ISSO,
    ESTUDAMOS OS 

    MAGIC GETTERS E SETTER METHODS,

    DENTRO DA CLASS 'Model' base, novamente:










encontramos o method de 'getAttribute()'...




DENTRO DELE,
TEMOS ISTO:






    public function getAttribute($key)
    {
        if (! $key) {
            return;
        }

        // If the attribute exists in the attribute array or has a "get" mutator we will
        // get the attribute's value. Otherwise, we will proceed as if the developers
        // are asking for a relationship's value. This covers both types of values.
        if (array_key_exists($key, $this->attributes) ||
            array_key_exists($key, $this->casts) ||
            $this->hasGetMutator($key) ||
            $this->hasAttributeMutator($key) ||
            $this->isClassCastable($key)) {
            return $this->getAttributeValue($key);
        }












ESSA SECTION TENTA PEGAR O ATTRIBUTE DO ARRAY DE 'attributes',

se ele existe ou se HÁ ALGUM MUTATOR METHOD....




-> DEPOIS DISSO, ELE CHECA SE 'THE CLASS ITSELF HAS THE GIVEN KEY'...








--> CASO CONTRÁRIO, 
    ELE TENTA PEGAR O VALUE DA RELATIONSHIP,

    com 

    'getRelationValue()'...











--> ISSO QUER DIZER, EM OUTRAS PALAVRAS:







'''IF WE ACCESS THE RELATED MODEL AS A REGULAR 
    PROPERTY, IT IS GOING TO LOAD THE RELATIONSHIP AND
    RETURN IT...''




--> É JUSTAMENTE POR ISSO QUE PODEMOS 

ESCREVER 


"$invoice->items"


em vez de 


"$invoice->items()",


E ISSO JÁ VAI RETORNAR A COLLECTION DE ITEMS...





--> COM ESSA COLLECTION DE ITEMS,
    podemos chamar 



    '->first()',

    para PEGAR O PRIMEIRO ITEM DE ESSA COLLECTION...






--> E AÍ PODEMOS DEFINIR ESSE ITEM  

    A 1 VARIABLE DE NOME '$item',TIPO ASSIM:




    // * Select all paid invoices, then print them out:
Invoice::query()
    ->where('status', InvoiceStatus::Paid)
    ->get()
    ->each(
        function (Invoice $invoice) {
            echo $invoice->id . ', ' . $invoice->status->toString() . ', ' . $invoice->created_at->format('m/d/Y') . PHP_EOL;

            // $invoice->items()->where('description', 'awdwdwas')->update(['description' => 'foo bar']);

            // * Select the first invoice item of each invoice:
            $item = $invoice->items()->first();
        }
    );














CERTO...









PODEMOS ENCONTRAR O ID DE CADA INVOICE_ITEM,


TIPO ASSIM:










    ->each(
        function (Invoice $invoice) {
            echo $invoice->id . ', ' . $invoice->status->toString() . ', ' . $invoice->created_at->format('m/d/Y') . PHP_EOL;

            // $invoice->items()->where('description', 'awdwdwas')->update(['description' => 'foo bar']);

            // * Select the first invoice item of each invoice:
            $item = $invoice->items()->first();

            var_dump($item->id);  // This will return the ID of the first invoice item of each invoice.
        }
    );













para adicionar 1 melhor typehinting/autocomplete a esses 

invoice_items,


podemos escrever assim, lá em 'Invoice':






/**
 * @property int $id
 * @property string $invoice_number
 * @property float $amount
 * @property InvoiceStatus  $status
 * @property Carbon $created_at
 * @property Carbon $due_date
 *
 * @property-read Collection $items
 */







 --> MAS O PROFESSOR DESTACA:






 '''STILL,
    GETTING RELATED ITEMS LIKE THIS __ 
    STILL EXECUTES THE ADDITIONAL QUERY...''






'''THERE ARE WAYS TO AVOID N+1 PROBLEMS AND 
THE EXECUTING OF MULTIPLE QUERIES, BUT THAT IS 
BEYOND THE SCOPE OF THIS SECTION...'''








--> MAS O PROFESSOR APONTA QUE 

'first()'


FICA DISPONÍVEL TANTO 


NA 'COLLECTION' COMO NO 'BUILDER'...













--> OU SEJA:




SE EXECUTAMOS ASSIM:



$invoice->items()->first();





ISSO USA A CLAUSE DE 'LIMIT' NA QUERY,


E AÍ 



SELECIONA APENAS 1 RECORD,

E FAZ O HYDRATE APENAS DE ESSE ÚNICO METHOD...











--> APESAR DE TEREM 1 APARÊNCIA SEMELHANTE,



ISTO:



$invoice->items()->first();



E 


ISTO:



$invoice->items->first();








NÃO SÃO A MESMA COISA...












-> O PRIMEIRO SELECIONA E FAZ HYDRATE APENAS  DO PRIMEIRO RECORD...











--> O SEGUNDO SELECIONA __ TODOS __ OS INVOICE ITEMS,
    TODOS ELES SÃO HYDRATED NA MEMORY,
    E AÍ 

    APENAS 

    PEGAMOS 


    O PRIMEIRO ITEM, NESSA COLLECTION, com o 'first()' 


    ( o que quer dizer que é bem mais intensivo,
    em questão de resources)...










-> CERTO...





--> ADICIONALMENTE,
    ALÉM DE 


    SER POSSÍVEL 

    SALVAR AS CHANGES EM 1 ITEM 


    COM '$item->save()',





também é possível 





FAZER __ PUSH__ DAS CHANGES/UPDATES 





DO INVOICE MODEL,

DIRETAMENTE...











--> FAZEMOS ISSO TIPO ASSIM:





Invoice::query()
    ->where('status', InvoiceStatus::Paid)
    ->get()
    ->each(
        function (Invoice $invoice) {
            echo $invoice->id . ', ' . $invoice->status->toString() . ', ' . $invoice->created_at->format('m/d/Y') . PHP_EOL;

            // $invoice->items()->where('description', 'awdwdwas')->update(['description' => 'foo bar']);

            // * Select the first invoice item of each invoice:
            $item = $invoice->items()->first();



            $item->description = 'Foo bar';


            $invoice->push(); // AQUI
        }
    );

















$invoice->push(); 








''THIS UPDATES THE INVOICE MODEL, ALONG WITH ITS RELATIONSHIPS''...













ESSE METHOD AÍ É ÚTIL JUSTAMENTE 

PQ 



''MAYBE WE ARE DOING SOME UPDATES ON THE INVOICE MODEL, 
TOO, MAYBE CHANGING THE invoice_number,

AND THEN WE MAYBE WANT TO UPDATE THE INVOICE ALONG WITH THE INVOICE ITEMS''...











--> BASICAMENTE, ISSO É USADO PARA 'UPDATE EVERYTHING AT ONCE'...




--> PQ SE VC CHAMAR APENAS '$invoice->save()',
ISSO 

__NÃO VAI___ UPDATE/CHANGE 

OS 


'InvoiceItem' na sua database automaticamente,



MAS o '->push()'

VAI...










---------------------------







POR FIM, TEMOS O ASSUNTO DO 'DELETE DE MODELS/ROWS'...










-> PODEMOS FAZER ISSO COM O CALL DO METHOD DE '->delete()' NOS OBJECTS...













TIPO ASSIM:





$item->delete();

















--> OK... AQUI, NO CASO, ESTAMOS CHAMANDO O DELETE 

NO 'HYDRATED MODEL', no invoiceItem hydrated,


MAS É CLARO QUE 
PODERÍAMOS 


CHAMAR 'delete' NA QUERY EM SI,


NO BUILDER EM SI..





TIPO ASSIM:







$invoice->items()->delete();









--> ISSO DELETA/DELETARIA __ TODOS OS ITEMS DE ESSE GIVEN INVOICE...









--> PODEMOS TAMBÉM RODAR QUERIEs com WHERE, 

TIPO ASSIM:



$invoice->items()->where('description', 'Item 2')->delete();










É CLARO QUE EXISTEM OUTRAS MANEIRAS PARA SELECT, UPDATE 
E DELETE MODELS....






-> BASICAMENTE, HÁ MTAS MANEIRAS DE FAZER AS MESMAS COISAS 

NO LARAVEL/ELOQUENT...


https://laracasts.com/series/30-days-to-learn-laravel-11








--> OUTRO DETALHE:






''WHILE LARAVEL PROTECTS US FROM SQL 
INJECTION BY THE PASS OF THE VARIABLES LIKE THIS,


YOU ARE NOT FULLY PROTECTED''...







-> VC NÃO ESTÁ TOTALMENTE PROTEGIDO PQ VC AINDA PODE:


1) BUILD RAW QUERIES 


2) PASS THE RAW QUERY STATEMENTS 



3) PASS UNSANITIZED AND UNTRUSTED DATA IN PLACES 
    WHERE PLACEHOLDERS ARE NOT ALLOWED...







--> ANTES DE ENVIAR QUALQUER DATA   UNTRUSTED       
    DIRETAMENTE NAS QUEWRIES,



    VC DEVE PRIMEIRAMENTE CHECAR SE AQUELE LUGAR 

    PERMITE 

    O USO DE PLACEHOLDERS...


    SE AQUELE LUGAR N PERMITIR,


    VC PRECISARÁ DE 1 ALLOW-LIST CUSTOMIZADA, 

    PARA IDENTIFICAR 



    SE O VALUE PASSADO EXISTE DENTRO DA PRE-DEFINED LIST...








TIPO ALGO ASSIM:





$column = 'status';


$allowedColumns = ['status'];

if (!in_array($column, $allowedColumns)) {
    throw Exception();
}



















OUTRA COISA:





''EM VEZ DE USAR O MODEL PARA CONSTRUIR 
AS QUERIES,


PODERÍAMOS CONSTRUIR AS QUERIES DIRETAEMNTE 



DA CLASS DE 'Capsule'...'''


TIPO ASSIM:









Capsule::connection()->query()->from('table_name');




Capsule::connection()->table('table_name')->where();





// \Illuminate\Database\Capsule\Manager::connection()->table('invoices')->where('status', InvoiceStatus::Paid)->get();

// var_dump($invoices);























CERTO...


A DIFERENÇA ENTRE RODAR ISTO:


\Illuminate\Database\Capsule\Manager::connection()->table('invoices')->where('status', InvoiceStatus::Paid)->get();




E ISTO:





// * Update a specific invoice:
Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);




É QUE O QUERYBUILDER 

QUE É RETORNADO 


PELO 
CAPSULEMANAGER 

NÃO É EXATAMENTE O MESMO QUERYBUILDER 



RETORNADO PELO 'ELOQUENT (pelo Invoice::, aqui...)...












--> ISSO É PQ O LARAVEL TEM 2 QUERY BUILDERS...

--> 1 DELES FUNCIONA COM O ELOQUENT...



--> O OUTRO É O BASE QUERY BUILDER...









ESTE:



\Illuminate\Database\Capsule\Manager::connection()->table('invoices')->where('status', InvoiceStatus::Paid)->get();




É O BASE QUERY BUILDER...






E 



ESTE:


 

// * Update a specific invoice:
Invoice::query()->where('id', '=', 5)->update(['status' => InvoiceStatus::Paid]);







É O ELOQUENT QUERY BUILDER...













--> SE ABRIMOS O CONSTRUCTOR DO ELOQUENT QUERY BUILDER, 
        PERCEBEMOS QUE O CONSTRUCTOR 
        USA O QUERY BUILDER DO LARAVEL..., 


        O BASE QUERY BUILDER... ELE APENAS FAZ COM QUE ELE FUNCIONE  


        COM O ELOQUENT...
    




QUER DIZER QUE O ELOQUENT QUERY BUILDER 



''ACCEPTS THE BASE QUERY BUILDER IN THE CONSTRUCTOR,

E BUILDS ON TOP OF IT, TO PROVIDE THE QUERY BUILDER FUNCTIONALITIES 

WITH THE ELOQUENT''...









--> A MESMA COISA ACONTECE COM COLLECTIONS, TEMOS DUAS NO LARAVEL:





1) AS ELOQUENT COLLECTIONS, QUE FUNCIONAM COM O ELOQUENT,

E UTILIZAM A BASE COLLECTION CLASS...





2) A BASE COLLECTION INSTANCE, DO LARAVEL...