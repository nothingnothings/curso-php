











NAS ÚLTIMAS AULAS, APRENDEMOS:






1) DATABASE ABSTRACTION LAYER (DBAL) 



2) DATA MAPPER PATTERN 





3) OBJECT RELATIONAL MAPPING (ORM)




4) MIGRATIONS 





5) ETC...











USAMOS LIBRARIES DO DOCTRINE COMO EXEMPLO,

PARA COBRIR ESSES TÓPICOS...















--> MAS AINDA NÃO COBRIMOS O 'ACTIVE RECORD PATTERN'...
















ACTIVE RECORD PATTERN --> É UMA OUTRA MANEIRA/STRATEGY 
                        USADA PARA IMPLEMENTAR 
                        ORMs...





LARAVEL FRAMEWORK ----> UTILIZA-SE 
                        DE 

                        ACTIVE RECORD PATTERN 

                        PARA 'POWER' 


                        SUA PRÓPRIA 

                        PACKAGE DE ORM,


                        QUE É O 'ELOQUENT'...














-> NESSE VIDEO E NO PRÓXIMO,
    APRENDEREMOS 1 POUCO SOBRE 'ELOQUENT'...











OK, MAS O QUE É 'ACTIVE RECORD PATTERN'?









--> descrição:


''The active record pattern is an approach to accessing data in a database.
    A database table or VIEW is  WRAPPED INTO A CLASS... Thus,
    an OBJECT INSTANCE is tied to a SINGLE ROW in the table. After the 
    creation of an object, a NEW ROW is added to the table, upon save. Any 
    object loaded gets its information from the database. When an object 
    is updated, the corresponding row in the table is also updated. The 
    wrapper class implements ACESSOR METHODS or properties for 
    EACH COLUMN IN THE TABLE OR VIEW...''











-> isso parece straightforward...










''UNLIKE DATA MAPPER PATTERN,
  WHERE THE PERSISTENCE/DATABASE LAYER 

  IS _ SEPARATED_ FROM THE OBJECTS/ENTITIES'',



 ''IN ''ACTIVE RECORD PATTERN'', THE DATABASE 
  IS TIED _DIRECTLY _ TO THE OBJECT....''










''WHEN YOU CREATE AN OBJECT 
    AND CALL SOME KIND OF 'save()' method,
    A NEW _ ROW _ IS REALLY ADDED TO THE TABLE...''





''THESE OBJECTS HAVE THE SAME METHODS, IN THE ACTIVE RECORD..'''










''BUT IN DATA MAPPER PATTERN, 
    IN THE DOCTRINE ORM,

    WE HAD ENTITIES WHERE THE _ PROPERTIES WERE 
    MAPPED TO TABLE COLUMNS, LIKE THIS:


    #[Column('amount', type: Types::DECIMAL, precision: 10, scale: 2)]
    private float $amount;  // using float for money is not a good idea, it's better to use decimal or string, in your database and your code.

    #[Column('invoice_number')]
    private string $invoiceNumber;

    #[Column('status')]
    private InvoiceStatus $status;



''












''BUT THE PERSISTENCE 
    OF ALL OF IT, TO BE ABLE TO PERSIST THESE OBJECTS 
    IN THE DATABASE, WE 

    __HAD__ TO USE ANOTHER SERVICE,


    LIKE THE 'EntityManager' class...''




EX:







$entityManager = \Doctrine\ORM\EntityManager::create(
    $params,
    \Doctrine\ORM\Tools\Setup::createAttributeMetadataConfiguration([__DIR__ . '/src/Entity'], true)
);


$invoice = (new Invoice())
            ->setAmount(45)
            ->setInvoiceNumber('1')
            ->setStatus(InvoiceStatus::Pending);

        

$entityManager->persist($invoice);









OU SEJA,



TÍNHAMOS DE USAR ESSE SERVICE AÍ,

QUE HANDLAVA 

'THE DATABASE RELATED STUFF'...









-> quer dizer que 

''WE WERE NOT 
    CALLING ANY 

    'save()' or 'update()'

    METHODS IN THE OBJECTS THEMSELVES...''









--> ''THE ENTITIES WERE/ARE 
    JUST LIKE PLAIN PHP OBJECTS,
    IN DOCTRINE ORM... THEY HAVE 
    NO IDEA HOW THE DATA IS PERSISTED''...










---> COM O ACTIVE RECORD, ENTRETANTO,
     OS OBJECTS SÃO CAPAZES DE 

     __REALIZAR_ ACTUAL _ DATABASE QUERIES,

     INCLUSIVE/INCLUDING 


     A ACTUAL_ _ABILIDADE DE 'persist' 

     a data, por meio do method de '->save()'...





    TIPO ASSIM:





    
$invoice = (new Invoice())
            ->setAmount(45)
            ->setInvoiceNumber('1')
            ->setStatus(InvoiceStatus::Pending)
            ->save();

        











--> CERTO...

    ESSA É UMA DAS MAJOR DIFFERENCES 


    ENTRE 'DATA MAPPER PATTERN' 

    E 

        'ACTIVE RECORD PATTERN'...















OBS::


não vamos cobrir tudo sobre o 'eloquent' nessa aula,


PQ ESSE CURSO NÃO É FOCADO NO LARAVEL/ELOQUENT...








VEREMOS APENAS OS BASICS DO ELOQUENT,


PARA SABER:


1) WHAT IT IS 


2) HOW IT WORKS 


3) HOW THE ACTIVE RECORD PATTERN IS IMPLEMENTED...













PODEMOS ACTUALLY USAR O 'ELOQUENT'


EXTERNAMENTE AO LARAVEL...








-> 'ITS KINDOF A COMPONENT ITSELF'...






--> QUER DIZER QUE PODEMOS INSTALÁ-LO EM UM PROJETO 

PHP VANILLA...











MAS EM 1 APP DE VERDADE,
VC NAO VAI FAZER ISSO, PQ FARÁ MT MAIS SENTIDO 

USAR 

O LARAVEL FRAMEWORK INTEIRO, QUE JÁ TEM ESSE ELOQUENT EMBUTIDO...












--> MAS, AQUI, O PROFESSOR QUER INSTALAR O ELOQUENT COMO STANDALONE PACKAGE,
    nessa aula, pq ele só quer cobrir a parte do eloquent, nessa série..








-> PQ O SETUP DO LARAVEL É BEM EXTENSO...












--> PARA SETUPPAR 
    O ELOQUENT, PRECISAMOS:






1) DO COMPONENT 'DATABASE' DO LARAVEL,
    QUE EXISTE 



    em 

    'Illuminate/database'...







2) DO package de 'events' 
    DO LARAVEL,

    PARA CONSEGUIRMOS FAZER 'HOOK IN' AOS 

    EVENTS DO ELOQUENT...



    isso em 

    'Illuminate/events'











INSTALAMOS OS DOIS COM 



composer require Illuminate/database Illuminate/events







--> VAMOS USAR o arquivo 'eloquent_example.php' como 
    teste,

    PARA DEMONSTRA ALGUMAS DAS FEATURES DO ELOQUENT,
    ASSIM COMO FIZEMOS COM O DOCTRINE...







-- VAMOS COMPARAR O EXEMPLO DOCTRINE ORM 


COM O EXEMPLO ELOQUENT, PARA VER AS DIFERENÇAS 

ENTRE 



O DATA MAPPER E O ACTIVE RECORD PATTERNS...









--> NO DOCTRINE ORM, 

CRIAMS 1 INVOICE, E AÍ 

INVOICE ITEMS, USANDO O ENTITY MANAGER,

E AÍ 

OS ASSOCIAMOS, UM COM O OUTRO...





FIZEMOS ISSO COM ESTE CÓDIGO:






$invoice = (new \App\Entity\Invoice())
    ->setAmount(100)
    ->setInvoiceNumber('1')
    ->setStatus(InvoiceStatus::Pending)
    ->setCreatedAt(new \DateTime());

foreach ($items as [$description, $quantity, $unitPrice]) {
    $invoiceItem = (new \App\Entity\InvoiceItem())
        ->setDescription($item[0])
        ->setQuantity($item[1])
        ->setUnitPrice($item[2]);

    $invoice->addItem($invoiceItem);

    $invoice->getItems()->get(0)->setDescription('Foo bar');

    $invoice->flush();
    // $entityManager->persist($invoiceItem); // This is not needed, because we have 'cascade' set to 'persist' in the 'OneToMany' annotation, in the '$items' property, in the 'Invoice' entity.

    // $invoice->addItem($invoiceItem);
}

// This doesn't actually create data in the database, it just 'queues' the creation of the data, in the database.
$entityManager->persist($invoice);

$entityManager->flush();  // This actually creates the data in the database







-> VAMOS IMPLEMENTAR A MESMA COISA, MAS COM O ELOQUENT...











-> PARA COMEÇAR, PRECISAMOS DE UMA CONNECTION...











-> aBRIMOS O GITHUB REPO DO 
    'ILLUMINATE/DATABASE',

    PARA VER COMO PODEMOS SETTAR 1 CONNECTION..









---> EM USAGE INSTRUCTIONS,

    TEMOS ISTO:







First, create a new "Capsule" manager instance. Capsule aims to make configuring the library for usage outside of the Laravel framework as easy as possible.




use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Events\Dispatcher;
use Illuminate\Container\Container;
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();











podemos copiar e  colar esse snippet lá no arquivo eloquent_example.php.






tipo assim:












<?php declare(strict_types=1);

require_once './vendor/autoload.php';

use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Container\Container;
use Illuminate\Events\Dispatcher;

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();





















O CAPSULE MANAGER, NO CASO,


É 

'KINDOF' 

UM __ CENTRAL POINT,




EM QUE VC VAI SETTAR TUDO...










----> criamos o capsule com 


$capsule = new Capsule;











-> COMO ESTAMOS USANDO ENVIRONMENT VARIABLES,


TEMOS QUE EDITAR ESTE TRECHO AQUI:







$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);












VAMOS CARREGÁ-LOS DO ARQUIVO DE ENV,


USANDO PHPDOTENV....








EX:







<?php declare(strict_types=1);

use Dotenv\Dotenv;

require_once './vendor/autoload.php';

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Database\Capsule\Manager as Capsule;

$capsule = new Capsule;

$capsule->addConnection([
    'driver' => 'mysql',
    'host' => 'localhost',
    'database' => 'database',
    'username' => 'root',
    'password' => 'password',
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
]);

// Set the event dispatcher used by Eloquent models... (optional)
use Illuminate\Container\Container;
use Illuminate\Events\Dispatcher;

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















CERTO... MAS PRECISAMOS  AJUSTAR ALGUMAS DAS KEYS, AQUI...








AJUSTAMOS ELA, E DEIXAMOS ASSIM:













$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Container\Container;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;

$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();






















OK...











A PRÓXIMA PARTE É 



O _ sETUP _ DO EVENT DISPATCHER,

QUE É USADO PELOS MODELS DO ELOQUENT...












--> ISSO É FEITO COM ESTA LINHA:






$capsule->setEventDispatcher(new Dispatcher(new Container));














--> DEPOIS DISSO, 
    DEVEMOS SETTAR O 'capsule' COMO SENDO GLOBAL,
    CONTEXTO GLOBAL:





// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();












--> OK....












--> POR FIM, 

    ELE CHAMA O METHOD DE 'bootEloquent()',


    PARA SETTUPAR O ORM...




EX:






$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















CERTO...








COM ISSO, TEMOS O SETUP BÁSICO DO CAPSULE/ELOQUENT...












-> O PROFESSOR DECIDE FAZER OUTSOURCE 
    DE ESSE CÓDIGO DE SETUP EM 1 ARQUIVO SEPARADO...











--> ELE FAZ ISSO COM UM ARQUIVO DE 'eloquent.php',
    NO ROOT DO PROJETO...








TIPO ASSIM:








<?php declare(strict_types=1);

use Dotenv\Dotenv;

require_once './vendor/autoload.php';

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

use Illuminate\Container\Container;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;

$capsule = new Capsule;

$params = [
    'host' => $_ENV['DB_HOST'],
    'username' => $_ENV['DB_USER'],
    'password' => $_ENV['DB_PASS'],
    'database' => $_ENV['DB_DATABASE'],
    'driver' => $_ENV['DB_DRIVER'] ?? 'mysql',
    'port' => $_ENV['DB_PORT'] ?? 3307,
    'charset' => 'utf8',
    'collation' => 'utf8_unicode_ci',
    'prefix' => '',
];

$capsule->addConnection($params);

// Set the event dispatcher used by Eloquent's models:
$capsule->setEventDispatcher(new Dispatcher(new Container));

// Make this Capsule instance available globally via static methods... (optional)
$capsule->setAsGlobal();

// Setup the Eloquent ORM... (optional; unless you've used setEventDispatcher())
$capsule->bootEloquent();

















NO 'eloquent_example',


VAMOS IMPORTAR ESSE 'eloquent.php',



TIPO ASSIM:







<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';













É CLARO QUE EM 1 APP DE VERDADE, ISSO SERIA SETTADO 


DE FORMA 1 POUCO DIFERENTE...



NÓS FARÍAMOS O SETUP DO ELOQUENT 


NO MOMENTO DO BOOTSTRAP DE NOSSO APP...






--> VEREMOS UM EXEMPLO DISSO NA PRÓXIMA AULA,
    EM QUE VAMOS REFATORAR NOSSO MINI-APP PARA USAR 
    O ELOQUENT, EM VEZ DE DOCTRINE....









-> ANTES DE MAIS NADA, PRECISAMOS CRIAR ALGO CHAMADO DE 'MODELS'...









-> PODEM APARENTAR SER ENTITIES, MAS SÃO DIFERENTES...








-> DIFERENÇA:


''ENTITIES ARE JUST PLAIN PHP CLASSES,
 AND WE USE THE DATA MAPPER TO 
 MAP THE PROPERTIES TO TABLE COLUMNS...''









 -> JÁ OS MODELS, NO ELOQUENT,

 POSSUEM ACESSO à DATABASE,

 E USAM 'MAGIC' 

 PARA HYDRATE OS MODELS...





 --> OS MESMOS MODELS PODEM SER USADOS 
    PARA RUN E BUILD QUERIES, E ASSIM POR DIANTE...












--> VAMOS CRIAR 1 MODEL PARA A INVOICE...





--> É POR ISSO QUE, NA PASTA DE 'Models',

criamos 'Invoice.php'...





EX:







<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{


    public function __construct() {}
}













podemos definir as partes específicas 
desse model por meio do override de certas 
propriedades, do base model,


e por meio do define de certos methods...









--> a primeira coisa que 


DEVEMOS FAZER É 


DEFINIR 

1 TABLE...





fazemos isso com a 
property 


protected $table = 'invoices';











O LARAVEL 

USA 'CONVENTION-BASED CONFIGURATIONS'


EM UM MONTE DE PARTES,

INCLUSIVE 


NO ELOQUENT...






--> SE VC SEGUE AS STANDARD 
CONVENTIONS,

VC NEM MESMO PRECISA 
SETTAR 1 BOA PARTE DO BOILERPLATE 
CODE...






--> NESSE CASO, POR EXEMPLO,


''We don't even need to define 
the property value of '$table' with 
our table name,

BECAUSE __THE__ CLASS NAME 
IS ALREADY GOING TO BE TURNED 
INTO PLURAL, CONVERTED INTO snake_case 
AND USED AS THE TABLE NAME''...






QUER DIZER QUE ISTO AQUI JÁ É LIDO 
AUTOMATICAMENTE:




class Invoice extends Model













--> OK....












--> PODERÍAMOS NOS 
    LIVRAR DA PROPERTY, MAS EU DEIXO 
    ELA ALI, MESMO ASSIM....











-> HÁ ALGUMAS OUTRAS COISAS QUE 
O LARAVEL ELOQUENT ASSUME, POR CONVENÇÃO...



EX:


''LARAVEL ELOQUENT 
    ASSUMES THAT THE ID 
    OF THE TABLE IS 
    THE __ PRIMARY_ _KEY,
    BY DEFAULT...''







'''IF WE HAVE/HAD ANOTHER KEY AS THE PRIMARY KEY
IN THE TABLE, WE CAN USE 
THE PROPERTY "protected $primaryKey = 'column_name'"
TO __ OVERRIDE THAT PRIMARY KEY DEFAULT...''












-> O ELOQUENT TAMBÉM 
    ASSUME QUE 
    SUAS PRIMARY 
    KEYS SÃO AUTOINCREMENTED 
    INTEGERS (convenção)






-> ''BUT IF WE HAVE/HAD A 
    NON-INCREMENTING PRIMARY KEY,
    WE CAN __ TURN THIS DEFAULT 
    OFF,

    WITH THE PROPERTY 

    '' public $incrementing = false; ''
















VAI FICANDO TIPO ASSIM:









<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    public function __construct() {}

}















CERTO...












--> TAMBÉM PODEMOS USAR '$keyType,'

PARA DEFINIR O TYPE DA PRIMARY 
KEY 

COMO SENDO ALGO DIFERENTE DE 'INTEGER',

como, por exemplo, 'string'...






EX:









<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.


    public function __construct() {}
}













O ELOQUENT TAMBÉM,

POR DEFAULT,




ESPERA QUE ALGUMAS 

COLUMNS DE TIPO 'timestamp'

VÃO EXISTIR NA SUA TABLE...










--> NO CASO,
 ELE ESPERA QUE JÁ EXISTIRÃO
 AS COLUMNS 


 DE 

 'created_at'

 e 


 'updated_at'...













--> ESSAS COLUMNS SERÃO SETTADAS 
AUTOMATICAMENTE PELO 
_ELOQUENT,
SEMPRE QUE

OS MODELS FOREM 'CREATED' OU 'UPDATED'...









--> NO NOSSO CASO,

    A TABLE DE 'invoices' 
    
    SÓ TEM A COLUMN DE 'created_at',
    E NÃO  TEM A COLUMN 


    DE 


    'updated_at'...






-> ISSO QUER DIZER QUE, SE 

TENTÁSSEMOS CRIAR OU UPDATAR 

1 MODEL NESSE EXATO MOMENTO,

ACABARÍAMOS TRIGGANDO 


1 ERROR DO LARAVEL ELOQUENT....










--> PARA CONTORNAR ESSE ERRO, PODEMOS:








1) ADICIONAR UM FIELD DE 'updated_at'
    NA NOSSA TABLE...






2) DESABILITAR COMPLETAMENTE ESSA FEATURE 
    DE 'created_at' e 'updated_at'
    TIMESTAMP FIELDS,



    por meio da property 

    de 


    'public $timestamps = false;'




    TIPO ASSIM:






<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}
}













CERTO...








OU, ALTERNATIVAMENTE,


PODEMOS DESABILITAR 
APENAS COLUMNS ESPECÍFICAS,



COMO 'CREATED_AT',




por meio da definição das CONSTANTS...










--> AS CONSTANTS SÃO:





1) const CREATED_AT 



2) const UPDATED_AT







--> vc pode OVERWRITTAR ELAS,
    deixar outros string values

    nelas (se vc quer definir sua column 
    correspondente como detentora de um 
    nome diferente dos defaults 'created_at' e 'updated_at'),


OU, ALTERNATIVAMENTE,

PODE DEFINIR SEUS VALUES COMO 'null',

PARA DESABILITÁ-LAS INTEIRAMENTE:









<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}


    const CREATED_AT = 'created_date';

    const UPDATED_AT = null;
}






















--> É POR ISSO QUE DEIXEI ESSA 


CONSTANT DE 'UPDATED_AT'



COMO SENDO null,

PARA DESABILITAR 



ESSE FIELD AÍ, pq não temos ele,

nessa table de nosso db...














--> CERTO...












--> AGORA VAMOS CRIAR O MODEL DE 'InvoiceItem'...











--> CRIAMOS ELE TIPO ASSIM:








<?php 


declare(strict_types=1);

namespace App\Models;

use App\Model;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly
}













--------> não precisamos especificar a table 
    property,

    mas eu especifico mesmo assim, 

    só para garantir...








--> O PROFESSOR APONTA QUE NÃO PRECISAMOS 

ESPECIFICAR 

$primaryKey 



ou 

$incrementing,



PQ ESSA TABLE TAMBÉM TEM OS DEFAULTS...












--> MAS PRECISAMOS DESLIGAR OS TIMESTAMPS,

PQ NÃO TEMOS NEM O FIELD DE 'created_at'

 nem o de 'updated_at'



 NA NOSSA TABLE..











 -> FAZEMOS ISSO TIPO ASSIM:




<?php


declare(strict_types=1);

namespace App\Models;

use App\Model;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;
}










CERTO...












isso feito,
 


 PRECISAMOS CRIAR A RELATIONSHIP 


 ENTRE A INVOICE 

 E OS INVOICE ITEMS...










 --> COM 'ENTITIES',


 TÍNHAMOS DEFINIDO 



 QUE A RELATION ERA 

 DE 



 ONE-TO-MANY....












 -> AGORA PRECISAMOS FAZER ISSO COM O LARAVEL..









 --> ABRIMOS OS DOCS DO LARAVEL ELOQUENT...
















-> OK...








--> TEMOS 'ONE-TO-MANY'...








One-TO-many 



e 


'ONE-TO-MAN (inverse) / Belongs to' 






SÃO AS NECESSÁRIAS NO NOSSO EXEMPLO...










--> PRECISAMOS USAR O 

METHOD DE '->hasMany()',


PARA AÍ 

ESPECIFICARMOS 


O RELATED MODEL...













-> PARA ISSO, VAMOS PRECISAR DE UM NOVO 


METHOD, lá em 'Invoice',



CUJO NOME SERÁ 'items()'....






TIPO ASSIM:






<?php

declare(strict_types=1);

namespace App\Models;

use App\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.



    public function items() {
        
    }
}










--> CERTO...







NOSSO MODEL, DO ELOQUENT,


SEMPRE TERÁ ESSE METHOD DE 'hasMany'....






NESSE METHOD DE 'items()',



PODEMOS 



fazer return de 


'$this->hasMany()',



E PASSAMOS 



O MODEL DE 'invoiceItem' 




COMO PARAMETER,

TIPO ASSIM:











    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }








OK... ISSO RETORNA A RELATION DE 'HASMANY'....







NOVAMENTE, O ELOQUENT ASSUME 


OS COLUMN NAMES POR CONVENTION,

MAS PODERÍAMOS OVERWRITTAR, 

SE QUISÉSSEMOS...










--> OS COLUMN NAMES, NESSE CASO,

SÃO 'PRESUMED' COMO SENDO:





1) em 'invoice_item', a column 'invoice_id', que é a foreign_key de invoice...



'foreignKey' -> é a PRIMARY KEY DO ''PARENT MODEL''... (o id)


2) 'localKey' --> é a key do 'invoice_item'...





''IF WE HAD DIFFERENT NAMES FOR THE PRIMARY KEYS 
AND WE WERE NOT USING THE PRIMARY KEY PROPERTY, 
WE COULD SPECIFY THERE 'foreignKey' and 'localKey' 
here....''








MAS COMO NÃO ESTAMOS FAZENDO ISSO, AQUI,

PODEMOS 

SIMPLESMENTE USAR OS DEFAULTS...











--> AGORA QUE SETTAMOS ESSE 'items'

    no invoice,


    DEVEMOS FAZER O INVERSO, MAS LÁ 

    NO 'invoiceItems'...






-> PRECISAMOS ESCREVER O 


'OneToMany (Inverse) / Belongs to ''











-> PARA ISSO, DEVEMOS CRIAR 

1 METHOD E RETORNAR ESSE TIPO DE RELATION,


TIPO ASSIM:





<?php


declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;

    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function invoice(): BelongsTo
    {

        return $this->belongsTo(Invoice::class);
    }
}







CERTO...






QUER DIZER QUE O COMBO É ESTE:



<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.


    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }
}


<?php


declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InvoiceItem extends Model
{
    protected $table = 'invoice_items'; // used if you want to define the corresponding table name explicitly

    public $timestamps = false;

    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function invoice(): BelongsTo
    {

        return $this->belongsTo(Invoice::class);
    }
}










CERTO... AGORA DEVEMOS COMPARAR 



O INVOICE MODEL VS INVOICE ENTITY...













--> A DIFERENÇA ENTRE OS 2:





<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Invoice extends Model
{
    protected $table = 'invoices'; // used if you want to define the corresponding table name explicitly

    protected $primaryKey = 'invoice_uid'; // we define a 'primaryKey' property if we want to use a field that isn't 'ID' as the primary key of this specific table. 

    protected $incrementing = false; // we define this property to tell Laravel that we don't want to use the auto-incrementing feature of the database

    protected $keyType = 'string'; // we define this property to tell Laravel that we want to use a string as the type of the primary key of this specific table.

    protected $timestamps = false; // we define this property to tell Laravel that we don't want to use the timestamps feature (created_at and updated_at) of the database

    public function __construct() {}

    const CREATED_AT = 'created_date'; // we define a 'created_at' property if we want to use a field that isn't 'created_at' as the column name of the 'created_at' column of this specific table.

    const UPDATED_AT = null; // we define a 'updated_at' property as null if we don't want to use/don't have a field that isn't 'updated_at' as the column name of the 'updated_at' column of this specific table.


    // * This is what sets the relation between the Invoice and the InvoiceItem
    public function items()
    {
        return $this->hasMany(InvoiceItem::class);
    }
}













VS









#[Entity]
#[Table('invoices')]  // The table name to be used, for this entity ('Invoice' will be equal to the entries in the 'invoices' table).
#[HasLifecycleCallbacks]  // Needed to make the 'onPrePersist' method work.
class Invoice
{
    #[Id]
    #[Column('id'), GeneratedValue(strategy: 'AUTO')]  // GeneratedValue is an attribute that makes it so that the value of that column is automatically generated by the database. The default is 'AUTO', which is good enough for 'ID' fields...
    private int $id;

    #[Column('amount', type: Types::DECIMAL, precision: 10, scale: 2)]
    private float $amount;  // using float for money is not a good idea, it's better to use decimal or string, in your database and your code.

    #[Column('invoice_number')]
    private string $invoiceNumber;

    #[Column('status')]
    private InvoiceStatus $status;

    #[Column('created_at')]
    private \DateTime $createdAt;

    #[Column('due_date')]
    private \DateTime $dueDate;

    #[OneToMany(targetEntity: InvoiceItem::class, mappedBy: 'invoice', cascade: ['persist', 'remove'])]
    private Collection $items;

    public function __construct()
    {
        $this->items = new ArrayCollection();
    }

    public function getId(): int
    {
        return $this->id;
    }

    public function getAmount(): float
    {
        return $this->amount;
    }

    public function getInvoiceNumber(): string
    {
        return $this->invoiceNumber;
    }

    public function getStatus(): InvoiceStatus
    {
        return $this->status;
    }

    public function getCreatedAt(): \DateTime
    {
        return $this->createdAt;
    }

    public function setAmount(float $amount): self
    {
        $this->amount = $amount;

        return $this;
    }

    public function setInvoiceNumber(string $invoiceNumber): self
    {
        $this->invoiceNumber = $invoiceNumber;

        return $this;
    }

    public function setStatus(InvoiceStatus $status): self
    {
        $this->status = $status;

        return $this;
    }

    #[PrePersist]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        $this->createdAt = new \DateTime();
    }


    public function addItem(InvoiceItem $item): self
    {
        $item->setInvoice($this);  // this is the call that establishes the relationship between the 'Invoice' and 'InvoiceItem' entities.

        $this->items->add($item);

        return $this;
    }
}














COMO VC PODE VER,

FICAMOS COM MT MENOS CÓDIGO DO QUE O 

CÓDIGO 

DAS ENTITIES...






-> MT MENOS BOILERPLATE CODE...










--> ISSO PQ, COM ENTITIES,

TUDO É PRATICAMENTE 

'EXPLICITLY MAPPED' 

E 

'EXPLICITLY CONFIGURED'...









--> OUTRO DETALHE:



COM ENTITIES, NÓS TEMOS 1 MONTE DE PROPERTIES ESPECIFICADAS,

COM OS ATTRIBUTES EM CIMA...












--> JÁ COM Models do ELOQUENT,
    TEMOS NENHUMA DAQUELAS PROPERTIES ESPECIFICADAS...






---> ISSO É PQ, 
COM DATA MAPPER,

''WE MAP DATA PROPERTIES TO COLUMNS IN THE TABLES'...







POR OUTRO LADO, 

COM ACTIVE RECORD,


''THE TABLE COLUMNS 
    __BECOME _ THE 
    OBJECT'S PROPERTIES''...










->> HÁ UM POUCO DE MÁGICA, AQUI,

E VEREMOS ISSO EM AÇÃO LOGO LOGO...













--> COMO O PROFESSOR MENCIONOU ANTES,

AS TABLE COLUMNS SE TRANSFORMAM AS PROPERTIES DOS OBJECTS..










--> ISSO QUER DIZER QUE PODEMOS 

DEFINIR OS VALUES 

DE ESSAS PROPERTIES 



NO NOSSO CÓDIGO...











-> DIGAMOS QUE TEMOS A TABLE DE INVOICES..











--> FIELDS DE 




ID,
AMOUNT,
INVOICE_NUMBER,
status,
CREATED_AT,
DUE_DATE...







--> NÃO PRECISAMOS SETTAR AS COLUMNS DE 'ID' 
E 'CREATED_AT',

PQ 

AMBAS 

SERÃO 



SETTADAS AUTOMATICAMENTE, PARA NÓS,

PELO ELOQUENT,


MAS 

PODEMOS 
SETTAR O RESTO DAS COLUMNS...








--> BASTA ESCREVERMOS ASSIM:



<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';




$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
$invoice->due_date = new \DateTime('2023-01-01');















MAS VAMOS SETTAR 1 VALUE DIFERENTE EM 'due_date'...







-> QUEREMOS SETTAR O DUE DATE COMO SENDO 

10 DIAS NO FUTURO...









--> O LARAVEL USA UMA LIBRARY CHAMADA DE 'CARBON' 

PARA TRABALHAR 
COM DATES...







---> O CARBON É COMO UM NICE WRAPPER 
    AO REDOR DOS OBJECTS 'DATE' DO PHP,

    QUE PROVIDENCIA HELPER E FLUENT METHODS QUE 
    DEIXAM O TRABALHO COM DATES MAIS FÁCIL...






->  ALTERNATIVAMENTE,
    PODEMOS INSTANCIAR UM NOVO DATETIME OBJECT 
    E ENTAO USAR INTERVALS PARA ADICIONAR DAYS A ELE...




    OU, COM O CARBON, DE FORMA BEM MAIS FACILITADA,


    BASTA ESCREVER ASSIM:







$invoice->due_date = (new \Carbon\Carbon())->addDays(10);











PODEMOS INSTALAR O CARBON ASSIM:



composer require nesbot/carbon










FICA TIPO ASSIM:











<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

require __DIR__ . '../eloquent.php';




$invoice = new \App\Models\Invoice();


$invoice->amount = 45;
$invoice->invoice_number = '1';
$invoice->status = \App\Enums\InvoiceStatus::Pending;
// $invoice->due_date = new \DateTime('2023-01-01'); // without Carbon.
$invoice->due_date = (new \Carbon\Carbon())->addDays(10);







CERTO...