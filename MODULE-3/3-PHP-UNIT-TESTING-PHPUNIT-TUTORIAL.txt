












CERTO....








-> NA ÚLTIMA AULA,
 FALAMOS SOBRE DIFERENTES METHODS E TECHNIQUES DE TESTING...










--> NESSA AULA, VAMOS 
    ACTUALLY ESCREVER ALGUNS UNIT TESTS,

    E APRENDER OS BASICS DO PHPUNIT,

    QUE É UM 
    TESTING FRAMEWORK PARA PHP..











--> SEGUIMOS OS DOCS DO PHPUNIT,



QUE 


AFIRMAM QUE 

PODEMOS INSTALAR 

O 'PHPUNIT'

POR MEIO DO COMPOSER,


COM ESTE CÓDIGO:






'composer require --dev phpunit/phpunit ^9.5'






'--dev' --> o php unit é instalado como uma DEV DEPENDENCY...







VAMOS RODAR ESSE COMANDO DENTRO 


DO DOCKER...








-> RODAMOS ISSO NO TERMINAL...











--> AÍ PODEMOS RODAR TESTS 
    USANDO O PHPUNIT SCRIPT,

    LOCALIZADO DENTRO DE 

    'vendor>bin'...





-> DENTRO DESSE FOLDER,

temos 
'phpunit',


que é o arquivo usado para rodar os tests...








--> PARA RODAR O 'phpunit',



BASTA RODAR ASSIM


'./vendor/bin/phpunit'









--> COM ISSO, FICAMOS COM 1 MONTE DE OPTIONS,
    QUE PODEMOS USAR, JUNTO COM O COMANDO...






    --> PODEMOS RODAR TESTS PARA 1 FILE ESPECÍFICA,
        OU PARA 1 FOLDER INTEIRO...








EX:











PS D:\PROJETO20-PHP-FROM-THE-GROUND-UP\MODULE-3\phpunit-first-example>  ./vendor/bin/phpunit
PHPUnit 9.5.0 by Sebastian Bergmann and contributors.

Usage:
  phpunit [options] UnitTest.php
  phpunit [options] <directory>

Code Coverage Options:
  --coverage-clover <file>    Generate code coverage report in Clover XML format
  --coverage-cobertura <file> Generate code coverage report in Cobertura XML format
  --coverage-crap4j <file>    Generate code coverage report in Crap4J XML format
  --coverage-html <dir>       Generate code coverage report in HTML format
  --coverage-php <file>       Export PHP_CodeCoverage object to file
  --coverage-text <file>      Generate code coverage report in text format [default: standard output]       
  --coverage-xml <dir>        Generate code coverage report in PHPUnit XML format
  --coverage-cache <dir>      Cache static analysis results
  --warm-coverage-cache       Warm static analysis cache
  --coverage-filter <dir>     Include <dir> in code coverage analysis
  --path-coverage             Perform path coverage analysis
  --disable-coverage-ignore   Disable annotations for ignoring code coverage
  --no-coverage               Ignore code coverage configuration

Logging Options:
  --log-junit <file>          Log test execution in JUnit XML format to file
  --log-teamcity <file>       Log test execution in TeamCity format to file
  --testdox-html <file>       Write agile documentation in HTML format to file
  --testdox-text <file>       Write agile documentation in Text format to file
  --testdox-xml <file>        Write agile documentation in XML format to file
  --reverse-list              Print defects in reverse order
  --no-logging                Ignore logging configuration

Test Selection Options:
  --list-suites               List available test suites
  --testsuite <name>          Filter which testsuite to run
  --list-groups               List available test groups
  --group <name>              Only runs tests from the specified group(s)
  --exclude-group <name>      Exclude tests from the specified group(s)
  --covers <name>             Only runs tests annotated with "@covers <name>"
  --uses <name>               Only runs tests annotated with "@uses <name>"
  --list-tests                List available tests
  --list-tests-xml <file>     List available tests in XML format
  --filter <pattern>          Filter which tests to run
  --test-suffix <suffixes>    Only search for test in files with specified suffix(es). Default:
                              Test.php,.phpt

Test Execution Options:
  --dont-report-useless-tests Do not report tests that do not test anything
  --strict-coverage           Be strict about @covers annotation usage
  --strict-global-state       Be strict about changes to global state
  --disallow-test-output      Be strict about output during tests
  --disallow-resource-usage   Be strict about resource usage during small tests
  --enforce-time-limit        Enforce time limit based on test size
  --default-time-limit <sec>  Timeout in seconds for tests without @small, @medium or @large
  --disallow-todo-tests       Disallow @todo-annotated tests

  --process-isolation         Run each test in a separate PHP process
  --globals-backup            Backup and restore $GLOBALS for each test
  --static-backup             Backup and restore static attributes for each test

  --colors <flag>             Use colors in output ("never", "auto" or "always")
  --columns <n>               Number of columns to use for progress output
  --columns max               Use maximum number of columns for progress output
  --stderr                    Write to STDERR instead of STDOUT
  --stop-on-defect            Stop execution upon first not-passed test
  --stop-on-error             Stop execution upon first error
  --stop-on-failure           Stop execution upon first error or failure
  --stop-on-warning           Stop execution upon first warning
  --stop-on-risky             Stop execution upon first risky test
  --stop-on-skipped           Stop execution upon first skipped test
  --stop-on-incomplete        Stop execution upon first incomplete test
  --fail-on-incomplete        Treat incomplete tests as failures
  --fail-on-risky             Treat risky tests as failures
  --fail-on-skipped           Treat skipped tests as failures
  --fail-on-warning           Treat tests with warnings as failures
  -v|--verbose                Output more verbose information
  --debug                     Display debugging information

  --repeat <times>            Runs the test(s) repeatedly
  --teamcity                  Report test execution progress in TeamCity format
  --testdox                   Report test execution progress in TestDox format
  --testdox-group             Only include tests from the specified group(s)
  --testdox-exclude-group     Exclude tests from the specified group(s)
  --no-interaction            Disable TestDox progress animation
  --printer <printer>         TestListener implementation to use

  --order-by <order>          Run tests in order: default|defects|duration|no-depends|random|reverse|size   
  --random-order-seed <N>     Use a specific random seed <N> for random order
  --cache-result              Write test results to cache file
  --do-not-cache-result       Do not write test results to cache file

Configuration Options:
  --prepend <file>            A PHP script that is included as early as possible
  --bootstrap <file>          A PHP script that is included before the tests run
  -c|--configuration <file>   Read configuration from XML file
  --no-configuration          Ignore default configuration file (phpunit.xml)
  --extensions <extensions>   A comma separated list of PHPUnit extensions to load
  --no-extensions             Do not load PHPUnit extensions
  --include-path <path(s)>    Prepend PHP's include_path with given path(s)
  -d <key[=value]>            Sets a php.ini value
  --cache-result-file <file>  Specify result cache path and filename
  --generate-configuration    Generate configuration file with suggested settings
  --migrate-configuration     Migrate configuration file to current format

Miscellaneous Options:
  -h|--help                   Prints this usage information
  --version                   Prints the version and exits
  --atleast-version <min>     Checks that version is greater than min and exits
  --check-version             Check whether PHPUnit is the latest version

PS D:\PROJETO20-PHP-FROM-THE-GROUND-UP\MODULE-3\phpunit-first-example> 

























-> CERTO...




PODEMOS ESPECIFICAR 1 TEST FILE ESPECÍFICA,

COMO 


'MyTest.php',




ou 

então 

1 folder inteiro,


com 



algo como 


'' ./vendor/bin/phpunit myTests '''















ou, então,


PODEMOS USAR A OPTION DE 'filter',



PARA _ RODAR 1 TEST ESPECÍFICO...













COMO VC PODE VER,

HÁ MTAS OPTIONS AO SEU DISPOR...








-> VC  VAI SE FAMILIARIZAR 
COM AS OPTIONS A MEDIDA QUE TRABALHA 


COM O PHPUNIT...










--> SE VC NAÕ QUER TER DE ESCREVER 
'./vendor/bin/phpunit'


TODA SANTA VEZ,

VC 


PODE ESPECIFICAR 1 ALIAS 

para esse comando (no linux).....















--> VAMOS FAZER TUDO ISSO EM 1 NOVO DIRECTORY, EM NOSSO PROJECT,


DE NOME 'tests'...







-> AÍ, DENTRO DE 'tests',



CRIAMOS UM OUTRO FOLDER, DE NOME 'Units'...






-> É NESSE FOLDER QUE 

SEGURAREMOS TODOS OS NOSSOS UNIT TESTS...







--> CERTO... MAIS TARDE PODEREMOS TER FOLDERS PARA INTEGRATION TESTS 
    E OUTROS TIPOS DE TESTS, POR EXEMPLO...










-> OK... MAS ANTES DE CRIARMOS A ACTUAL TEST FILE,
    DEVEMOS CONFIGURAR O ACTUAL PHPUNIT,

    POR MEIO DO CREATE _ DE 1 

    ARQUIVO DE CONFIG...











-> O ARQUIVO DE CONFIG DO PHPUNIT

    AJUDA 

    A SETTAR ALGUMAS OPTIONS QUE, SE NÃO O TIVÉSSEMOS,

    TERÍAMOS DE DIGITAR JUNTO COM O COMANDO BASE....










--> É POR ISSO QUE CRIAMOS O ARQUIVO 

    DE CONFIG DO PHPUNIT...







--> ESSE ARQUIVO É UM ARQUIVO XML...






O NOME DO CONFIG É 


'phpunit.xml'...






-> O ARQUIVO CONFIG BÁSICO TEM ESTE FORMATO:













<?xml version="1.0" encoding="UTF-8"?>
<phpunit colors="true" bootstrap="vendor/autoload.php">
    <testsuites>
        <testsuite name="Unit Tests">
            <directory>tests/Unit</directory>
        </testsuite>
    </testsuites>










CERTO...














VAMOS ANALISAR ESSE SNIPPET...













--> É UM XML FILE...







-> DENTRO DE '<phpunit>',


ESPECIFICAMOS AS OPTIONS_,

NO FORMATO DE 


___ATTRIBUTES__


(como aquele 'colors', 'bootstrap', etc)...








-> NO CASO, AQUI ESTAMOS DEIXANDO COLOR-CODING ATIVADO (colors=true),



    e ESTAMOS DEIXANDO O BOOTSTRAP COMO 


    SENDO O SCRIPT DE 'autoload.php',

    do composer,

    dentro 

    da pasta 'vendor'...







-> O BOOTSTRAP SCRIPT É CARREGADO 



__ ANTES__ DOS TESTS SEREM EXECUTADOS,

E 
ELE PODE SER SETTADO COMO 1 CUSTOM BOOTSTRAP SCRIPT,

CASO NECESSÁRIO...








--> AÍ, dentro de 'phpunit',


temos 


'<testsuites>',

QUE 
EXISTE PARA ORGANIZAR MELHOR SEU CÓDIGO...








-> COMO TEMOS APENAS UNIT TESTS,
POR ENQUANTO,


FICAMOS COM APENAS 1 ELEMENTO '<testsuite>' (para os unit tests)...








--> MAIS TARDE PODEMOS ADICIONAR 1 '<testsuite>' para 
  INTEGRATION TESTS E ETC...












--> SE RODAMOS O SCRIPT BASE SEM ESPECIFICAR 
  TEST ALGUM, TIPO ASSIM:





./vendor/bin/phpunit









ISSO VAI EXECUTAR TODOS OS TEST SCRIPTS DEFINIDOS 

NO ARQUIVO DE CONFIG...




--> COMO AINDA NÃO DEFINIMOS TEST ALGUM DENTRO DA 'TESTSUITE',

  FICAMOS COM TESTE WARNING,

  DE 


  'No tests executed!'




  EX:






  PS D:\PROJETO20-PHP-FROM-THE-GROUND-UP\MODULE-3\phpunit-first-example>  ./vendor/bin/phpunit 
PHPUnit 9.5.0 by Sebastian Bergmann and contributors.

No tests executed!









OK...






VAMOS ESCREVER ALGUNS TESTS PARA A CLASS DE 'Router',


que ESCREVEMOS NA PARTE ANTERIOR DO CURSO...









-> O CÓDIGO DE Router.php estava assim:









<?php 

declare(strict_types= 1);


namespace App19;

use App19\Exceptions\RouteNotFoundException;

class Router {

    private array $routes = [];

    // * Call it like '$router->register('GET /foo', function() { ... });'
    private function register(string $requestMethod,string $route, callable|array $action): self {
        $this->routes[$requestMethod][$route] = $action;

        return $this;
    }

    // * This is used to call the 'register' method for the 'get' request method routes:
    public function get(string $route, callable|array $action): self {
 
        return $this->register('get', $route, $action);
    }

    public function post(string $route, callable|array $action): self {
        return $this->register('post', $route, $action);
    }

    public function routes(): array {
        return $this->routes;
    }



    public function resolve(string $requestUri, string $requestedMethod){

    // * The first part of the request URI is the route (the second part is the query string/parametrs)
        $route = explode('?', $requestUri)[0];

        // * Find the action for the route, in the routes array.
        $action = $this->routes[$requestedMethod][$route] ?? null;

        if (!$action) {
            // Throw custom exception.
            throw new RouteNotFoundException();
        }


        if (is_callable($action)) {
            return call_user_func($action, $route);
        }

        // * If it is not callable, it must be an array:
        if(is_array($action)) {
            [$class, $method] = $action;
            if (class_exists($class)) {
            
                $class = new $class;
                
                if (method_exists($class, $method)) {
                    return call_user_func_array([$class, $method],[]);
                }
            
            }


        }

        throw new RouteNotFoundException();
    
    }
}













TEMOS ALGUNS METHODS DISPONÍVEIS,





COMO 'get' 

' 

'post',



QUE SIMPLESMENTE CHAMAM O METHOD DE 'register' 


JUNTO COM A ACTION CORRESPONDENTE ...










-> A ACTION PODE SER OU 1 ARRAY (
  controller, method
)

  ou 1 callable simples...









--> AÍ TEMOS O METHOD de 'routes()",

  QUE RETORNA TODAS AS ROUTES,


  E AÍ 

  TEMOS 

  O METHOD 

  DE 

  'resolve()',







  que faz o resolve da route, com base no request URI e request method..










--> É UM ROUTER BEM SIMPLES,
  NOTHING FANCY... MAS 


  O FATO DE SER SIMPLES NÃO QUER DIZER QUE NÃO DEVEMOS 

 CRIAR TESTS PARA ELE...











 -> VAMOS CRIAR OS TESTS EM 1 ARQUIVO DE 'RouterTest.php',



 LÁ 


 NO FOLDER DE 'tests'...


















 -> CERTO....







 AÍ, DENTRO DISSO,


VAMOS FAZER EXTEND DA CLASS DE 'TestCase'


DO 'PHPUnit'...

















EX:









<?php


declare(strict_types=1);


namespace Tests\Unit;


use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

}









A CLASS DE 'TestCase'

PROVIDENCIA A FUNCIONALIDADE PARA OS TESTS...








OS TESTS EM SI SÃO ESCRITOS COMO METHODS,

DENTRO DA CLASS DE 


'RouterTest'...










--> A PRIMEIRA COISA QUE QUEREMOS TESTAR É 


'TEST IF A ROUTE CAN BE REGISTERED'.








-> OU SEJA, O METHOD TARGETADO 

  É 




    // * Call it like '$router->register('GET /foo', function() { ... });'
    private function register(string $requestMethod,string $route, callable|array $action): self {
        $this->routes[$requestMethod][$route] = $action;

        return $this;
    }











-> para escrever 1 test para isso,



podemos criar com este formato:







public function it_registers_a_route(): void
{

}


















EX:









<?php


declare(strict_types=1);


namespace Tests\Unit;


use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    public function it_registers_a_route(): void
    {

    }
}

















--> O PROFESSOR PREFERE NOMES DESCRITIVOS, MESMO QUE SEJAM 
  LONGOS...






-> QUANDO O PROFESSOR ESCREVE TESTS, ELE TENTA SEGUIR 
OS PADRÕES:





''GIVEN 
   - 
   WHEN 
   - 
   THEN 
  ''



E 


'' ARRANGE 
      - 
    ACT 
    - 
  ASSERT 

''







--> QUANDO VC QUER TESTAR ALGUMA COISA, TBM AJUDA 
  ESCREVER O QUE VC QUER TESTAR...








--. TIPO ASSIM:







<?php


declare(strict_types=1);


namespace Tests\Unit;


use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    public function it_registers_a_route(): void
    {

      // Given that we have a router object 

      // When we call a register method and provide the arguments

      // Then we assert that the route was registered.
    }
}











AÍ ESCREVEMOS TIPO ASSIM:








<?php


declare(strict_types=1);


namespace Tests\Unit;


use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    public function it_registers_a_route(): void
    {

      // Given that we have a router object 
      $router = new Router();

      // When we call a register method and provide the arguments
      $router->register();

      // Then we assert that the route was registered.
    }
}
 












NÃO IMPORTA OS ARGUMENTS QUE ESTAMOS PASSANDO A '->register()',


pq aqui 

ESTAMOS APENAS

TESTANDO SE ROUTES CONSEGUEM SER REGISTERED....













ESCREVEMOS ASSIM:




<?php


declare(strict_types=1);


namespace Tests\Unit;


use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    public function it_registers_a_route(): void
    {

      // Given that we have a router object 
      $router = new Router();

      // When we call a register method and provide the arguments
      $router->register('get', '/users', ['Users', 'index']);

      // Then we assert that the route was registered.
    }
}
 
















-> NO FINAL, NA PARTE FINAL,
QUEREMOS 'ASSERT'...









--> PARA ISSO, USAMOS 1 DOS ASSERTION METHODS,

DA CLASS DE 'TestCase'


do PHPUNIT...








--> NO CASO,



USAMOS 


'$this->assertEquals()',


PARA 





'''COMPARE THE EXPECTED VALUE WITH THE _ ACTUAL__ VALUE_...''






--> usaremos um array de nome '$expected',


e o ACTUAL VALUE pegaremos de 

'$routes->routes()',


PQ 


ESSE '->routes()'


RETORNA A PROPRIEDADE '$routes' 

do objeto 'Router'...










-> É POR ISSO QUE O CÓDIGO VAI FICANDO ASSIM:



<?php


declare(strict_types=1);


namespace Tests\Unit;


use App\Router;
use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    public function it_registers_a_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a register method and provide the arguments
        $router->register('get', '/users', ['Users', 'index']);

        $expected = [
            
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());

    }
}











aí podemos 



HARDCODAR O VALUE ESPERADO DE ESSE ROUTER,

TIPO ASSIM:








<?php


declare(strict_types=1);


namespace Tests\Unit;


use App\Router;
use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    public function it_registers_a_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a register method and provide the arguments
        $router->register('get', '/users', ['Users', 'index']);

        $expected = [
            'get' => [
                '/users' => ['Users', 'index'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());

    }
}













CERTO...










ASSIM QUE ESCREVEMOS ESSE TEST,


TENTAMOS EXECUTÁ-LO NO TERMINAL, COM O COMANDO BASE:



./vendor/bin/phpunit












CERTO... MAS NENHUM 

TEST FOI ENCONTRADO...







--> GANHAMOS AQUELE WARNING:




1) Warning
No tests found in class "Tests\Unit\RouterTest".

WARNINGS!
Tests: 1, Assertions: 0, Warnings: 1.










-->  A RAZÃO PARA O WARNING/ERROR 

É QUE 



''PHPUNIT DOES NOT KNOW IF THIS METHOD IS A __ TEST_ METHOD _ OR 
  IF IT IS A __ REGULAR __ METHOD'''..








-> PARA HINTAR QUE NOSSO METHOD É UM 'TEST METHOD',
   PODEMOS USAR 'ANNOTATION',


   ou 

   ENTÃO 
   PREFIXAR 

   O METHOD DE TEST COM A PALAVRA 'Test'...



  





-> SE VC QUER USAR A ANOTATION,

  VC DEVE ESCREVER 

  '/** @test */''


  LOGO ANTES DO SEU TEST...






TIPO ASSIM:




<?php


declare(strict_types=1);


namespace Tests\Unit;


use App\Router;
use PHPUnit\Framework\TestCase;


class RouterTest extends TestCase
{

    /** @test */
    public function it_registers_a_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a register method and provide the arguments
        $router->register('get', '/users', ['Users', 'index']);

        $expected = [
            'get' => [
                '/users' => ['Users', 'index'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());

    }
}











CERTO... COM ISSO, O NEGÓCIO VAI DETECTAR 1 TEST E 1 ASSERTION...










CERTO... MAS AO RODAR ISSO, NOVAMENTE,


FIQUEI COM ESTE ERROR:












Call to private method App\Router::register() from scope Tests\Unit\RouterTest  










QUER DIZER QUE ESSE METHOD DEVE FICAR COMO 'public',

PARA QUE EU CONSIGA EXECUTÁ-LO DENTRO 

DA CLASS DE 'RouterTest'...





TIPO ASSIM:











    // * Call it like '$router->register('GET /foo', function() { ... });'
    public function register(string $requestMethod, string $route, callable|array $action): self
    {
        $this->routes[$requestMethod][$route] = $action;

        return $this;
    }












  OK... AGORA DEU CERTO...











  PS D:\PROJETO20-PHP-FROM-THE-GROUND-UP\MODULE-3\phpunit-first-example>  ./vendor/bin/phpunit 
PHPUnit 9.5.0 by Sebastian Bergmann and contributors.

.                                                                   1 / 1 (100%)

Time: 00:00.004, Memory: 6.00 MB

OK (1 test, 1 assertion)


















A OUTRA MANEIRA DE MARCAR QUE 

1 METHOD 


É DE TIPO 'TEST'


É ESCREVÊ-LO TIPO ASSIM:



''test_that_it_registers_a_route(): void 
{

}
''






AMBOS SÃO FINE...








PARA TEST METHODS, O PROFESSOR USA SNAKE_CASE...











MAS AGORA VAMOS ADICIONAR ALGUNS OUTROS TESTS...








--> vamos adicionar 


um test 

para 

'
CONFIRM THAT GET AND POST ROUTES ARE REGISTERED PROPERLY 
WHEN WE CALL THE GET AND POST METHODS...''








--> PODERÍAMOS ADICIONAR 1 
    UNIT TEST PARA TESTAR AMBOS,

    OU CRIAR 1 PARA CADA...







    -> O PROFESSOR PREFERE TER TESTS SEPARADOS..


    TIPO ASSIM:


  





  
class RouterTest extends TestCase
{

    /** @test */
    public function it_registers_a_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a register method and provide the arguments
        $router->register('get', '/users', ['Users', 'index']);

        $expected = [
            'get' => [
                '/users' => ['Users', 'index'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());
    }

    /** @test */
    public function it_registers_a_get_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a get method and provide the arguments
        $router->get('/posts', ['Posts', 'index']);

        $expected = [
            'get' => [
                '/posts' => ['Posts', 'index'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());
    }

    /** @test */
    public function it_registers_a_post_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a get method and provide the arguments
        $router->post('/posts', ['Posts', 'create']);

        $expected = [
            'post' => [
                '/posts' => ['Posts', 'create'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());
    }
}















CERTO... E ISSO FUNCIONOU...










se tentássemos passar outros params, os tests 

falhariam,

o que é bom...











-> AGORA VAMOS ADICIONAR OUTRO  
  UNIT TEST 

  PARA O METHOD DE '->routes()',


  PARA QUE NÓS 


  ''TEST THAT NO ROUTES ARE REGISTERED INITIALLY, WHEN WE CALL THAT METHOD''...





TIPO ASSIM:









class RouterTest extends TestCase
{

    /** @test */
    public function it_registers_a_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a register method and provide the arguments
        $router->register('get', '/users', ['Users', 'index']);

        $expected = [
            'get' => [
                '/users' => ['Users', 'index'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());
    }

    /** @test */
    public function it_registers_a_get_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a get method and provide the arguments
        $router->get('/posts', ['Posts', 'index']);

        $expected = [
            'get' => [
                '/posts' => ['Posts', 'index'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());
    }

    /** @test */
    public function it_registers_a_post_route(): void
    {
        // Given that we have a router object 
        $router = new Router();

        // When we call a get method and provide the arguments
        $router->post('/posts', ['Posts', 'create']);

        $expected = [
            'post' => [
                '/posts' => ['Posts', 'create'],
            ]
        ];

        // Then we assert that the route was registered.
        $this->assertEquals($expected, $router->routes());
    }

    /** @test */
    public function it_returns_no_routes_when_router_is_created(): void
    {
        // Given that we have a router class and when we create an instance of it
        $router = new Router();

        $expected = [];

        // Then we assert that the routes are empty.
        $this->assertEquals($expected, $router->routes());
    }
}













CERTO... 




ISTO AQUI:






   /** @test */
    public function it_returns_no_routes_when_router_is_created(): void
    {
        // Given that we have a router class and when we create an instance of it
        $router = new Router();

        $expected = [];

        // Then we assert that the routes are empty.
        $this->assertEquals($expected, $router->routes());
    }











  E ISSO REALMENTE FUNCIONA, PQ 

  O ARRAY DE ROUTES FICA VAZIO, NO INÍCIO...



















-> O PROFESSOR MOSTRA COMO EXECUTAR 


O TEST COM APENAS 1 TEST ESPECÍFICO...




BASTA RODARMOS O COMANDO BASE 


COM A FLAG DE --filter 


E 

AÍ O NOME DO TEST METHOD,

tipo assim:




./vendor/bin/phpunit  --filter it_returns_no_routes_when_router_is_created














mas o test do professor deu errado...







--> NO TEST DO PROFESSOR, ELE HAVIA ESCRITO ASSIM:




'$this->assertEmpty($router->routes())'








O MEU FOI DIFERENTE, FOI:



''        $this->assertEquals($expected, $router->routes());         ''
 









A MESSAGE DE ERROR 


DO PROFESSOR FOI 



'$routes must not be accessed befor initialization''...










isso aconteceu pq 

a versão do professor de routes começa assim:




    private array $routes;







    e não assim:





        private array $routes = [];





(QUE É A MINHA VERSÃO, CORRETA)....










-> QUER DIZER QUE 
  1 SIMPLES UNIT TEST COMO ESSE 

  NOS AJUDA A ENCONTRAR BUGS 

  NO NOSSO CÓDIGO...






  FEITA A MUDANÇA NA CLASS DE 'Router',

  PROSSEGUIMOS...