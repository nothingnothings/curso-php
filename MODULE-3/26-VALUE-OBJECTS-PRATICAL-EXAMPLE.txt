






NA ÚLTIMA AULA, FALAMOS SOBRE DATA MODELLING,


MAIS ESPECIFICAMENTE 


DATA TRANSFER OBJECTS ('DTOs')...











-> HOJE FALAREMOS SOBRE VALUE OBJECTS (VOs)...








--> ANTES DE FALARMOS SOBRE A TEORIA E FORMAL DEFINITIONS,

    O PROFESSOR QUER MOSTRAR 1 EXEMPLO...









-> SERÁ MT MAIS FÁCIL ENTENDER:



1) WHEN 

2) WHY


3) WHERE 


4) HOW 






DOS VALUE OBJECTS...












-> O EXEMPLO DE HOJE É SOBRE O __ CALCULATE__ DE 

SHIPPING COSTS....















SHIPPING COSTS:





---> TIPICAMENTE,
    PARA CALCULAR 
    O CUSTO DE ENVIO DE 1 PACKAGE,

    ISSO DEPENDE DE ALGUNS FACTORS E VARIABLES...


    ALGUMAS DELAS SÃO:





    1) DIMENSIONS OF THE PACKAGE (width x height x length)


    2) Weight 


    3) distance 


    4) carrier 


    5) speed

    6) value 











--> VAMOS ASSUMIR ALGUNS DOS FATORES 

NESSA LESSON...









-> VAMOS FAZER 1 CÁLCULO BEM SIMPLES,

    PARA NÃO 'GO OUT OF THE SCOPE'..













-->  VAMOS FOCAR APENAS EM ALGUNS FACTORS...





SÃO ELES:



1) PACKAGE DIMENSION 




2) WEIGHT ...











--> USAREMOS ISSO PARA CALCULAR AQUILO QUE CHAMAMOS 

DE 

'BILLABLE WEIGHT'...









BILLABLE WEIGHT...









--> É ALGO USADO POR CARRIERS, PARA 
    CALCULAR O SHIPPING COST DE CADA PACKAGE...











--> O BILLABLE WEIGHT 
É BASEADO EM ALGO CHAMADO DE 


'DIMENSIONAL WEIGHT',

QUE POR SUA VEZ TAMBÉM É CONHECIDO COMO 'DIM Weight'...











--> É BASEADO NO 'DIM WEIGHT' E O 'ACTUAL WEIGHT' 
DA PACKAGE...












--> BILLABLE WEIGHT -->     SEMPRE SERÁ 
                        EQUIVALENTE 


                        AO WEIGHT 

                        MAIOR 

                        ENTRE 

                        O 

                        'DIM Weight' 


                        e 

                        o 

                        'Actual Weight'...






--> POR ISSO, A FÓRMULA É 



max(DIM Weight, Weight);








-> SE O DIM Weight é maior 
    do que o weight da package,

    ele será o billable weight... e vice-versa...














    --> PARA CALCULAR ISSO,





O PROFESSOR CRIOU 1 SERVICE DE 


'BillableWeightCalculatorService',






COM ESTE CÓDIGO:



<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        return 241;
    }
}




ESSE SERVICE CONTÉM 1 ÚNICO METHOD,

'CALCULATE'...






--> É ESSA A CLASS QUE VAI CALCULATAR 
O BILLABLEWEIGHT PARA NÓS...











--> ELE ACEITA AQUELES 5 PARAMS...









-> COM ISSO, ELE DEVE RETORNAR O BILLABLEWEIGHT..








-> COLOCAMOS O TYPE COMO INT, MAS PODERIA 
    SER FLOATS OU STRINGS...








MAS PARA DEIXAR AS COISAS SIMPLES,

COLOCAMOS O RETURN 

DE INT...












--> O PROFESSOR CONSIDERA QUE AS UNITS DAS 
DIMENSIONS SERÃO EM INCHES...



--> JÁ OS WEIGHT SERÃO EM POUNDS...










-> O PROFESSOR HAVIA MENCIONADO QUE A BILLABLEWEIGHT SERÁ 




max(billableWeight, weight)....





o professor vai escrevendo assim:





<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = 0;


        return max($weight, $dimWeight);
    }
}





















A 'DIMWEIGHT',

DIMENSIONAL WEIGHT,



LEVA EM CONSIDERAÇÃO:




WIDTH,
LENGTH,
HEIGHT 


DA PACKAGE...










--> É POR ISSO QUE ESCREVEMOS TIPO ASSIM:



<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = $width * height * length;


        return max($weight, $dimWeight);
    }
}

















-> NO CASO, ESSE VALUE SERÁ DIVIDIDO POR UM 'dimDivisor'...











-> DIMENSION DIVISOR É UM 
    NUMBER QUE SEMPRE É DETERMINADO 

    POR CADA  CARRIER...



 

    FEDEX PODE TER 

    1 DIM DIVISOR DIFERENTE DE USPS, POR EXEMPLO...








-> 

<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = $width * height * length / $dimDivisor;


        return max($weight, $dimWeight);
    }
}


















--> vamos fazer ROUND DO VALUE INTEIRO,

'TO THE NEAREST INTEGER',



e aí 

VAMOS CASTAR TUDO 



COMO SENDO 


INT... pq o return type é de int,



TIPO ASSIM:



<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        
        $dimWeight = (int) round($width * height * length / $dimDivisor);


        return max($weight, $dimWeight);
    }
}













CERTO... TESTAMOS ISSO, PARA VER SE FUNCIONA...








eX:










<?php declare(strict_types=1);

namespace App\Services\BillableWeightCalculator;

class BillableWeightCalculator
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}















o professor também criou um arquivo 

de 



'shipping_calculator_example.php',


QUE USAREMOS PARA 


TESTAR ESSE SERVICE, E PARA DEMONSTRAR O FUNCIONAMENTO 


DOS 'VO' (value objects)....









TIPO ASSIM:







<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\Shipping\BillableWeightCalculatorService;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 139;

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length'],
    $package['weight'],
    $fedexDimDivisor
);















OK...





MAS ISSO É BEM RUIM...







PQ QUANDO INSTANCIAMOS AQUELE SERVICE,

TEMOS DE PASSAR 1 MONTE DE PARAMETERS, 1 ATRÁS DO OUTRO...












-> O CÓDIGO FUNCIONA,

MAS 

É FEIO...













''BUT WHAT IS THE ISSUE, HERE?''













--> PQ DIABOS NÃO PODEMOS USAR ESSA SERVICE CLASS DESSA FORMA AÍ?










--> EM ALGUNS CASES, ESSE CÓDIGO É PERFECTLY FINE,
E FUNCIONARIA...










--> ENTRETANTO, EM OUTROS CASES,
    ESSE CODE _ FALHARIA___...













--> POR EXEMPLO,



''WHAT IF WE 
    _ PASSED __ 
    NEGATIVE VALUES'',


''OR WHAT IF WE PASSED 0 FOR THE DIM DIVISOR???''

 












 -> PARA TESTAR ISSO, DIGAMOS QUE A WIDTH FOI SETTADA COMO '-9',


 tipo assim:












 <?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\Shipping\BillableWeightCalculatorService;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => -9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 139;

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length'],
    $package['weight'],
    $fedexDimDivisor
);















AO FAZER ISSO, 


ficamos com 


'6lb', em vez de '7lb',


no print desse method...









isso aconteceu pq, quando o width, length e height são multiplicados,

o value final fica 





um NÚMERO NEGATIVO..








--> COMO RESULTADO DISSO,




o 'dimWeight' FICA UM NÚMERO NEGATIVO...











E O 'max()' entre um -6 E UM +6 




É UM +6,
OBVIAMENTE....














CERTO....














-> MAS DIGAMOS QUE TEMOS 1 'dimDivisor'

DE 0...









tipo assim:




<?php declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\Shipping\BillableWeightCalculatorService;

$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];

$fedexDimDivisor = 0;

$billableWeight = (new BillableWeightCalculatorService())->calculate(
    $package['dimensions']['width'],
    $package['dimensions']['height'],
    $package['dimensions']['length'],
    $package['weight'],
    $fedexDimDivisor
);















AO FAZERMOS ISSO,


FICAMOS COM 1 ERROR DE 



'Uncaught DivisionByZeroError: division by zero in BillableWeightCalculatorService'...













OU SEJA,


VÁRIAS COISAS PODEM DAR ERRADO, AQUI,


E NÃO TEMOS NENHUM TIPO DE VALIDATION 

CONTRA ESSES ERROR-CASES...














--> 'WHAT IF WE ALSO WANTED TO HAVE 
    SOME KIND OF 'MAXIMUM ALLOWED PACKAGE DIMENSIONS'? ''










--> OU SEJA,

NÃO QUEREMOS ACEITAR 

NUMBERS COMO '9999999'....













-> UMA MANEIRA DE CONSERTAR ISSO, NO CASO,

É TER 1 VALIDATION...








''THIS VALIDATION 
    CAN EXIST 


    EITHER INSIDE THE SERVICE CLASS,

    OR INSIDE IT, INSIDE THE VERIFY METHOD''...













-> OK... O PROFESSOR REVERTE TUDO PARA OS VALUES ADEQUADOS,
    E AÍ 


    DECIDE ADICIONAR VALIDATION NESSE METHOD DE 'calculate()'... 












EX:




    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
















NO CASO, O PROFESSOR DECIDE USAR UMA MATCH EXPRESSION,

TUDO PARA 

EVITAR TER UM MONTE DE IF-ELSE BLOCKS...










--> PODEMOS ESCREVER ALGO ASSIM:










<?php declare(strict_types=1);

namespace App\Services\Shipping;

class BillableWeightCalculatorService
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}













CERTO...






FAZ SENTIDO, É UMA VALIDATION BÁSICA...





vamos fazer throw da exception, caso qualquer 1 desses values seja 
invalid...













--. AÍ TESTAMOS ISSO..











SIMPLESMENTE PASSAMOS 1 VALUE NEGATIVE 

PARA O width,

TIPO ASSIM:




$package = [
    'weight' => 6,
    'dimensions' => [
        'width' => 9,
        'height' => 15,
        'length' => 7
    ],
];











COM ISSO, FICAMOS COM A EXCEPTION 

DE 


'Invalid package width',


O QUE QUER DIZER QUE NOSSA VALIDATION FOI UM SUCESSO...











--> O MESMO ACONTECE COM LENGTH E HEIGHT..


TODOS ELES FAZEM THROW DA EXCEPTION CORRESPONDENTE...









-> SE DEIXAMOS O DIM DIVISOR COMO '0',

FICAMOS COM 'Invalid dim divisor'..









QUER DIZER QUE 




ESSA VALIDATION ESTÁ FUNCIONANDO..








-> MAS E QUANTO ÀS 'UNITS'?









--> BEM, O PROFESSOR HAVIA COMENTADO QUE 

    DEVERÍAMOS 
    CONSIDERAR AS UNITS DE DIMENSIONS COMO SENDO EM 'INCHES',


    E AS UNITS DE PESO SEREM EM 'POUNDS'...













--> OK... MAS DIGAMOS QUE QUEREMOS QUE AS MEDIDAS 
    SEJAM EM 'METRIC UNITS',

    EM VEZ DE IMPERIAL UNITS...







--> OU SEJA,

    QUEREMOS KILOGRAMS, METERS, ETC....









-> UMA MANEIRA DE SUPORTAR ISSO 
    SERIA FAZER 

    O 'ACCEPT' DE 
    UNITS 


    COMO _ OUTRO ARGUMENT,

    DENTRO DA FUNCTION DE 'calculate'...









--> A OUTRA ALTERNATIVA SERIA 


DEFINIR 1 PARAMETER DE '$array',







UM ARRAY QUE CONTERIA:


1) AS DIMENSIONS 

2) THE WEIGHT 

3) THE UNIT,


ETC...







-> ISSO SERIA OK, EM SITUAÇÕES MAIS SIMPLES,


    MAS LOGO FICARIA UMA PORCARIA COM 
     
    SITUAÇÕES MAIS COMPLEXAS...










-> QUANDO AS COISAS FICAREM MAIS COMPLEXAS,
    OS REQUIREMENTS VÃO MUDAR,
    TUDO VAI MUDAR...










--> 
O PROFESSOR APONTA QUE 

OS ARGUMENTS 


DE 


'width', 'height', 'length', 'weight' e 'dimDIVISORF'



NÃO SÃO MAIS APENAS 'SCALAR VALUES'..











-> AGORA, NO CASO, HÁ MAIS COISAS ACONTECENDO 
COM ELES ...








 

-> NO CASO, HÁ VALIDATION ENVOLVIDA..







-> PODERIA TER MAIS DE 1 TIPO DE UNIT ENVOLVIDA...





-> PODERIA TER 1 FORMATTING ENVOLVIDO, TAMBÉM...










-> QUER DIZER QUE ESSA INFO NÃO SERÁ APENAS 
    SIMPLES SCALAR VALUES








--> QUER DIZER QUE MAIS INFO É NECESSÁRIA, PARA ESSES ARGUMENTS..











-> SÃO NESSES CASOS QUE 'VALUE OBJECTS'

PODEM SER ÚTEIS:












1) ''WHEN THERE IS NEED FOR ADDITIONAL INFORMATION FOR THE PARAMETERS, 
    AND A SIMPLE SCALAR TYPE IS NO LONGER ENOUGHT''.....





 
2) ''WHEN YOU NEED TO _GROUP_ MULTIPLE ARGUMENTS 
    IN A SINGLE TYPE...''










-> AÍ, NESSES CASOS, 

É QUE 


'VALUE OBJECTS' 

PODEM SER ÚTEIS...







MAS O QUE SÃO ELES?










DEFINIÇÃO:







''A value object is a SMALL OBJECT THAT 

REPRESENTS __ A SIMPLE ENTITY,
 WHOSE EQUALITY IS __ NOT BASED ON IDENTITY (e.g two values 
 are EQUAL when they have the SAME VALUES, not necessarily being 
 the same object, LOOSE OPERATOR...)

''






''Examples of value objects are objects 
    representing an amount of MONEY or a DATE RANGE''...












AS KEYWORDS AQUI SÃO:




1) EQUALITY 



2) ENTITY 


3) IDENTITY...











-> COBRIMOS ENTITIES MAIS CEDO NESSE CURSO,...











-> APESAR DE VALUE OBJECTS SOAREM SEMELHANTES 

A ENTITIES,

HÁ UMA DIFERENÇA ESSENCIAL...












ENTITIES --> SÃO TIPICAMENTE 
            IDENTIFICADOS
            por algo como um 'ID'...












VALUE OBJECT -> 'THEY DON'T HAVE ANY 
                SPECIFIC IDENTIFIER'...










--> ok... quer dizer que são completamente diferentes..






-> ENTITIES SÃO IDENTIFICADOS POR IDs...







-> JÁ AS PROPERTIES 
     DO VALUE OBJECT 

     SÃO SUA 'ACTUAL IDENTIITY',



     JUSTAMENTE POR 'value object'

    NÃO TEREM 1 IDENTIFIER ESPECÍFICO...










--> ENTITIES TAMBÉM GERALMENTE POSSUEM 
    LIFECYCLES....


    EX: SE TEMOS UMA 'PACKAGE' COMO 
        ENTITY, SUAS PROPRIEDADES PODERIAM 
        MUDAR AO LONGO DO TEMPO,


        TIPO ASSIM:


        #[Entity]
        class Package 
        {
            
            #[Id]
            private int $id;

            #[Column]
            private int $width;

            #[Column]
            private int $height;

            #[Column]
            private int $length;

            #[Column]
            private int $weight;
        }
        







--> PODERÍAMOS TER ESSAS PROPERTIES INICIALMENTE,
    MAS MAIS PROPERTIES PODERIAM SER ADICIONADAS,
    DE ACORDO COM AS CARACTERÍSTICAS DA PACKAGE:





        #[Entity]
        class Package 
        {
            
            #[Id]
            private int $id;

            #[Column]
            private int $width;

            #[Column]
            private int $height;

            #[Column]
            private int $length;

            #[Column]
            private int $weight;

            // ... more properties;

            // ... more methods
        }
        
















MAS A PACKAGE IDENTITY 
SEMPRE CONTINUARIA A MESMA, POR CONTA DAQUELE ID...












--> PODERÍAMOS COMPARAR 2 
    PACKAGES POR EQUALITY (strict comparison),


    POR MEIO DE 

    ALGO COMO 


    $package1->id === $package2->id ,




    QUE ISSO SEMPRE RETORNARÁ 
    FALSE, se não forem o mesmo object...











--> QUER DIZER QUE PODEMOS TER 2 PACKAGES COM OS MESMOS 
    VALUES, MAS QUE AINDA SERÃO PACKAGES DIFERENTES...







ex:



$package1 = new Package();

$package1->width = 4;
$package1->length = 8;
$package1->height = 3;
$package1->weight = 5;





$package2 = new Package();

$package2->width = 4;
$package2->length = 8;
$package2->height = 3;
$package2->weight = 5;





persist($package1);
persist($package2);




// Two different packages:
$package->id !== $package2->id;











certo... nesse caso,



os 2 objects 'package' SÃO 

DIFERENTES, SIM...







MAS VC PODERIA CONSIDERAR, POR OUTRO LADO,


QUE A COMBINAÇÃO 



DE 'width - length - height',

nesse exemplo aí,



CONSTITUI UM 'VALUE OBJECT',


JUSTAMENTE PQ 


NÃO IMPORTA SUA IDENTITY, O QUE IMPORTA 
SÃO OS VALUES (que serão os mesmos 
entre suas 2 utilizações, nesse exemplo)











--> ''THIS TYPE OF OBJECTS,
    WHERE THE EQUALITY IS BASED 
    ON ITS _ PROPERTIES' VALUES,

    IS CALLED ''VALUE OBJECTS''....''








EXEMPLO DE VALUE OBJECT:





class Dim
{
    public readonly int $width;
    public readonly int $height;
    public readonly int $length;
}







--> VALUE OBJECTS GERALMENTE REPRESENTAM ALGO:


1) QUANTIFIABLE 


2) MEASURABLE 


3) OR THEY DESCRIBE SOMETHING...






POR EXEMPLO:


-- ADDRESS 

-- EMAIL

-- AMOUNT 

-- DIMENSIONS 

-- AGE 



TODOS ELES PODERIAM SER MODELADOS 


COMO 'VALUE OBJECTS'...








AGORA DEVEMOS VOLTAR AO NOSSO EXEMPLO,

E VER COMO PODEMOS MODELAR 


NOSSOS ARGUMENTS COMO VALUE OBJECTS...










ATUALMENTE, TEMOS ESTE CÓDigo:







<?php declare(strict_types=1);

namespace App\Services\Shipping;

class BillableWeightCalculatorService
{
    public function calculate(
        int $width,
        int $height,
        int $length,
        int $weight,
        int $dimDivisor
    ): int {
        // Basic validation, to avoid invalid values:
        match (true) {
            $width < 0 || $width > 80 => throw new \InvalidArgumentException('Invalid package width '),
            $height < 0 || $height > 70 => throw new \InvalidArgumentException('Invalid package height '),
            $length < 0 || $length > 120 => throw new \InvalidArgumentException('Invalid package length '),
            $weight < 0 || $weight > 150 => throw new \InvalidArgumentException('Invalid package weight '),
            $dimDivisor <= 0 => throw new \InvalidArgumentException('Invalid dim divisor '),
            default => true
        };

        $dimWeight = (int) round($width * $height * $length / $dimDivisor);

        return max($weight, $dimWeight);
    }
}










HÁ UM PUNHADO DE OPTIONS, AQUI...










PODERÍAMOS OU:


1) CREATE VALUE OBJECTS 
FOR EACH INDIVIDUAL ARGUMENT,


tipo algo assim:







public function calculate(
    Width $width,
    Height $height,
    Length $length,
    int $weight,
    int $dimDivisor
) {

}









OU, ALTERNATIVAMENTE,
PODERÍAMOS AGRUPAR ESSES 3 ARGUMENTS 



EM 1 VALUE OBJECT SÓ,

CHAMADO DE 'Dimensions'...










--> NESSE EXEMPLO,
    EM VEZ DE REPRESENTÁ-LOS COMO SEPARATE
    VALUE OBJECTS,


    VAMOS COMBINÁ-LOS EM 1 ÚNICO VALUE OBJECT,

    DE NOME 'Dimensions'...







TIPO ASSIM:







public function calculate(
    Width $width,
    Height $height,
    Length $length,
    int $weight,
    int $dimDivisor
) {
    
}










-> CRIAMOS ESSE VALUE OBJECT DENTRO DO SERVICE 



DE BillableWeightCalculatorService....







TIPO ASSIM:





<?php

declare(strict_types=1);

namespace App\Services\Shipping;

class PackageDimensions
{
    public function __construct(
        private readonly int $width,
        private readonly int $height,
        private readonly int $length,
    ) {}
}











CERTO... MAS OS VALUE OBJECTS POSSUEM ALGUMAS 
CARACTERÍSTICAS...










ALGUMAS DELAS SÃO:



1) THEY MUST BE _ IMMUTABLE_...




--> É POR ISSO QUE DEIXAMOS ESSAS PROPERTIES 
COMO READONLY...








-> A RAZÃO PARA ELES TEREM DE SER 
    IMMUTABLE É JUSTAMENTE 

    PARA QUE 

    VOCê POSSA 

    ''SHARE VALUE OBJECTS SAFELY''...









TIPO ASSIM:




$dimensions = new PackageDimensions(6, 4, 10);

method_1($dimensions);

method_2($dimensions);


// ... more places that use the same dimensions object.











--> OS VALUE OBJECTS 
    SOLUCIONAM UM PROBLEMA 

    CHAMADO DE 

    'ALIASING BOX',




problema em que 


''WHERE THE SAME PACKAGE DIMENSIONS OBJECT 
    IS PASSED AROUND IN MULTIPLE PLACES,
    AND IN ONE OF THESE PLACES THE PACKAGE 
    DIMENSIONS OBJECT GETS UPDATED (tipo o value 
    de width é alterado, por exemplo),
    THIS WOULD ALSO AFFECT THE OTHER PLACES WHERE 
    THE DIMENSIONS PACKAGE OBJECT WAS USED''...









EX:



$dimensions (original variable) ---------

$dimensions (in method_1 function) -------

$dimensions (in method_2 function)