











// Error Handling 











--> EXISTEM DIFERENTES TIPOS DE ERRORS QUE PODEM SER GERADOS PELO PHP...






OS TIPOS SÃO:







1) FATAL ERRORS 




2) SYNTAX ERRORS



3) NOTICES 



4) PARSE ERRORS 











ALGUNS DESSES TIPOS DE ERRORS VAO __ PARAR_ _ A SCRIPT EXECUTION,

COMO 'FATAL ERRORS'...





MAS ALGUNS ERRORS NÃO VÃO PARAR A SCRIPT EXECUTION,

COMO 'WARNINGS'... 


 













 --> E O PHP DETERMINA QUAIS ERRORS DEVEM SER REPORTADOS 
    _ A PARTIR__ DO QUE VC DEFINIU LÁ NO 'error_report' config,

    no php.ini... conforme mencionamos na última aula...











--> VOCÊ TAMBÉM PODE OVERWRITTAR A SUA DEFINITION DE 
    ERROR REPORTING EXPLICITAMENTE,



    POR MEIO DA FUNCTION DE 



    'error_reporting()',


    que pode ser chamada durante o runtime de seu código...









EX:





// Error Handling 
error_reporting();











ISSO TE DEIXA ALTERAR O LEVEL DE REPORTING DE SEUS ERRORS...











ALGUNS DOS VALUES POSSÍVEIS SÃO:








error_reporting(0);







com ''0'',



__ VC __ DESATIVA __ O ERROR REPORTING EM SI,


O QUE QUER DIZER QUE NENHUM ERROR VAI SER REPORTADO...














--> OUTRO VALUE POSSÍVEL É 'E_ALL',


TIPO ASSIM:








error_reporting(E_ALL);













--> ISSO VAI REPORTAR TODOS OS ERRORS, INCLUSIVE WARNINGS...








-----> VOCE SEMPRE DEVE USAR __CONSTANTS__ PARA 
    SETTAR OS REPORTING LEVELS. Ou, alternativamente,
    vc pode usar o 'bitmask', o qual basicamente COMBINA 
    __ MÚLTIPLOS __ REPORTING LEVELS COM O bitwise operator, para 
    então formar o reporting level desejado...







POR EXEMPLO, SE VC QUER __''FAZER REPORT DE EVERYTHING, EXCEPT WARNINGS'',


                    VC PODE ESCREVER ASSIM:


                    'E_ALL & ~E_WARNING'




                    com isso, vc diz 

                    ''report EVERYTHING, except warnings'...






EX:







error_reporting(E_ALL & ~E_WARNING);















-> QUAL É A RECOMENDAÇÃO DO PROFESSOR?





-- USAR 'E_ALL' PRINCIPALMENTE EM DEVELOPMENT... E, ÀS VEZES, EM PRODUCTION...
    PQ AÍ VC VAI SER CAPAZ DE CATCH ERRORS EARLY ON...







---> CONFORME MENCIONADO ANTES, VC É  CAPAZ_
 DE ESPECIFICAR OS 'LEVELS DE REPORTING' USANDO 

 AS CONSTANTS JÁ PRÉ-DEFINIDAS..











 --> O PROFESSOR ENTÃO ABRE A _ LISTA__ 
    DE __ AVAILABLE ERROR-RELATED CONSTANTS NO PHP...




-> TODAS ELAS SÃO REPRESENTADAS POR 'int', podem ser traduzidas como ints... (e são lidas como ints, se printadas)...





    ELE FAZ 1 REVIEW RÁPIDO:







    1) E_ERROR --> REPRESENTA FATAL ___ RUN-TIME ERRORS... ESSE TIPO DE ERROR INTERROMPE A SCRIPT EXECUTION...




    2) E_WARNING --> REPRESENTA RUN-TIME WARNINGS (non-fatal errors), a execution não é halted...


    3) E_PARSE --> compile-time parse errors... Parse errors should only be generated by the parser.


    4) E_NOTICE  --> indica algo que PODERIA SER 1 ERROR, MAS QUE TBM PODERIA ACONTECER NORMALMENTE DURANTE A EXECUÇÃO DO SCRIPT...



    5) E_USER_ERROR --> 


    6) E_USER_WARNING --> TODOS ESSES SÃO COMO AS OUTRAS 'E_ERROR' E 'E_WARNING' constants,
                                MAS A DIFERENÇA EM RELAÇÃO A ELAS É QUE 

                                TODAS AS CONSTANTES COM PREFIXO DE 'E_USER'

                                SÃO GERADAS MANUALMENTE, POR MEIO 

                                DO USO 

                                DA ARROW FUNCTION DE 'trigger_error()',

                                QUE LOGO ESTUDAREMOS...



    7) E_STRICT -> 



    8) E_DEPRECATED -> 


    9) outros....


















-> CERTO... E O PROFESSOR HAVIA MENCIONADO QUE 
    PODEMOS FAZER O TRIGGER MANUAL DE ERRORS...











--> para fazer o trigger manual de 1 erro (o throw, basicamente),
    devemos usar 



    a function de 'trigger_error()',

    tipo assim:





    trigger_error('Example Error');












EX:






// Trigger an error manually:
trigger_error("", E_USER_ERROR);















-> NO CASO, VC DEVE PASSAR, como argumentos:



1) A ERROR MESSAGE 



2) O LEVEL DO ERROR QUE SERÁ TRIGGADO...










EX:







// Trigger an error manually:
trigger_error("YOUR ERROR MESSAGE HERE", E_USER_ERROR); // first argument is the error message, the second argument is the error <type>













--> NO CASO, 


SE RECARREGARMOS A PÁGINA, VEREMOS QUE ISSO VAI GERAR 1 FATAL ERROR,
    PQ O TIPO DE ERROR DE 'E_USER_ERROR' é realmente 

    1 FATAL ERROR...









EX:





// Error Handling 

// Set/alter error reporting settings, during runtime, if you wish:
error_reporting(E_ALL);

// Trigger an error manually:
trigger_error("YOUR ERROR MESSAGE HERE", E_USER_ERROR); // first argument is the error message, the second argument is the error <type>

// 'E_USER_ERROR' is a type of error that is fatal, and will stop the script from executing further.


echo 1; // this line will not be reached, because the error above will stop the script from executing further.
















SE QUEREMOS FAZER O THROW DE 1 ERROR QUE NÃO INTERROMPA A EXECUÇÃO DO SCRIPT,


PODEMOS 




USAR O TYPE DE 'E_USER_WARNING',

tipo assim:



trigger_error("YOUR OTHER ERROR MESSAGE", E_USER_WARNING); // 'E_USER_WARNING' won't stop the script from executing further, but will trigger a warning.




















OUTRA OBSERVAÇÃO:




''VC SÓ PODE USAR 'E_USER_XXX' error types 
    QUANDO VC FAZ O TRIGGER DE ERRORS MANUALMENTE...''






SE VC TENTA FAZER O TRIGGER DE ERRORS DE TYPE PADRÃO,
TYPE QUE NÃO É 'E_USER_XXXXX',

VC VAI GANHAR 1 ERROR..







EX:







trigger_error('EXAMPLE ERROR', E_WARNING); //// This won't work, we wil receive a fatal error of 'Argument #2 must be one of E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE OR E_USER_DEPRECATED'...










CERTO...





FAZ TOTAL SENTIDO....










--> OK... QUANDO 1 ERRO ACONTECE, NO PHP,



O PHP VAI DETERMINAR/DECIDIR
 

 SE 



 O 

 ERROR VAI SER 'DISPLAYED' OU NÃO 



 __ A PARTIR __ DO QUE 

 VC DEFINIU 


 NA PARTE DE 


 'display_errors' LÁ DO 'php.ini' file...













 EX:










 display_errors();
















 --> EM PRODUCTION, o 'display_errors()'


 SEMPRE DEVE SER __ TURNED __ OFF,

 TUDO PARA QUE 


 SENSITIVE INFORMATION NÃO FIQUE EXPOSTA,



 E PARA QUE ERRORS INTERNOS NÃO SEJAM MOSTRADOS AO USER...







 -> MESMO QUE ESSES ERRORS NÃO SEJAM DISPLAYED AOS USERS,
    ELES AINDA FICARÃO DISPONÍVEIS A VOCÊ, PARA QUE VOCÊ OS ESTUDE,


    DESDE QUE VC TENHA O 'ERROR_LOGGING' DO PHP 


    ATIVADO...









--> E A LOCALIZAÇÃO DO 'ERROR_LOG',
    NO SEU PROJECT PHP,

    DEPENDE DE ALGUNS FATORES...




--> MAS O XAMPP TE AJUDA COM ISSO,
    FAZ COM QUE SEJA BEM FÁCIL ENCONTRAR ESSE ERROR LOG...






-> BASTA CLICAR NO BOTÃO 'LOGS' DO SERVER APACHE,

    E DEPOIS SELECIONAR 'php_error_log'...










-> MAIS TARDE, VEREMOS COMO PODEMOS OBTER ERROR LOGS 
    NO SERVER EM SI,

    QUANDO ESTUDARMOS O SERVER PHP...








-> A PARTE DE SERVER PHP SERÁ VISTA NA TERCEIRA PARTE DO CURSO...






--> você também pode fazer log MANUAL DE ERRORS,    

    POR MEIO DA FUNCTION 



    DE 'error_log()'...














EX:








error_log()










-> COM ESSA FUNCTION, PASSAMOS 
    A 'MESSAGE' COMO ARGUMENT, 



    E AÍ 


    ISSO SERÁ LOGGADO, DENTRO DAQUELA FILE...














--> OK, MAS COMO PODEMOS HANDLAR ESSES ERRORS?











-> FELIZMENTE, O PHP TE DEIXA CRIAR CUSTOM ERROR HANDLERS,
QUE ENTÃO  __ VÃO __ DIZER AO PHP COMO ELE DEVE HANDLE ERRORS 
DURANTE O RUNTIME...







-> ISSO, NO CASO, TE DÁ PODER PARA CUSTOMIZAR O ERROR HANDLING 
    DO JEITO QUE VC QUISER (rodar cleanup actions QUANDO O ERROR É CHAMADO/LOGGED DE 
    ALGUMA FORMA ESPECÍFICA)...
















O PROFESSOR MOSTRA COMO PODEMOS 
'REGISTER' 1 CUSTOM ERROR HANDLER...







ESSE CUSTOM ERROR HANDLER PRECISA SEGURAR, OBRIGATORIAMENTE, DUAS COISAS:




1) É O 'ERROR TYPE', que será um INTEGER...



2) É A ERROR MESSAGE EM SI...




TIPO ASSIM:






// Error Handling 
function errorHandler(int $type, string $msg) {



}













OPCIONALMENTE,

VC PODE PASSAR TAMBÉM 

A 'file' em si, e também 


O LINE NUMBER EM QUE O ERROR APARECEU, TIPO ASSIM:







// Error Handling 
function errorHandler(int $type, string $msg, ?string $file = null, ?$int $line = null) {
    


}











OK... AÍ, DENTRO DE ESSA FUNCTION, PODEMOS FAZER O QUE QUISERMOS...










-- PODEMOS USAR IF-ELSE STATEMENTS E SWITCH STATEMENTS,
    TUDO PARA HANDLAR DIFERENTES TIPOS DE ERRORS, DE FORMAS DIFERENTES..












TIPO ASSIM:




// Error Handling 
function errorHandler(int $type, string $msg, ?string $file = null, ?$int $line = null) {
    

    echo $type . ':' . $msg . ' in ' . $file . ' on line ' . $line; 
}









É CLARO QUE, EM PRODUCTION, VC 

NAO USARIA ESSE CÓDIGO AÍ,


PQ O QUE QUEREMOS FAZER É __OCULTAR _ A INFO DO USER,

E NÃO 



OUTPUTTÁ-LA DIRETAMENTE AO USER...  


















-> SE VC QUER RETORNAR AO 'NORMAL PHP ERROR HANDLING' enquanto usa essa function de 'errorHandler' 
    para handlar errors, 


    BASTA FAZER RETURN DE 'FALSE',

    tipo assim:





    
// Error Handling 
function errorHandler(int $type, string $msg, ?string $file = null, ?$int $line = null) {

        echo $type . ':' . $msg . ' in ' . $file . ' on line ' . $line; 


        return false; // usado para voltar ao error handling comum do PHP... 
}



 






-> se vc retorna algo como 'true', ou qualquer outro value que 
    não seja 'false',

    A SCRIPT EXECUTION VAI CONTINUAR...











EX:






// Error Handling 
function errorHandler(int $type, string $msg, ?string $file = null, ?$int $line = null) {
        
        
        echo $type . ':' . $msg . ' in ' . $file . ' on line ' . $line; 


        return; // usado para voltar ao error handling comum do PHP... 
}












essa opção pelo 'return ao error handling comum' do 

php pode ser bom em alguns cases, 
 

 TALVEZ PARA ALGUNS ERROR TYPES...
















MAS VC TAMBÉM TALVEZ QUEIRA __ INTERROMPER A SCRIPT EXECUTION,

EM ALGUNS CASES... SE VC QUER 

REALMENTE __ INTERROMPER A EXECUÇÃO DO SEU SCRIPT 


PHP, vc deve usar a keyword 'exit',


tipo assim:






// Error Handling 
function errorHandler(int $type, string $msg, ?string $file = null, ?$int $line = null) {
        
        
        echo $type . ':' . $msg . ' in ' . $file . ' on line ' . $line; 


        exit; // usado para INTERROMPER A EXECUÇÃO.
}
















OK... 







ASSIM QUE TEMOS ESSA FUNCTION PRONTA,


PODEMOS REGISTRÁ-LA COMO ERROR HANDLER 

DEFAULT,

POR MEIO 



DO USO DA FUNCTION 



'set_error_handler()'...







essa function exige 2 parameters:




1o parameter) A FUNCTION A SER DISPARADA QUANDO ACONTECE 1 ERROR 




2o parameter) QUAIS TIPOS DE ERROR DEVEM DISPARAR ESSA FUNCTION/ser reportados...
 





tipo assim:










// Error Handling 
function errorHandler(int $type, string $msg, ?string $file = null, ?$int $line = null) {
        
        
        echo $type . ':' . $msg . ' in ' . $file . ' on line ' . $line; 


        exit; // usado para voltar ao error handling comum do PHP... 
}





set_error_handler('errorHandler', E_ALL); /// With this, we set the errorHandler function to trigger upon every error.














EX:












// Set alternative error handler as default error handler:
set_error_handler('errorHandler3', E_ALL); // 'E_ALL' is the error type, we want to catch all errors, all of them will trigger the first function, passed as a parameter.

















OK... MAS AQUI TEMOS 1 QUICK NOTE:









''ESSE SEGUNDO PARAMETER DE 'set_error_handler' VAI OVERWRITTAR 
    O TIPO DE ERROR REPORTING QUE VC SETTOU COM 'error_reporting(YOUR_ERROR_CONST_VALUE)''''





ou seja,

se antes vc tinha executado algo como 


error_reporting(E_ALL | E_STRICT),





esse call,


de 


'set_error_handler('errorHandler3', E_ALL);',







VAI OVERWRITTAR ESSE VALUE, com 'E_ALL'...













-> podemos testar isso, com este código:








error_reporting(E_ALL & ~E_WARNING); // reports all errors, except warnings 


echo $x; // This is an undefined variable, but it won't be reported, because of the '~E_WARNING' value.

















--> OK... MAS SE DEIXAMOS O ERROR_REPORTING COMO 



'E_ALL',


ganharemos o warning de essa undefined variable..



EX:




error_reporting(E_ALL); // reports all errors

echo $x; // This is an undefined variable, and it will be reported... 
















MAS SE TEMOS ESTE CÓDIGO:





error_reporting(E_ALL & ~E_WARNING); //// Initial Set

set_error_handler('errorHandler3', E_ALL);  //// Overwrites 'E_ALL & ~E_WARNING' value

echo $x; // This is an undefined variable, and it will be reported, as a warning, because of the 'E_ALL' overwriting the first value.























--> NOSSO CUSTOM ERROR HANDLER FUNCIONOU, NO CASO,

    PQ NOSSA CUSTOM MESSAGE REALMENTE FOI PRINTADA NO CONSOLE...


    




MAS TENHA EM MENTE QUE __ ALGUNS ERRORS_ __ NÃO PODEM 

SER HANDLADOS...







ALGUNS DELES SÃO:




1)  PARSE ERRORS 



2) COMPILE ERRORS...











OUTRO CASO É SE O ERROR ACONTECE 

__ANTES__ DO PONTO, NO SCRIPT, EM QUE VC


REGISTROU O ERROR HANDLER CUSTOMIZADO... (AÍ NÃO VAI SER HANDLADO POR ELE)















--> POR FIM, VC SEMPRE PODE RESTAURAR 
    O ERROR HANDLER ORIGINAL DO PHP, DURANTE RUNTIME,


    USANDO A FUNCTION DE 'restore_error_handler()'...








--> NÓS COBRIMOS O BASICS DO ERROR HANDLING NO PHP...







--> NÓS AINDA NÃO FALAMOS SOBRE 'EXCEPTIONS',
    QUE SÃO COISAS THROWN PELA MAIOR PARTE DOS ERRORS 

    DO PHP... VC PODE FAZER THROW DE SUAS PRÓPRIAS EXCEPTIONS, TAMBÉM...




---> EXCEPTIONS SÃO UMA OBJECT-ORIENTED WAY DE HANDLAR ERRORS,  
    E AS ESTUDAREMOS NA SEGUNDA SECTION DO CURSO...