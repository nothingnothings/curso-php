












--> ESTUDAMOS TRAITS, NA AULA ANTERIOR...














-> NA PRIMEIRA SECTION DO CURSO, APRENDEMOS ANONYMOUS FUNCTIONS...










-> MAS AGORA FALAREMOS SOBRE ANON CLASSES...
















--> ANON CLASSES -> NÃO POSSUEM NOME...















--> PARA CRIAR 1 ANON CLASS,
    VC USA 

    A KEYWORD DE 

    'new' + 'class{}'....















TIPO ASSIM:








<?php



require_once '../../src/vendor/autoload.php'; // imports the composer's autoloader



// Anonymous Class example:
$obj = new class {

};














ok...










ISSO FEITO, VC COLOCA A ESTRUTURA COMUM DE CLASSES 

DENTRO 


DESSA CLASS...













--> 








anon classes também ACEITAM ARGUMENTS, ATRAVÉS DO CONSTRUCTOR...










TIPO ASSIM:




<?php



require_once '../../src/vendor/autoload.php'; // imports the composer's autoloader





// Anonymous Class example:
$obj = new class(1, 2, 3) {

    public function __construct(public int $x, public int $y, public int $z) {

    }
};




var_dump($obj);




















COM ISSO, FICAREMOS COM 3 PROPERTIES,


COM OS VALUES 

'1' '2' E '3'....

















--> ANON CLASSES TAMBÉM PODEM USAR INHERITANCE,
    FAZENDO EXTEND DE OUTRAS CLASSES...







--> VC TAMBÉM PODE IMPLEMENTAR INTERFACES,
    USAR TRAITS E ETC,

    EXATAMENTE COMO QUALQUER OUTRA CLASS..











    TIPO ASSIM:


    

<?php



require_once '../../src/vendor/autoload.php'; // imports the composer's autoloader





// Anonymous Class example:
$obj = new class(1, 2, 3) extends MyClass implements MyInterface {

    use MyTrait;

    public function __construct(public int $x, public int $y, public int $z) {

    }
};




var_dump($obj);


















QUER DIZER QUE 


ANON CLASSES FUNCIONAM QUASE EXATAMENTE 

COMO REGULAR CLASSES..

















OBS:::







'''JUST BECAUSE THE CLASS DIDN'T RECEIVE A NAME,
    THIS DOESN'T MEAN THAT IT DOESN'T HAS A NAME...''




''THE ANON CLASS GETS ACTUALLY A AUTOMATICALLY-GENERATED
    NAME, GENERATED BY THE PHP ENGINE...''







-> PARA OBTER/DESCOBRIR ESSE NAME,,

PODEMOS 

USAR 


A FUNCTION DE 




'get_class()',


TIPO ASSIM:









var_dump(get_class($obj));
















COM ISSO, FICAMOS COM 1 NOME DE 




'class@anonymous' 














--> MAS, MESMO ASSIM, O PROFESSOR NÃO CONFIARIA NESSE NOME...











--> É POR ISSO QUE DEVEMOS SEMPRE ASSUMIR QUE 
    ''ANON CLASSES HAVE NO NAME''....














E, POR _ ANON CLASSES NÃO TEREM 


NAME ALGUM,




É IMPOSSÍVEL VC FAZER 'TYPE HINT'

DELAS,


IMPOSSÍVEL USÁ-LAS COMO TYPE...















--> SIM, VC NÃO PODE USAR COMO TYPE..










--> MAS HÁ UMA GAMBIARRA QUE VC PODE USAR,
    PARA CONSEGUIR USÁ-LAS COMO TYPE DE FUNCTIONS E OUTRAS COISAS...








--> NESSA GAMBIARRA,
    VC IMPLEMENTA UMA INTERFACE NA ANON FUNCTION,


    E, ENTÃO,

    USA A INTERFACE EM SI COMO TYPE..









    TIPO ASSIM:






$obj = new class (1, 2, 3) implements MyInterface {

    use MyTrait;

    public function __construct(public int $x, public int $y, public int $z)
    {

    }
};






function foo(MyInterface $obj) { //// THE TYPE HINTING of the ANON FUNCTION, by using the interface...

}


















-> COM ISSO, TEREMOS TYPE HINTEADO USANDO A 'ANON CLASS' + 'A INTERFACE'...


















--> VOCÊ TAMBÉM PODE USAR 
    ANON CLASSES _ DENTRO DE REGULAR CLASSES...



    (quer dizer que podemos actually 'STORE' 
    anon classes, dentro de outras classes...
    
    )













--> PARA ISSO, O PROFESSOR CRIA 1 REGULAR CLASS,

TIPO ASSIM:








class ClassA
{
    public function __construct(public int $x, public int $y) 
    {

    }


    public function foo(): string 
    {
        return 'foo';
    }

    public function bar()
    {
        return 
    }
}







--> NO CASO,


'bar()'


VAI RETORNAR 1 INSTANCE DE OUTRA CLASS... A NOSSA ANON CLASS,

TIPO ASSIM:















class ClassA
{
    public function __construct(public int $x, public int $y) 
    {

    }


    public function foo(): string 
    {
        return 'foo';
    }

    public function bar()
    {
        return new class {

        }
    }
}











DEIXAMOS O RETURN TYPE COMO 'object',

TIPO ASSIM:








class ClassA
{
    public function __construct(public int $x, public int $y) 
    {

    }


    public function foo(): string 
    {
        return 'foo';
    }

    public function bar(): object 
    {
        return new class {

        }
    }
}













NÃO PODEMOS TYPAR A ANON CLASS SEM USAR 

INHERITANCE OU INTERFACES,


MAS VC 


AINDA PODE 


TYPEHINT QUE ESSA FUNCTION ESTÁ RETORNANDO UM OBJECT...











-> PODEMOS VISUALIZAR 
O RETURN DESSA FUNCTION, COM ESTE CALL:












var_dump($obj->bar());











TUDO ESTÁ FUNCIONANDO, E ISSO ESTÁ RETORNANDO UMA INSTANCE 

DA ANON CLASS...













--> A COISA A SER PERCEBIDA, AQUI,

    É QUE, 


    DENTRO DA ANON CLASS,


    VC __ NÃO PODE ACESSAR 




    AS PROPERTIES E METHODS 


    DA MAIN CLASS...









    QUER DIZER QUE ISTO É IMPOSSÍVEL:




    

class ClassA
{
    public function __construct(public int $x, public int $y) 
    {

    }


    public function foo(): string 
    {
        return 'foo';
    }

    public function bar(): object 
    {
        return new class {

            public function __construct() 
            {
                echo $this->y;  ///THIS WON'T WORK
            }
        }
    }
}














-> ISSO NAO FUNCIONA PQ ESTAMOS NOS REFERINDO 

    'TO THE INNER CLASS',



    e não à outer class..














-> SE VC QUER REALMENTE TER ACESSO às PROPERTIES DA OUTER CLASS,
    VC PODE 



    SIMPLESMENTE PASSAR ESSES VALUES POR DENTRO DO CONSTRUCTOR DESSA ANON CLASS..






--> OU, ALTERNATIVAMENTE,

VC PODE FAZER 'extend'


DA OUTER CLASS,


para então chamar o 'super()' (que é 'parent::__construct()')




E ENTÃO RODAR O RESTO DA SUA LÓGICA,

TIPO ASSIM:








<?php



namespace App7;


class ClassA
{
    public function __construct(public int $x, public int $y)
    {

    }


    public function foo(): string
    {
        return 'foo';
    }

    public function bar(): object
    {
        return new class ($this->x, $this->y) extends ClassA {
            public function __construct(public int $x, public int $y)
            {
                parent::__construct($x, $y);
                // echo $this->y;  /// ! THIS WON'T WORK (cannot access outer class properties directly like this, they need to be passed in as arguments of the constructor)

                $this->foo();
            }
        };
    }
}





















MAS SE VC N QUER USAR INHERITANCE E NÃO QUER FAZER 'EXTEND',

VC 


TEM 2 OPTIONS:







1) PASSAR AS PROPERTIES COMO ARGUMENTS DO CONSTRUCTOR  









2) PASS DOWN THE CURRENT OBJECT...


















OK... ISSO PARECE LEGAL,

MAS QUAL É O MAIN-USE CASE DISSO?










--> O MAIN-USE CASE DE ANON CLASSES 

É 


__tESTING_..







-> PQ ELE TE DEIXA CRIAR 


    ONE-OFF OBJECTS 


    COM BASE EM 1 ANON CLASS... AÍ, COM ISSO,


    VC PODE 

    FAZER 

    A ANON CLASS IMPLEMENTAR 1 INTERFACE,

    USAR 1 ABSTRACT CLASS,


    COM 



    BASE 


    NOS SEUS TESTING NEEDS...





    -> É BEM ÚTIL QUANDO É USADA PARA 'MOCKING'...






EX:









protected function setUp() 
{
    $this->myObj = new class implements GreetingInterface {
        public function greeting(): string 
        {
            return 'Hello World';
        }
    }
}









-> MAS VEREMOS MAIS SOBRE TESTING MAIS TARDE....




--> PROFESSOR NUNCA USOU ANON FUNCTIONS FORA DE TESTING...









AQUI ESTÃO OS USE-CASES/VANTAGENS DE ANON FUNCTIONS:









''A FEW QUICK POINTS:

    -- Mocking tests becomes easy as pie. Create on-the-fly implementations for interfaces, avoid using complex mocking APIs 

    -- Keep usage of htese classes outside the scope they are defined in 

    -- Avoid hitting the autoloader for trivial implementations (microoptimization)