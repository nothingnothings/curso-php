






na última aula, revimos os basics do mysql...








NESSA AULA, 

VAMOS:





1) CONECTAR A MYSQL DATABASE AO PHP 



2) USAR PHP PDO, PARA RODAR QUERIES...



3) VAMOS APRENDER SOBRE 'PREPARED STATEMENTS'




4) SQL INJECTION (E COMO A EVITAR) 



5) EMULATED PREPARES...














-> VC PODE ADICIONAR DATABASE USAGE AO SEU APP DE DIVERSAS 
    MANEIRAS...













1a MANEIRA: 


                POR MEIO DO USO DE 'NATIVE PHP FUNCTIONS' PARA O MYSQL 
                DRIVER, COMO POR EXEMPLO 

                AS FUNCTIONS 

                DE 'MySQLi'...









2a MANEIRA:


                POR MEIO DO USO DOS 'PHP DATABASE OBJECTS' (chamado de 'PDO')...










TANTO AS 'MySQLi' functions 

como o PDO 


possuem vantagens próprias...

















mySQLi:


-- OFERECE TANTO 'PROCEDURAL' COMO 'OOP' APPROACHES...


-- Suporta APENAS MySQL...

 

-- NÃO SUPORTA NAMED PARAMETERS...






PDO:


-- É 'ALL ABOUT OOP', não tem nada de procedural...


-- Suporta diversos drivers, como 'MySQL', SQLite, etc...


-- SUPORTA 'NAMED PARAMETERS'...











AS DATABASES SUPORTADAS PELO PDO SÃO:







Driver name	Supported databases

PDO_CUBRID	Cubrid
PDO_DBLIB	FreeTDS / Microsoft SQL Server / Sybase
PDO_FIREBIRD	Firebird
PDO_IBM	        IBM DB2
PDO_INFORMIX	IBM Informix Dynamic Server
PDO_MYSQL	MySQL 3.x/4.x/5.x/8.x
PDO_OCI	    Oracle Call Interface
PDO_ODBC	ODBC v3 (IBM DB2, unixODBC and win32 ODBC)
PDO_PGSQL	PostgreSQL
PDO_SQLITE	SQLite 3 and SQLite 2
PDO_SQLSRV	Microsoft SQL Server / SQL Azure











CERTO... BASICAMENTE, O PDO 


'ABSTRACTS AWAY THE DATA ACCESS LAYER',


AND 

'PROVIDES THE COMMON INTERFACE'...









--> VC DEVE ENTENDER QUE O 'PDO'
 

 'DOES NOT PROVIDE DATABASE ABSTRACTION' --> ISSO É ALGO QUE 
                                            ALGUNS FRAMEWORKS OFERECEM,

                                            MAS O PDO EM SI NÃO OFERECE..








-> O PDO É 'LIKE A DATA ACCESS LAYER...'...










-> ANTES DE MAIS NADA, PRECISAMOS GARANTIR QUE 

    O DRIVER PDO __ ADEQUADO ESTÁ ENABLADO...








    ''WHILE PDO IS ENABLED BY DEFAULT, IN PHP,

    YOU STILL NEED TO ENABLE THE SPECIFIC DRIVER, FOR THE 
    DATABASE YOU ARE GOING TO BE USING'...







-> COMO VAMOS USAR UMA DATABASE MYSQL,

    PRECISAMOS DO PDO 



    'PDO_MYSQL'...





-> PRECISAMOS CHECAR SE ESSE DRIVER ESTÁ ENABLED... E , SE NÃO ESTIVER ENABLED,
                                                    PRECISAMOS ENABLÁ-LO...






 
 --> PODEMOS CHECAR SE O PDO MYSQL DRIVER ESTÁ ENABLADO 

 COM A CLÁSSICA FUNCTION 


 'phpinfo()'..









 -> BASTA RODAR ISSO EM 'HomeController',

 tipo assim:








class HomeController
{

    public function index(): View
    {


        // return (new \App21\View('index'))->render();

        phpinfo();

        return View::make('index', ['foo' => 'bar']);
    }






















BEM MAIS PARA BAIXO, ENCONTRAMOS ISTO:







'PDO 




PDO Support 


PDO Drivers          sqlite












--> BASICAMENTE, PERCEBEMOS QUE O ÚNICO DRIVER AVAILABLE PARA 

    O PDO, NO NOSSO APP,


    É O SQLITE...



 

--> PRECISAMOS ENABLAR O DRIVER MYSQL...











-> ESSE PROCESSO PODE SER 1 PCO DIFERENTE A DEPENDER:





1) DO SISTEMA OPERACIONAL DE SEU SERVER




2) DE COMO SEU PHP ESTÁ INSTALADO...









-> SE VC SEGUIU A SÉRIE ATÉ AGORA, VC ESTÁ COM O PHP NO DOCKER...








SE VC ESTÁ USANDO ALGO COMO XAMPP,


ENABLAR ESSE DRIVER SERÁ BEM MAIS SIMPLES...







-> BASTA ABRIR A CONFIG FILE DO PHP (php.ini)

E DESCOMENTAR A PARTE DE 



';extension=pdo_mysql'...







-> DEPOIS DE DESCOMENTAR ISSO, 
    VC DEVE REINICIAR SEU WEBSERVER,

    PARA TER ESSE DRIVER HABILITADO COM SUCESSO...






EX:







extension=bz2
extension=curl
;extension=ffi
;extension=ftp
extension=fileinfo
;extension=gd
extension=gettext
;extension=gmp
;extension=intl
;extension=imap
;extension=ldap
extension=mbstring
extension=exif      ; Must be after mbstring as it depends on it
extension=mysqli
;extension=oci8_12c  ; Use with Oracle Database 12c Instant Client
;extension=oci8_19  ; Use with Oracle Database 19 Instant Client
;extension=odbc
;extension=openssl
;extension=pdo_firebird
extension=pdo_mysql
;extension=pdo_oci
;extension=pdo_odbc
;extension=pdo_pgsql
extension=pdo_sqlite
;extension=pgsql
;extension=shmop


















-> COM O DOCKER, NO ENTANTO,

    O PROCESSO É MAIS COMPLEXO...







PRECISAMOS:






1o) INSTALAR O PDO 



2o) ENABLAR O PDO...












FELIZMENTE, O REPO DO PHP NO DOCKERHUB
 


 TEM 1 HELPER SCRIPT QUE PODEMOS EXECUTAR 
 PARA FAZER ISSO PARA NÓS...







--> PARA EXECUTAR ESSE HELPER SCRIPT,


BASTA IR 


ATÉ O arquivo 'Dockerfile',




que está com este código:





FROM php:8.0.2-fpm 


RUN apt-get update && apt-get install -y \
    git \
    curl \
    zip \
    unzip 

RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

WORKDIR /var/www












E ENTÃO RODAR, DEPOIS DO 'curl',



O CÓDIGO DE 




'RUN docker-php-ext-install pdo pdo_mysql'












--> ISSO VAI INSTALAR O PDO E ENABLAR O MYSQL DRIVER...





TIPO ASSIM:






FROM php:8.0.2-fpm 


RUN apt-get update && apt-get install -y \
    git \
    curl \
    zip \
    unzip 

RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

RUN docker-php-ext-install pdo pdo_mysql

WORKDIR /var/www



















DEPOIS DISSO, RE-RODAMOS O DOCKER COMPOSE,



COM docker-compose up -d --build...
















OK.. ISSO VAI REBUILDAR A IMAGE....









-> AÍ RECARREGAMOS A PAGE,

E AÍ VEREMOS, LÁ NA INFO OUTPUTTADA 

POR 'phpinfo()',





a parte:





PDO 




PDO drivers    sqlite, mysql...


















OK... AGORA QUE ESTAMOS COM O PDO SETTADO,


PODEMOS ACTUALLY UTILIZÁ-LO, DENTRO DE NOSSO CÓDIGO,

PARA NOS CONECTARMOS À DATABASE MYSQL...

















--> VAMOS FAZER TUDO DE DENTRO DO CONTROLLER DE 'HomeController',


para facilitar..














COMEÇAMOS COM ALGO TIPO ASSIm:








    public function index()
    {






        phpinfo();

        return View::make('index', $_GET)->render();






















CERTO...







MAIS TARDE, VAMOS EXTRAIR 


ESSA LÓGICA DE 'PDO' EM OUTRO LUGAR..














-> CERTO... MAS VAMOS CRIAR 1 NOVO OBJECT '$db',

COM A CLASS DE 'PDO',

tipo assim:






        // * PDO (php data objects - with my sql) lesson:
        $db = new PDO();













OK... MAS É CLARO QUE ESSE CONSTRUCTOR EXIGE 
    ALGUNS ARGUMENTS...







OS ARGUMENTS SÃO:






'''THE DATA SOURCE NAME''  (DSN) ------>  CONTÉM 'THE HOST OF THE DATABASE' + 'THE DATABASE NAME'...



'''THE DATABASE CREDENTIALS''' (username, password)



''SOME OPTIONS'' (se necessário)














O 'DSN' SEMPRE TEM ESTE FORMATO:



mysql:host=DB_HOST;dbname=DB_NAME;













--> NO CASO, O NOSSO VAI FICANDO ASSIM:




mysql:host=localhost;dbname=MY_DB;










O HOST É LOCALHOST,


a database é 'MY_DB'...









--> depois disso, temos o USER E O PASSWORD...


O VALUE DOS 2 É 'root',

POR ISSO ESCREVEMOS ASSIM:





        // * PDO (php data objects - with my sql) lesson:
        $db = new PDO(
            'mysql:host=localhost;dbname=MY_DB',
            'root',
            'root'

        );











EX:







        // * PDO (php data objects - with my sql) lesson:
        $db = new PDO(
            'mysql:host=localhost;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
            'root', // username
            'root' // password
        );













    CERTO... AÍ REFRESHAMOS A PAGE,

    E FICAMOS COM 1 ERROR..









--> ''PDO EXCEPTION' --> 










''Uncaught PDO Exception''....






se há qualquer erro de connection,
o pdo 

FAZ O THROW DE 1 EXCEPTION, COMO ELE FEZ, AQUI..











CERTO, MAS PQ NAÕ ESTAMOS SENDO CAPAZES DE NOS CONECTAR 

A ESSA 

DATABASE, AQUI?










-> O PROBLEMA, AQUI, 

É O 'HOSTNAME'...







--> NO CASO, AQUI COLOCAMOS 

'localhost' como HOSTNAME...







--> mas se trocamos para '127.0.0.1',



FICAMOS COM OUTRO TIPO DE ERROR...

FICAMOS COM 


'Connection Refused'...










O PROBLEMA, AQUI,


É QUE 




''PDO IS TRYING TO CONNECT TO THIS HOST _ FROM WITHIN THE 

    ___ APP CONTAINER... BUT  ___ _THERE __ IS NO MYSQL 
    INSTALLED WITHIN THE CONTAINER''...







--> O MYSQL ESTÁ INSTALADO NO LADO DE __ FORa__ DO CONTAINER...






-> SIGNIFICA QUE PRECISAMOS DE ALGUMAS TRICKS DO DOCKER,
    PARA CONSEGUIRMOS NOS CONECTAR 

    COM ESSE host aí...




--> PROVAVELMENTE PRECISAMOS USAR A PORT DE '3306',

que foi exposta para essa database, anteriormente...






TIPO ASSIM:




        // * PDO (php data objects - with my sql) lesson:
        $db = new PDO(
            'mysql:host=localhost:3306;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
            'root', // username
            'root' // password
        );













--> MAS O PROFESSOR AINDA APONTA QUE 

NÃO DEVEMOS COLOCAR 'localhost',


E SIM DEVEMOS COLOCAR 


O CONTAINER NAME EM SI...




PQ É ASSIM QUE FUNCIONA, COM O DOCKER...






---> por isso que apenas colocamos um host de 'db'...






TIPO ASSIM:








        // * PDO (php data objects - with my sql) lesson:
        $db = new PDO(
            'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
            'root', // username
            'root' // password
        );









ISSO PQ,

LÁ NO DOCKER-COMPOSE.YML,



TEMOS ESTE CÓDigo:





  db: //// THIS IS THE CONTAINER IDENTIFIER...
    container_name: programwithgio-db
    image: mysql:8.0
    volumes: 
      - ./storage/mysql:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
    ports:
      - 3306:3306

















é por isso que 'db' funciona... 













-> CERTO... AGORA ESTAMOS FICANDO COM O OBJECT,


E COM NENHUMA EXCEPTION...









ex:



object(PDO)#5 (0) { }


















--> CERTO... 

MAS ANTES DE PROSSEGUIR, O PROFESSOR QUER TRIGGAR A EXCEPTION 
MAIS 1 VEZ,

PQ APARENTEMENTE ESTAMOS COM UM 'BIG PROBLEM',

QUE PRECISA SER CONSERTADO..









PARA ISSO, O PROFESSOR COLOCA UMAS CREDENTIALS ERRADAS, SÓ PARA TESTAR,
TIPO ASSIM:


        // * PDO (php data objects - with my sql) lesson:
        $db = new PDO(
            'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
            'root', // username
            'rootdassdaa' // password
        );













    ISSO TRIGGA A EXCEPTION:






Fatal error: Uncaught PDOException: SQLSTATE[HY000] [1045] Access denied for user 'root'@'172.18.0.3' (using password: YES) in /var/www/app/Home.php:88 Stack trace: #0 /var/www/app/Home.php(88): PDO->__construct('mysql:host=db;d...', 'root', 'rootdassdaa') #1 [internal function]: App19\Classes\Home->index() #2 /var/www/app/Router.php(63): call_user_func_array(Array, Array) #3 /var/www/public/index.php(75): App19\Router->resolve('/', 'get') #4 {main} thrown in /var/www/app/Home.php on line 88














mas o problema, no caso, é que essa exception 
ESTÁ 


DEIXANDO EXPOSTOS 

__ TODOS OS VALUES DAS CREDENTIALS


(aquela parte de 


construct('mysql:host=db;d...', 'root', 'rootdassdaa')
)












--> ISSO ESTÁ DANDO TODO O DSN,

    E TAMBÉM 
    O PASSWORD... ISSO É NADA 

    SECURE, E 'PRETTY BAD'...








-> E AINDA QUE NÃO ESTIVÉSSEMOS 
    ENVIANDO ESSES ERRORS AOS USERS,


    TALVEZ ESTEJAMOS ENVIANDO ESSES ERRORS 
    A THIRD-PARTY SERVICES QUE HANDLAM NOSSOS ERRORS,

    
    MAS NÃO INTERESSA, O QUE IMPORTA É QUE ESSA 

    É _ SENSITIVE INFORMATION,

    E QUE _ ELA _ NÃO DEVE SER EXPOSTA DESSA FORMA...






--> PARA RESOLVER ISSO, PODEMOS SIMPLESMENTE WRAPPAR 
ESSE CÓDIGO COM UM TRY-CATCH,

E AÍ 

HANDLAR DE FORMA DIFERENTE, LÁ NO CATCH,
TIPO ASSIM:





       // * PDO (php data objects - with my sql) lesson:
        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                'rootdassdaa' // password
            );

            var_dump($db);

        } catch (\Throwable $e) {
            echo 'Something went wrong when trying to connect to the database.';
        }
















--> OU PODEMOS, ALTERNATIVAMENTE, FAZER O THROW 

DE 1 CUSTOM 'PDOException',

MAS 

COM MENOS INFO,

TIPO ASSIM:



       // * PDO (php data objects - with my sql) lesson:
        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                'rootdassdaa' // password
            );

            var_dump($db);

        } catch (\PDOException $e) {
            // With this, we can hide sensitive database information (like username and password) from the user.
            throw new \PDOException($e->getMessage(), (int) $e->getCode());
        }








OK...








COM ISSO, 



FICAMOS COM 1 ERROR HANDLING BEM MELHOR...





O CÓDIGO DE ERRO FICA ASSIM:









Fatal error: Uncaught PDOException: SQLSTATE[HY000] [1045] Access denied for
 user 'root'@'172.18.0.3' (using password: YES) in 
 /var/www/app/Home.php:96 Stack trace: #0 [internal function]:
  App19\Classes\Home->index() #1 /var/www/app/Router.php(63): call_user_func_array(Array,
   Array) #2 /var/www/public/index.php(75): App19\Router->resolve('/', 'get') 
   #3 {main} thrown in /var/www/app/Home.php on line 96












CERTO... 







OUTRO DETALHE:







''YOU MUST KNOW __ THAT __ THE CONNECTION WILL REMAIN ACTIVE 
    UNTIL:

        1) THE SCRIPT ENDS 


        2) THERE ARE NO MORE REFERENCES TO THE PDO OBJECT, IN THE CODE...''


    



NÓS TAMBÉM PODEMOS, ALTERNATIVAMENTE,

    PASSAR 1 LISTA DE OPTIONS À CLASS DE 
    'PDO', COMO ARGUMENT...







    OU, ENTÃO, PODEMOS USAR 
    O METHOD DE 'setAttribute()',

    NO OBJECT 'PDO',
    PARA 
     SETAR ALGUNS DESSES ATTRIBUTES..







--> MAS NÃO VAMOS USAR O METHOD DE setAttribute() por enquanto,
    e sim vamos 

    USAR O PASS DE OPTIONS NO CONSTRUCTOR....











--> '''ONE OF THE OPTIONS THAT YOU MIGHT WANT TO SET, 
       DEPENDING ON YOUR PHP VERSION, IS THE _ _ERROR __ MODE__ ''








       O ERROR MODE 'DETERMINA A MANEIRA PELA QUAL 
       __ERRORS__ SÃO HANDLADOS _ PELO PDO 



        (DETERMINA SE 

        O PHP DEVE 

        'THROW EXCEPTIONS', 'THROW WARNINGS'

        OU 'DO NOTHING AT ALL' 
        E SIMPLESMENTE  DEIXAR O DEVELOPER INSPECIONAR 
        O ERROR CODE E MESSAGE ATRAVÉS DOS AVAILABLE METHODS...
        
        )





    tipo assim:



    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);







-> ANTES DO PHP8,


NO PDO, 

O 'SILENT MODE'  ERA O DEFAULT...











OS VALUES POSSÍVEIS SÃO:





'PDO::ERRMODE_SILENT''




''PDO::ERRMODE_WARNING''



''PDO::ERRMODE_EXCEPTION''...










ANTES DO PHP8,

O SILENT MODE ERA O DEFAULT... ANTES DELE,

SE VC QUISESSE FAZER O THROW DE EXCEPTIONS QUANDO OCORRESSEM ERRORS,
VC 

TERIA 

DE 

'SET THE EXCEPTION MODE', através das options (com 'PDO::ERRMODE_EXCEPTION')...















-> mas, DESDE O PHP8, 

O EXCEPTION MODE É O DEFAULT,

POR ISSO NÃO PRECISAMOS MUDAR COISA ALGUMA...





---------------------------------------------








OK.. AGORA, FINALMENTE, DEVEMOS RODAR ALGUMAS QUERIES...






QUERIES...












--> TEMOS 2 TABLES, INVOICES E USERS...










-> O PROFESSOR POPULOU A TABLE COM 1 BOCADO DE DATA,

PARA QUE CONSIGAMOS QUERIÁ-LA...












-> PARA RODAR QUERIES, PODEMOS 







USAR O METHOD DE 'query()'

DENTRO 


DE 
'$db',



TIPO ASSIM:



        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                'rootdassdaa' // password
            );

            $query = 'SELECT * FROM users';

            $stmt = $db->query($query);

            $result = $stmt->fetchAll(PDO::FETCH_ASSOC);

            return $result;












O METHOD DE 


'->query(YOUR_QUERY)'



RETORNA 

UM _ _OBJETO __ DA 

CLASS 

'Statement' DO PDO...







-> ESSE OBJECT, 'statement',


    PODE SER USADO PARA __ RETRIEVAR 

    __ OS RESULTADOS DA QUERY...



--> O PROFESSOR USA O METHOD DE '->fetchAll()',

PARA FETCHEAR 

TODA A DATA RETORNADA...










PODEMOS RODAR ALGO ASSIM:










        // * PDO (php data objects - with my sql) lesson:
        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                // 'rootdassdaa', // ! Testing errors and exception handling.
                'root', // password

            );

            $query = 'SELECT * FROM users';

            $stmt = $db->query($query);

            $result = $stmt->fetchAll(PDO::FETCH_ASSOC); // 'fetchAll' - method that is used to fetch all the results from the query.

            echo '<pre>';
            print_r($result);
            echo '</pre>';







        COMO RESULTADO, FICAMOS COM ESTE PRINT:




 Array
(
    [0] => Array
        (
            [ID] => 1
            [EMAIL] => john@doe.com
            [FULL_NAME] => John Doe
            [IS_ACTIVE] => 1
            [CREATED_AT] => 2024-08-11 22:02:16
        )

    [1] => Array
        (
            [ID] => 2
            [EMAIL] => jane@doe.com
            [FULL_NAME] => Jane Doe
            [IS_ACTIVE] => 1
            [CREATED_AT] => 2024-08-11 22:02:16
        )

)












CERTO...











COMO VC PODE TER PERCEBIDO,

O RETURNED VALUE É UM __ ARRAY_.... 








O ARRAY É 

'INDEXED BY __ BOTH 
    THE COLUMN NAME

    AND THE 0-INDEXED COLUMN NUMBER'...












-> E ESSE É O DEFAULT FETCH MODE DO 'PDO',

    que é chamado de 

    'FETCH_BOTH'...








-> PDO::FETCH_BOTH...








MAS PODEMOS MUDAR ESSE DEFAULT FETCH MODE 


__ GLOBALMENTE,

DENTRO DAS OPTIONS DO PDO,


OU 

ENTÃO 


PODEMOS 

MUDAR ISSO LOCALMENTE,




COM 


'THE PASS OF THE FETCH MODE AS AN ARGUMENT 

TO METHODS LIKE 'fetchAll()'...'''












-> TAMBÉM PODERÍAMOS PASSAR O 'FETCH MODE'

COMO 2o argumento DO METHOD de 'query()",



MAS VAMOS 

USAR APENAS 

COMO O


ARGUMENTO DE 'fetchAll()',


por enquanto,

TIPO ASSIM:





      // * PDO (php data objects - with my sql) lesson:
        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                // 'rootdassdaa', // ! Testing errors and exception handling.
                'root', // password

            );

            $query = 'SELECT * FROM users';

            $stmt = $db->query($query);

            $result = $stmt->fetchAll(PDO::FETCH_OBJ); // 'fetchAll' - method that is used to fetch all the results from the query.

            echo '<pre>';
            print_r($result);
            echo '</pre>';

        }










COLOCAMOS UM VALUE DE MODE DE 'PDO::FETCH_OBJ'...











--> ISSO VAI 


'''FETCH EACH ROW AS AN OBJECT OF PHP's 'stdClass'.. '''








tipo assim:






Array
(
    [0] => stdClass Object
        (
            [ID] => 1
            [EMAIL] => john@doe.com
            [FULL_NAME] => John Doe
            [IS_ACTIVE] => 1
            [CREATED_AT] => 2024-08-11 22:02:16
        )

    [1] => stdClass Object
        (
            [ID] => 2
            [EMAIL] => jane@doe.com
            [FULL_NAME] => Jane Doe
            [IS_ACTIVE] => 1
            [CREATED_AT] => 2024-08-11 22:02:16
        )

)
















CERTO...






FICAMOS COM CADA ROW COMO 1 OBJECT...







'IF YOU WANTED THE DEFAULT FETCH 

TO BE AN OBJECT AS WELL,


YOU CAN SET THE DEFAULT FETCH MODE FROM INSIDE 

THE PDO object's options',

TIPO ASSIM:




        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                // 'rootdassdaa', // ! Testing errors and exception handling.
                'root', // password

                [
                    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_OBJ
                ]
            );










    CERTO...










É CLARO QUE EXISTEM OUTROS FETCH MODES... PODEMOS CHECAR OS DOCS SOBRE ISSO..









--> MAS OS FETCH MODES MAIS COMUNS, MAIS UTILIZADOS,

SÃO:







'PDO::FETCH_ASSOC' --> VAI 'INDEX' O ARRAY CONSIDERANDO OS COLUMN NAMES... CADA ROW VAI SER SÓ 1 ASSOCIATE ARRAY, COM AS COLUMNS SENDO AS KEYS...








O OUTRO É:




'PDO::FETCH_CLASS' -> ESSE VAI ''FETCH ROWS AS _ OBJECTS__ OF THE GIVEN CLASSNAME (que vc passa como outro argument) ''


                                ''IT WILL MAP THE COLUMNS TO THE PROPERTIES 
                                OF THE CLASS, BY THE NAME...''


                                 ''AND IF THE COLUMN NAME DOES NOT EXIST AS THE 
                                 PROPERTY ON THAT CLASS, THEN IT WILL CALL THE 
                                 MAGIC __set() method of php, which will dynamically 
                                 CREATE THAT PROPERTY AND MAKE IT AVAILABLE ON THAT OBJECT'...








POR FIM,

TEMOS 







'PDO::FETCH_OBJ' -> ESSE É O QUE RECÉM FIZEMOS,
                        QUE VAI 

                        ''FETCH EACH ROW AS PHP'S STANDARD OBJECTS'...













-> O PROFESSOR DIZ QUE 

USAR O METHOD DE 'query()'


é ___ FINE__ PARA 



SIMPLE QUERIES COMO ESSA..








-> TAMBÉM É FINE PARA QUERIES 
    COMPLEXAS QUE CONTÉM 


    COISAS COMO 

    'JOINS, ORDER BY, WHERE CLAUSE', etc...







--> MAS SE VC PRECISA 
    USAR USER INPUT COMO 
    PARAMETERS PARA A QUERY 

    (como para a WHERE CLAUSe),

AI A USAGE DO METHOD DE 'query()"

NÃO É IDEAL...









-> ALÉM DISSO, SE VC QUER 
RODAR 1 MESMA QUERY EM 1 LOOP,


'query()' method não vai ser mt eficiente...









-> É NESSES CASOS QUE 

OS 'Prepared Statements' PODEM AJUDAR...









Prepared Statements 



---> NÃO É ALGO LIMITADO AO PHP...








-> É UMA FEATURE QUE EXISTE/FOI ORIGINADA EM 

DATABSAE MANAGEMENT SYSTEMS...







-> OS PREPARED STATEMENTS TRAZEM 2 MAIN ADVANTAGES:



1a) --> MORE EFFICIENT...



            ''YOU PREPARE THE QUERY ONCE, AND THEN YOU EXECUTE IT 
                MULTIPLE TIMES, WITH EITHER THE SAME 
                OR DIFFERENT PARAMETERS''....

                (isso resolve o problema de executar sua query dentro 
                de loops, por exemplo...)







2a --> BETTER PROTECTION AGAINST SQL INJECTIONS...










SQL INJECTION --> É QUANDO 1 STATEMENT MALICIOSO    
                    É INJETADO NA QUERY... E QUE PODE 
                    ACONTECER ATRAVÉS DE USER INPUTS COMO 

                    QUERY STRINGS E POST DATA....








-> O PROFESSOR NOS MOSTRA 1 EXEMPLO...








-> ''LET'S SAY THAT WE WANT TO FIND EMAILS 
    WITH X ID...''




    --> ''LET'S SAY THAT THE EMAIL COMES FROM A QUERY STRING'...







-> PODERÍAMOS ESCREVER TIPO ASSIM:






$query = 'SELECT * FROM users WHERE email = " ' . $email . '"';












-> PODEMOS PEGAR O EMAIL DA SUPERGLOBAL DE '$_GET',

TIPO ASSIM:




 

$email = $_GET["email"];
 
$query = 'SELECT * FROM users WHERE email = " ' . $email . '"';

















--> OK... 
AÍ, LÁ NA URL, PODEMOS ESCREVER ASSIM:



localhost:8000/?email=foo@bar.com 











-> ISSO VAI FAZER COM QUE O SQL PROCURE POR 1 EMAIL DE 

'foo@bar.com'...









-> O PROFESSOR FAZ 1 ECHO DA QUERY EM SI,


COM ESTE ´CODIGO:







       // * PDO (php data objects - with my sql) lesson:
        try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                'root', // password
            );



            $email = $_GET["email"];

            $query = 'SELECT * FROM users WHERE email = " ' . $email . '"';

            echo $query;

            // $query = 'SELECT * FROM users';

            $stmt = $db->query($query);

            $result = $stmt->fetchAll(PDO::FETCH_ASSOC); // 'fetchAll' - method that is used to fetch all the results from the query.

            echo '<pre>';
            print_r($result);
            echo '</pre>';

















        certo... 









    COMO ESTAMOS FAZENDO INJECT DO USER INPUT DIRETAMENTE

    NA QUERY,


    TECNICAMENTE PODEMOS MODIFICAR ESSA QUERY....






--> DEVEMOS PASSAR UM " DEPOIS DO value de 'email',



PARA 

QUEBRAR NOSSO APPP...







TIPO ASSIM:





localhost:8000/?email=foo@bar.com " 













ISSO JÁ VAI QUEBRAR NOSSO APP,

COM 1 FATAL ERROR, O QUE JÁ É BEM RUIM..







DEPOIS DE ", 
O PROFESSOR 


ESCREVE 

'+' E DEPOIS 'OR'...






TIPO ASSIM:


localhost:8000/?email=foo@bar.com"+OR 














-> OK...







AGORA, COM ISSO, 



PODEMOS 



RETORNAR MAIS USERS DO QUE O ESPERADO,


POR MEIO DO PROVIDE DE 1 SIMPLES TRUTHY CONDITION...








--> PODEMOS ESCREVER TIPO ASSIM:




localhost:8000/?email=foo@bar.com"+OR+1=1 



















-> COMO '1' É SEMPRE '1',

ESSA QUERY SEMPRE SERÁ TRUE...





COM ISSO, ESTAMOS SELECIONANDO 


_ TODOS OS USERS 




QUE POSSUAM EMAIL DE 'foo@bar.com' 



OU '1=1'.... ou seja,

TODOS USERS... 













ISSO VAI ESSENCIALMENTE RETORNAR TODOS OS USERS 

DA TABLE DE USERS...







-> A ÚNICA COISA QUE FALTA, PARA FAZER ISSO FUNCIONAR,


É REMOVER 

O " final...











-> PARA ISSO, BASTA ESCREVERMOS 
ASSIM:





'localhost:8000/?email=foo@bar.com"+OR+1=1+--+' 
















COM ISSO, CONSEGUIMOS TODOS OS USERS DE VOLTA,

E NÃO SÓ 1 ÚNICO USER...












E ISSO É A SQL INJECTION, BASICAMENTE...









--> CONSEGUIMOS RETRIEVAR DATA DE FORMA ILEGAL, LÁ DA DATABASE,

    POR MEIO DO INJECTION DE QUERIES QUE VÃO SEMPRE RETORNAR TRUE 


    'WHERE 1=1'...










--> HÁ VÁRIAS VARIAÇÕES E MANEIRAS DE INJETAR SQL,
    E NEM TODAS QUERIES VÃO TER ESTA APARÊNCIA,
    MAS É BEM SIMPLES QUEBRAR 1 APP, SE ELE É VULNERÁVEL
    A ATAQUES SQL...









--> ALÉM DE PODER SELECIONAR DATA NÃO AUTORIZADA,
    O ATACANTE PODE TAMBÉM DELETE DATA, UPDATE DATA,
    ETC....









-> É POR ISSO QUE É MT IMPORTANTE QUE VC 
    NUNCA _USE DATA __ PROVIDENCIADA PELOS USERS (como input)
    DIRETAMENTE NAS SUAS QUERIES...


    VC SEMPRE DEVE TER SERVERSIDE VALIDATION, 

    LÁ NOS CONTROLLERS, PARA IMPEDIR ESSE TIPO DE COISA..







--> E É AQUI, NO CASO, QUE 'PREPARED STATEMENTS' PODEM TE AJUDAR...











--> O METHOD DE 'PREPARE'


é chamado 

assim:







$db->prepare($query);








NO NOSSO CÓDIGO, FICA TIPO ASSIM:














            $email = $_GET["email"];

            $query = 'SELECT * FROM users WHERE email = " ' . $email . '"';

            $stmt = $db->prepare($query); // * This is safe - we should use prepared statements, with the 'prepare()' method, to avoid SQL injection.

  
            echo '<pre>';
            print_r($result);
            echo '</pre>';












O METHOD DE 'PREPARE()'


TAMBÉM FAZ O RETURN DE UM 'PDO OBJECT',



OBJECT EM QUE TEMOS O METHOD DE 'EXECUTE',

QUE PODE SER USADO 
PARA __ eXECUTAR _ A QUERY...






--> POR FIM, PODEMOS USAR AQUELE MESMO METHOD DE 'fetchAll()'


PARA LOOPAR POR TODOS OS ROWS DOS RESULTS...












fica tipo assim:










          $email = $_GET["email"];

            $query = 'SELECT * FROM users WHERE email = " ' . $email . '"';

            // $query = 'SELECT * FROM users';

            // $stmt = $db->query($query); // ! This is not safe - we should use prepared statements, with the 'prepare()' method, to avoid SQL injection.

            $stmt = $db->prepare($query); // * This is safe - we should use prepared statements, with the 'prepare()' method, to avoid SQL injection.

            $stmt->execute(); // this is needed, when using 'prepare()'.

            $result = $stmt->fetchAll(PDO::FETCH_ASSOC); // 'fetchAll' - method that is used to fetch all the results from the query.

            echo '<pre>';
            print_r($result);
            echo '</pre>';








MAS MESMO USANDO 



'prepare()',


ainda temos o mesmo result,


com o SQL INJECTION ainda funcionando.... ainda estamos vulneráveis...














-> O PROBLEMA, AQUI, É QUE 
PREPARE() STATEMENTS, POR SI MESMOS,
NÃO 

VÃO CONSEGUIR TE PROTEGER DE SQL INJECTION...


















--> PRECISAMOS FAZER SANITIZE DO INPUT DO USER...







--> PARA ISSO, PRECISAMOS USAR OU:




1) PLACEHOLDERS 




2) NAMED PARAMETERS  








na nossa query....








---> PARA USAR PLACEHOLDERS,


PODEMOS SIMPLESMENTE ESCREVER ASSIM:




            $query = 'SELECT * FROM users WHERE email = ?';
















O '?' INDICA O PLACEHOLDER...










---> AÍ, DENTRO DO 'execute()',

    DEVEMOS PASSAR 1 ARRAY DE VALUES, EM ORDEM,

    QUE SERÃO INSERIDOS 

    NOS PLACEHOLDERS...








tipo assim:











            $email = $_GET["email"];

            $query = 'SELECT * FROM users WHERE email = ?';

            $stmt = $db->prepare($query); // * This is safer - but it won't be enough, you still need to sanitize the data and use placeholders/named parameters.

            $stmt->execute([$email]); // this is needed, when using 'prepare()' and placeholders ('?' symbols).

            $result = $stmt->fetchAll(PDO::FETCH_ASSOC); // 'fetchAll' - method that is used to fetch all the results from the query.

            echo '<pre>';
            print_r($result);
            echo '</pre>';














        RECARREGAMOS A PAGE...



        AGORA REALMENTE NÃO FICAMOS MAIS COM TODOS USERS...


        COM ISSO, CONSEGUIMOS IMPEDIR SQL INJECTION...











OK... MAS AGORA DIGAMOS QUE QUEREMOS 1 QUERY DE INSERT,
EM VEZ DE SELECT...













--> TIPO ASSIM:









$query = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (?, ?, ?, ?);'














ESCREVEMOS TIPO ASSIM:














            $insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (?, ?, ?, ?);';

            $stmt = $db->prepare($insertQuery);

            $stmt->execute([$email, 'Arthur', true, date('Y-m-d H:i:s', strtotime('07/11/2021 9:00PM'))]); // this is needed, when using 'prepare()' and placeholders ('?' symbols).

           








    --> É CLARO QUE NÃO PODEMOS MAIS USAR 'fetchAll()' COM ESSE STATEMENT,
        PQ AQUI ESTAMOS RODANDO 1 INSERT STATEMENT, E NÃO UM SELECT STATEMENT...





        -> É POR ISSO QUE O PROFESSOR EXECUTA '$db->query('SELECT * FROM users WHERE id = ' . $id)'










NÓS AINDA NÃO TEMOS ESSE VALUE DE '$id', 

MAS PODEMOS OBTÊ-LO COM 





ESTE METHOD:



'$db->lastInsertId();' -----------> ESSE METHOD RETORNA O ID DO 'LAST INSERTED ROW'... o que vai nos dar o id do last inserted user...











FICA TIPO ASSIM:










        $stmt = $db->prepare($insertQuery);

            $stmt->execute([$email, 'Arthur', true, date('Y-m-d H:i:s', strtotime('07/11/2021 9:00PM'))]); // this is needed, when using 'prepare()' and placeholders ('?' symbols).

            $id = $db->lastInsertId();

            $user = $db->query('SELECT * FROM users WHERE id = ' . $id);

            echo '<pre>';
            var_dump($user);
            echo '</pre>';


















OK... COM ISSO, 


O USER ACABA CRIADO,


E FICAMOS COM ELE SELECIONADO, POR CONTA DO SEGUNDO STATEMENT...













--> USAR PLACEHOLDERS É FINE, SIM...








--> MAS QUANDO VC TEM __MUUUUITOS PLACEHOLDERS__,

    PODE FICAR DIFÍCIL DE ENTENDER 'WHICH VALUE GOES IN WHAT PLACEHOLDER''...





    --> E SE ERRARMOS A ORDEM, FICAREMOS COM PROBLEMAS (pq as coisas serão inseridas 
    nos lugares errados)








--> ALTERNATIVAMENTE, EM VEZ DE USAR PLACEHOLDERS (em que a ORDEM importa),

    VC PODERIA/DEVE USAR 'NAMED PARAMETERS'...









---> COM NAMED PARAMETERS, A ORDEM NÃO IMPORTA...











--> PARA USAR POSITIONAL PARAMETERS,


    DEVEMOS ESCREVER ASSIM (com ':'):








$insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (:email, :name, :active, :date);';













CERTO... COM ISSO, DENTRO DO 'execute()',


DEVEMOS PASSAR 1 ASSOCIATIVE ARRAY, TIPO ASSIM:









         // ? This is using named parameters (:name placeholders):
            $insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (:email, :full_name, :is_active, :date);';

            $stmt = $db->prepare($insertQuery);

            // ? This is using ordered parameters (normal placeholders, like '?'), and not named parameters.
            // $stmt->execute([$email, 'Arthur', true, date('Y-m-d H:i:s', strtotime('07/11/2021 9:00PM'))]); // this is needed, when using 'prepare()' and placeholders ('?' symbols).

            // ? This is using named parameters (:name placeholders), and not ordered parameters:
            $stmt->execute(['name' => $email, 'full_name' => 'Arthur', 'is_active' => true, 'created_at' => date('Y-m-d H:i:s', strtotime('07/11/2021 9:00PM'))]);















CERTO... ESTE FORMATO:





            $stmt->execute([
                'name' => $email, 
                'full_name' => 'Arthur', 
                'is_active' => true, 
                'created_at' => date('Y-m-d H:i:s', strtotime('07/11/2021 9:00PM'))
                
                ]);









E ISSO VAI FUNCIONAR...






a outra forma de passar named parameters, além 

de essa forma, diretamente no 'execute',



É __ USAR _ 'BIND',  para bindar values aos arguments..





--> usamos 'bindValue('nomeDoParametro', valueDoParametro, )





--> o terceiro parametro é O DATA TYPE do parameter... por default, é 'PDO::PARAM_STR', que indica que é um string data type...


TIPO ASSIM:






         // ? This is using named parameters (:name placeholders):
            $insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (:email, :full_name, :is_active, :date);';

            $stmt = $db->prepare($insertQuery);

            $stmt->bindValue('name', $name);
            $stmt->bindValue('email', $email);
            $stmt->bindValue('active', $isActive, PDO::PARAM_BOOL);
            $stmt->bindValue('date', $createdAt);

         
            $stmt->execute();



















CERTO... E ISSO FUNCIONA...






 
ALÉM DE PODER ESPECIFICAR OS DATA TYPES ASSIM,



OUTRA _ VANTAGEM DO USO DE 

'bindValue'
 

 e 

 'bindParam' 



É



''''IF YOU WERE WORKING WITH LOOPS 
    AND YOU WERE PREPARING A STATEMENT BEFORE THE 
    LOOP AND YOU __HAD __ FEW__ PARAMETERS THAT 
    WERE THE SAME, AND YOU DIDN'T NEED TO BIND THEM 
    EVERYTIME WITHIN THE LOOP, YOU COULD BIND THEM OUTSIDE 
    OF THE LOOP, AND THEN BIND ADDITIONAL PARAMETERS, FROM WITHIN 
    THE LOOP, and then execute that statement multiple times, from within the loop...''






 










 OK...





 OUTRO METHOD QUE O PROFESSOR HAVIA MENCIONADO É 



 'bindParam'...












-> A DIFERENÇA DE 'bindValue' 

para 

'bindParam'


é que



o 'bindParam' 


''BINDS BY REFERENCE''...










--> isso quer dizer que, se vc ALTERA O VALUE DE ALGUMA DAS VARIABLES,
    DURANTE A EXECUTION,

    ISSO VAI SER REFLETIDO NO param que vc passou a esse method...





EX:


            $isActive = 1;


            $stmt->bindParam('active', $isActive, PDO::PARAM_BOOL); // will set '1' as value 


            $isActive = 0; // changes the original variable value, BUT THE ARGUMENT PASSED TO 'bindParam' GETS CHANGED AS WELL... (referential value)


            $stmt->execute(); // Executes the statement, considering 'isActive' as 0, not 1.
















OUTRA DIFERENÇA É QUE, POR SER 'BY REFERENCE',
VC 

NÃO PODE FAZER HARDCODE DE VALUES, DENTRO DE 'bindParam'...



QUER DIZER QUE ISTO É PROIBIDO:




  $stmt->bindParam('active', true, PDO::PARAM_BOOL);















  CERTO...







  ESSA É, PORTANTO, A DIFERENÇA ENTRE BINDPARAM E BINDVALUE...








--> VC TAMBÉM PODE USAR 'bindParam' e 'bindValue'



COM PLACEHOLDERS...






-> se vc quer usar com placeholders,

vc CONSIDERARIA OS INDEXES DOS PLACEHOLDERS,


TIPO ASSIM:



            $insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (?, ?, ?, ?);';

            $stmt = $db->prepare($insertQuery);

            $stmt->bindValue(2, $name);
            $stmt->bindValue(1, $email);
            $stmt->bindValue(3, $isActive, PDO::PARAM_BOOL);
            $stmt->bindValue(4, $createdAt);

         
            $stmt->execute();
















CERTO...






E ISSO FUNCIONA...












-> VC TAMBÉM DEVE SABER QUE, 
    DENTRO DE 'bindParam' e 'bindValue',



OS PARAM 

NAMES 




DEVEM SER PREFIXADOS COM ':'...









TIPO ASSIM:






         // ? This is using named parameters (:name placeholders):
            $insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at) VALUES (:email, :full_name, :is_active, :date);';

            $stmt = $db->prepare($insertQuery);

            $stmt->bindValue(':name', $name);
            $stmt->bindValue(':email', $email);
            $stmt->bindValue(':active', $isActive, PDO::PARAM_BOOL);
            $stmt->bindValue(':date', $createdAt);

         
            $stmt->execute();
















UÉ, MAS ANTES NÓS NÃO TÍNHAMOS PREFIXADO...







PQ ISSO FUNCIONA?







-> É PQ A EXTENSION DE 'PDO' 

VAI ADICIONAR O ':' automaticamente,

se ele estiver missing...









--> MAS VC NÃO DEVE CONFIAR NISSO,
    PQ OS DOCS NÃO FALAM QUE 

    ':' SÃO OPCIONAIS...






    MAS O PROFESSOR ACHA QUE É OPTIONAL, PQ 

    ELE CHECOU O SOURCE CODE,



    E O SOURCE CODE ADICIONA ':' sempre que 


    ELES ESTÃO MISSING...












-> MT CONTEÚDO NESSA AULA,
   MAS TAKE YOUR TIME...









--> AGORA DEVEMOS VER O PRÓXIMO TÓPICO,
    QUE É 'EMULATED PREPARES'...














EMULATED PREPARES:












-- ''YOU CANNOT  USE THE SAME PARAMETER NAME MULTIPLE TIMES 
    IN PREPARE STATEMENTS'''..








POR EXEMPLO, DIGAMOS QUE TEMOS OUTRO CAMPO DE DATE, 'updated_at',


E AÍ QUEREMOS USAR O MESMO VALUE DE ':date',

TIPO ASSIM:




         // ? This is using named parameters (:name placeholders):
            $insertQuery = 'INSERT INTO users (email, full_name, is_active, created_at, updated_at) VALUES (:email, :full_name, :is_active, :created_at, :date, :date);';

            $stmt = $db->prepare($insertQuery);

            $stmt->bindValue('name', $name);
            $stmt->bindValue('email', $email);
            $stmt->bindValue('active', $isActive, PDO::PARAM_BOOL);
            $stmt->bindValue('date', $createdAt);

         
            $stmt->execute();

















-> QUEREMOS USAR O MESMO VALUE DE ':date' com 
'created_at'


e 
'updated_at'...












--> E ISSO VAI FUNCIONAR, ESTRANHAMENTE..






''YOU ARE NOT ALLOWED TO USE THE SAME PARAMETER MULTIPLE TIMES''




E ISSO É VERDADE... MAS O ___ PDO __ MYSQL DRIVER USA 

                    'EMULATED PREPARES' POR DEFAULT...





                    MAS ISSO PODE SER DISABLED POR 
                    MEIO DA OPTION DE 

                   'ATTR_EMULATE_PREPARES'





PERCEBA QUE 



''PDO WILL ALSO EMULATE 
    PREPARED STATEMENTS AND BOUND PARAMETERS 
    FOR SOME DRIVERS THAT DO NOT NATIVELY SUPPORT THEM''....





E, JUSTAMENTE PELOS PREPARES SEREM 'EMULATED',

VC CONSEGUE 'GET AWAY'

FAZENDO COISAS COMO ESSA... (com o uso repetido de ':date', nesse caso)...







-> MAS SE DESABILITAMOS O 'ATTR_EMULATE_PREPARES',


TIPO ASSIM:





    try {
            $db = new PDO(
                'mysql:host=db;dbname=MY_DB', // DSN (data source name) - composed of host (localhost) and database name (MY_DB)
                'root', // username
                'root', // password
                [PDO::ATTR_EMULATE_PREPARES=false]
            );












        

        FICAMOS COM 1 ERROR...









--> PARA CONSERTAR ISSO,

    USARÍAMOS OUTRAS KEYS PARA 

    ESSES SLOTS,

    COMO 


    ':date1'

    e 

    ':date2',

    ou algo assim...





coisa simples..












OUTRO DETALHE:










''NOTICE THAT 'id' field is coming back as a INT value...

before, it was coming back as a STRING...''











--> é pq QUANDO DESABILITAMOS OS EMULATED PREPARES,
    A DATA VEM COMO 'INT', e não 

    como 'string'...







    --> COM EMULATED PREPARES 
        __ DESABILITADOS E 

        USANDO 'NATIVE PREPARED STATEMENTS',

        VC 

        FICA 


        COM ALGUMAS VANTAGENS,

        ALÉM DE 1 PEQUENO PERFORMANCE BOOST...



        (INT E FLOAT SERÃO RETORNADOS COMO INTS E FLOATS, E NÃO COMO STRINGS...
        
        E VC TAMBÉM SERÁ CAPAZ DE USAR PLACEHOLDERS EM OUTROS CLAUSE STATEMENTS 
        COMO 
        'LIMIT'... JÁ COM EMULATED PREPARES, VC NÃO PODERÁ USAR...
        )








NO PRÓXIMO VIDEO,

VEREMOS COISAS COMO TRANSACTIONS COM PDO,

ASSIM COMO 'HOW WE CAN USE THE .env files to get the database credentials''...





TAMBÉM VEREMOS COMO PODEMOS 


EXTRACT E REFACTOR OS CALLS DE 'PDO',


TUDO PARA QUE ESSA LÓGICA DE DATABASE NÃO FIQUE DENTRO DOS CONTROLLERS...









--> VAMOS COLOCAR ESSA LÓGICA TODA, DE DATABASE, DENTRO DOS NOSSOS MODELS...

