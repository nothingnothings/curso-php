
 








 AGORA FALAREMOS SOBRE O MVC PATTERN...











 -> O PROFESSOR QUERIA MOSTRAR NA TERCEIRA PARTE DO CURSO,
    MAS É NECESSÁRIO FALAR SOBRE ISSO AGORA...












MVC -> MODEL VIEW CONTROLLER










-> É UM MODELO QUE SERVE PARA 


SEPARAR 




''THE DATA AND BUSINESS LOGIC''


EM RELAÇÃO AO 


''PRESENTATION LAYER''...











-> PARA ISSO, DEVEMOS VER 1 EXEMPLO DE COMO 

UM REQUEST IRIA POR DENTRO DE 1 MVC PATTERN...















request --------> CONTROLLER 












--> O CONTROLLER É O 'MIDDLE GUY',

QUE FICA ENTRE O PRESENTATION LAYER (as viewS)

E OS MODELS___ ...







--> É __ O TRABALHO DO CONTROLLER 
LIDAR COM REQUESTS, RESPONSES, HANDLAR RESOURCES, ETC...











--> O TRABALHO DO MODEL É HANDLAR A BUSINESS LOGIC 
    DO APP... 



    --> ELE MANAGEIA A DATA DO APP... PODE PROCESSAR 
        E ARMAZENAR A DATA... ->  A DATA PODE SER ARMAZENADA 
                                    EM 1 DATABASE OU 
                                    QUALQUER OUTRO 
                                    DATA STORAGE SYSTEM...




--> O MODEL É ALL ABOUT A BUSINESS LOGIC, DATA E DATA MANAGEMENT DE SEU APP...





--> O MODEL VAI 'TAKE IN' A INFO DO CONTROLLER,
    AÍ TALVEZ PASSÁ-LA A ALGUM DATA STORE, COMO 
    UMA DATABASE, 

    AÍ TALVEZ RETRIEVE ALGUMA DATA, DO DATA STORE,

    E AÍ 


    VAI REPASSAR ESSA DATA AO CONTROLLER...









--> QUER DIZER QUE O CONTROLLER E O MODEL SE COMUNICAM DESSA FORMA...






--> POR FIM, O CONTROLLER PASSA A INFO à VIEW,

    QUE ENTÃO RENDERIZA A INFO 


    DE FORMA SIMPLES À SCREEN/BROWSER/CLIENT...









--> NA MAIOR PARTE DOS CASOS,
    VIEWS SÃO APENAS PHP FILES QUE CONTÉM 
    HTML..


    --> MAS VIEWS TAMBÉM DEIXAM FÁCIL A UTILIZAÇÃO 
        DE TEMPLATING ENGINES,


        COMO 'TWIG' E 'BLADE'...

 







O DIAGRAMA DO MVC PODE SER REPRESENTADO DE DIFERENTES MANEIRAS:










  I----------------- VIEW 
  I                    ^
  I                    I
  I                    I
  I                    I 
  V                    I
CLIENT ---------> CONTROLLER 
                    I   ^
                    I   I
                    I   I 
                    V   I 
                    MODEL   ---->  DATABASE 
                            <---- 











vc poderia escrever assim, também:





  I-----------------   VIEW 
  I                    I  ^
  I                    I  I
  I                    I  I
  I                    I  I 
  V                    V  I
CLIENT ---------> CONTROLLER 
      <----------   I   ^
                    I   I
                    I   I 
                    V   I 
                    MODEL   ---->  DATABASE 
                            <---- 
















--> NESSE DIAGRAMA, O CONTROLLER SE COMUNICA BACK AND FORTH COM O CLIENT..








--> MVC PODE SER EXPLICADO DE DIFERENTES MANEIRAS, 
    DEPENDENDO DE COMO VC O ENTENDE/EXPLICA...











--> É CLARO QUE VIEWS NÃO PRECISAM SER, OBRIGATORIAMENTE, APENAS 
O   HTML....








--> DIGAMOS QUE VC ESTÁ LIDANDO COM FRAMEWORKS COMO 'REACT' OU 'VUE'...








--> EM CASOS COMO ESSES, VC NÃO TEM ESSAS VIEW FILES... EM VEZ DISSO,
    VC TEM VIEW COMPONENTS (javascript files),

    O QUE QUER DIZER QUE ESSES VIEW COMPONENTS ATUAM + OU - COMO VIEWS,
    PQ ELES SE COMUNICAM COM OS CONTROLLERS...












--> OUTRO DIAGRAMA QUE PODE REPRESENTAR A MESMA COISA É UM DIAGRAMA 


COM 'ROUTER':








  I-----------------   VIEW 
  I                       ^
  I                       I
  I                       I
  I                       I 
  V                       I
CLIENT      ----------> CONTROLLER 
    I       ^            I   ^
    I       I            I   I
    I       I            I   I 
    I       I            V   I 
    I       I            MODEL   ---->  DATABASE 
    v       I                    <---- 
      ROUTER     







-> NESSE CASO,


QUANDO VC FAZ 1 REQUEST,

O REQUEST VAI PARA 1 ROUTER,

ELE NÃO EXECUTA 1 CONTROLLER DIRETAMENTE...









---> E ESSE É UM SERVER COMUM,


    PQ ''ELE VAI ATÉ O ROUTER,
         AÍ O ROUTER DETERMINA QUAL
        CONTROLLER DEVERÁ SER EXECUTADO''..










COMO VC PODE VER, 1 MESMA COISA 

PODE SER REPRESENTADA DE DIFERENTES MANEIRAS DIFERENTES...



NÃO IMPORTA QUAL MANEIRA VC ESCOLHE PARA REPRESENTAR, 
DESDE QUE VC COMPREENDA A ESTRUTURA BÁSICA DO MVC...
















-> TAMBÉM EXISTEM DIFERENTES IMPLEMENTAÇÕES DO MVC PATTERN...









-> NESSA IMPLEMENTAÇÃO ESPECÍFICA,
    O 


    'MODEL SE COMUNICA COM O CONTROLLER, E 
    O CONTROLLER SE COMUNICA COM A VIEW'..





    MAS TAMBÉM PODERIA SER IMPLEMENTADO DE 1 MANEIRA 

    EM QUE 



    ''''MODEL AND VIEW COMMUNICATE WITH EACH OTHER DIRECTLY,
        AND THE CONTROLLER DOESN'T COMMUNICATE WITH THE VIEW, AT ALL'...



    










NO CASO, O DIAGRAMA FICARIA ASSIM:








                

   
                       VIEW 
                       I  ^
                       I  I
                       I  I
                       I  I 
                       V  I
CLIENT ---------> CONTROLLER 
      <----------   I   ^
                    I   I
                    I   I 
                    V   I 
                    MODEL   ---->  DATABASE 
                            <---- 








NESSE MODELO, O MODEL SE 
                COMUNICA COM A VIEW,

                E SEMPRE QUE O STATE DO MODEL 
                MUDA,


                A VIEW É UPDATADA TAMBÉM...





                --> E VC PODE USAR O 'OBSERVER PATTERN'
                PARA FAZER ISSO, OU, ENTÃO, 

                SIMPLESMENTE ATUALIZAR A VIEW DIRETAMENTE...











--> SE COLOCARMOS AS 2 IMPLEMENTAÇÕES SIDE-BY-SIDE,
FICAMOS COM ISTO:





















CLIENT -> CONTROLLER -> MODEL -> CONTROLLER -> VIEW -> CLIENT 






E (MENOS USADO)





CLIENT -> CONTROLLER -> MODEL -> VIEW -> CLIENT
















--> MAS VC USARÁ 
    O DA DIREITA COM MAIOR FREQUÊNCIA 


    (em que ''model does not communicate with view,
            and CONTROLLER COMMUNICATES WITH THE VIEW...''
    )








--> É CLARO QUE VC NAO PRECISA IMPLEMENTAR O MVC 
    PATTERN INTEIRO 

    E ENTÃO 


    1 FRAMEWORK EM VOLTA DELE, 'FROM SCRATCH'...










--> HÁ VÁRIOS PHP FRAMEWORKS BONS,
    QUE PROVIDENCIAM UM ÓTIMO STARTING POINT,

    E UMA PLATFORM PARA CRIAR AWESOME PHP WEB-APPS..







EX:





YII FRAMEWORK 
ZEND FRAMEWORK 
LARAVEL 
CODEIGNITER 
CAKEPHP 
SYMFONY





--> UM MONTE DE ESSES FRAMEWORKS PROVIDENCIAM O PATTERN MVC,

    MAS A ACTUAL IMPLEMENTATION PODE MUDAR... MAS A IDEIA PRINCIPAL
    CONTINUA SENDO A MESMA...









--> É INJUSTO, POR EXEMPLO, DIZER QUE 'O LARAVEL É UM MVC FRAMEWORK'...









-> ISSO PQ O LARAVEL NÃO É 'JUST A MVC FRAMEWORK'...









-> NÃO... O LARAVEL IMPLEMENTA O MVC PATTERN 
    'IN ITS OWN WAY',


    MAS _ O LARAVEL É 'MUCH LARGER',

    E TEM MT MAIS FEATURES 

    E FUNCIONALIDADE DO QUE VC PODERIA FIT 

    EM 1 MVC PATTERN BÁSICO....












-->  APESAR DE INTRODUZIR 1 POUCO MAIS DE COMPLEXIDADE,
     O MVC 

     TE DÁ 1 ESTRUTURAÇÃO 

     MELHOR A SEU CÓDIGO,

     POR MEIO 

     DA DIVISÃO EM 3 LAYERS,

     'MODEL', 'VIEWS' E 'CONTROLLERS'...







--> CADA LAYER PODE SER, ENTÃO, DIVIDIDO AINDA MAIS,
    POR MEIO DE OUTROS PATTERNS, ALÉM DO MVC...







    ''DATABASE ABSTRACTION'' --> É UM EXEMPLO DE DIVISÃO DESSAS...











--> MAS AGORA CHEGA DE CONCEITOS E TEORIA...
    DEVEMOS MELHORAR NOSSO CÓDIGO,
    PARA QUE ELE IMPLEMENTE O MVC PATTERN... 








    IMPLEMENTAÇÃO BÁSICA DO MVC...













-> JÁ IMPLEMENTAMOS 1 FORMA BÁSICA DE MVC EM AULAS PASSADAS,
    POR MEIO DE 'ROUTES' E 'CLASSES'



    (ESSAS ROUTES E CLASSES ATUAM, BASICAMENTE, COMO CONTROLLERS,
    NESSE 
    NOSSO APP...)












--> CERTO...







--> O QUE PRECISAMOS FAZER, AQUI,
PRIMEIRAMENTE,


É 

RENOMEAR O FOLDER DE 'Classes' como 'Controllers'...












-> VC PODE NOMEAR SEUS CONTROLLERS DO JEITO QUE VC QUISER,

MAS O PROFESSOR GOSTA DE COLOCAR 'xxxxController',

no final de cada class que é um controller...








TIPO ASSIM:



HomeController.php 



InvoiceController.php
















E O CÓDIGO FICOU TIPO ASSIM:










<?php



declare(strict_types=1);


namespace App21;


require_once __DIR__ . "/../vendor/autoload.php"; // imports the composer's autoloader


session_start();

define('STORAGE_PATH', __DIR__ . '/../storage');

$router = new Router();


$router->get('/', [\App21\Controllers\HomeController::class, 'index'])
    ->post('/upload', [\App21\Controllers\HomeController::class, 'upload'])
    ->get('/invoices', [\App21\Controllers\InvoiceController::class, 'index'])
    ->get('/invoices/create', [\App21\Controllers\InvoiceController::class, 'create'])
    ->post('invoices/create', [\App21\Controllers\InvoiceController::class, 'store']);




echo $router->resolve($_SERVER['REQUEST_URI'], strtolower($_SERVER['REQUEST_METHOD']));




















LÁ NOS CONTROLLERS, FICAMOS TIPO ASSIM:





<?php

declare(strict_types=1);


namespace App21\Controllers;




class HomeController
{

    public function index()
    {


        $_SESSION['count'] = ($_SESSION['count'] ?? 0) + 1;


        return <<<HTML
        <form action="/upload" method="post" enctype="multipart/form-data">
            <label for="amount">File:</label>
            <input type="file" name="receipt">
            <button type="submit">upload</button>
        </form>
HTML;

    }


    public function upload(): void
    {
        echo '<pre>';
        echo var_dump($_FILES);   // Will dump an array with objects with the keys 'receipt', 'name', 'type', 'tmp_name', 'error', 'size'.
        echo '</pre>';


        var_dump(pathinfo($_FILES['receipt']['tmp_name'])); // get additional information about the file.

        $filePath = STORAGE_PATH . '/' . $_FILES['receipt']['name'];
        // Files that are uploaded with requests get stored temporarily in the 'tmp' folder, and get deleted after the request is finished.
        // That's why we need to move the file to a permanent location, either locally, or to the cloud (s3 storage, for example):



        move_uploaded_file($_FILES['receipt']['tmp_name'], $filePath);

        echo '';

        echo var_dump(pathinfo($filePath));

    }


}

















É CLARO QUE NÓS __NÃO VAMOS _ CRIAR 1 FULL-FLEDGED 
MVC FRAMEWORK 'FROM SCRATCH'...












O PROFESSOR SÓ QUER DEMONSTRAR COMO ISSO FUNCIONA, SEM USAR ISSO EM PRODUCTION...














--> BEM... AGORA, O QUE QUEREMOS FAZER É, EM VEZ DE RETORNAR 
    CÓDIGO HTML DIRETAMENTE DE NOSSOS CONTROLLERS, QUEREMOS RETORNAR 


    __vIEWS....





    --> PQ ATUALMENTE, ESTÁ ASSIM:







    public function index()
    {


        $_SESSION['count'] = ($_SESSION['count'] ?? 0) + 1;


        return <<<HTML
        <form action="/upload" method="post" enctype="multipart/form-data">
            <label for="amount">File:</label>
            <input type="file" name="receipt">
            <button type="submit">upload</button>
        </form>
HTML;

    }















PRIMEIRAMENTE, PRECISAMOS DE ALGUM LUGAR PARA 'STORE' NOSSAS VIEWS...










POR ISSO CRIAMOS UM NOVO DIRECTORY, CHAMADO DE 'views'...






ELE FICARÁ NO ROOT DE NOSSO APP...














--> PRECISAMOS DE 1 VIEW FILE PARA 

CADA 'ACTION' QUE VAI RENDERIZAR ALGO...









PRECISAMOS DE:



1) UMA VIEW PARA O INDEX METHOD DO 'HomeController'





2) OUTRA PARA O INDEX METHOD OD 'InvoiceController'..






3) OUTRA PARA O METHOD DE 'create' 

    no 'InvoiceController'...












--> PARA ISSO, FICAMOS COM 1 FOLDER DE 'views' com este layout:







views(folder)

    invoices(folder)
        create.php (file)
        index.php (file)
    
    index.php (file)    (DEVE SER USADO PARA O 'index()' method de 'HomeController')...


















AGORA VAMOS PEGAR O HTML DE NOSSAS CLASSES E COLOCAR NESSES 'VIEWS'....























A PRÓXIMA COISA QUE PRECISAMOS FAZER, AQUI, É RENDERIZAR 
ESSAS VIEWS, DE ALGUMA FORMA,

DE DENTRO DE NOSSOS CONTROLLERS...






---> VAMOS TER 1 CLASS DE 'View',
 
E AÍ VAMOS CRIAR 1 NOVO OBJECT DESSA CLASS DE 'View',

TIPO ASSIM:












class HomeController
{

    public function index()
    {


        return (new View())->render();

    }














BASICAMENTE, VAMOS CRIAR ESSE OBJECT, E AÍ IMEDIATAMENTE CHAMAMOS 

O METHOD DE 'render()',
nesse object,

PARA RENDERIZAR A VIEW...













--> DENTRO DO CONSTRUCTOR DE 'View',

    PRECISAMOS PASSAR ALGUM RELATIVE PATH À VIEW desejada...








talvez algo como 


''         return (new View('index'))->render();    ''













SE QUISÉSSEMOS O INDEX.PHP DE 'invoices',


ESCREVERÍAMOS ALGO ASSIm:



''         return (new View('invoices/index'))->render();    ''













OK... 








É POR ISSO QUE CRIAMOS ESSA CLASS, DENTRO DO NAMESPACE DE 'App'...








VAI FICANDO TIPO ASSIM:














<?php

declare(strict_types=1);


namespace App19\Classes;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }


}















FICAMOS COM OS ARGUMENTOS DE '$view' (a string de qual view pegar)


e 

'$params', que 

será usado para passar optional parameters 


a nosso method de 'render()'....












--> ADICIONAMOS ESSE METHOD DE 'render',


    PQ QUEREMOS RENDERIZAR 

    NOSSA VIEW FILE,


    NO FORMATO DE UMA STRING...











MAS COMO PODEMOS FAZER ISSO?














ISTO NÃO FUNCIONARÁ:











    public function render()
    {
        include $this->view;
    }








ESSE INCLUDE NÃO VAI FUNCIONAR, POR MÚLTIPLAS RAZÕES:









1a RAZAO --> ISSO, esse '$this->view', é um RELATIVE PATH, 
                                        NÃO O FULL PATH,
                                        O QUE QUER DIZER QUE 

                                        ELE NÃO VAI ENCONTRAR ESSA VIEW...




                                        E ISSO VAI RESULTAR EM 1 WARNING...










-> PARA CONSERTAR ESSE WARNING/ERRO,
        PODEMOS CRIAR 

        UMA CONSTANT PARA AS VIEWS,


        BASTA USAR A MESMA ESTRUTURA QUE UTILIZAMOS 

        LÁ em 'public/index.php',




        COM A CONSTANT DE 'STORAGE_PATH':












define('STORAGE_PATH', __DIR__ . '/../storage');









ESCREVEMOS ASSIM:





define('VIEW_PATH', __DIR__ . '/../views');















CERTO... COM ISSO, PODEMOS USAR ESSA CONSTANT DE 'VIEW_PATH'



lá com o include,
tipo assim:











<?php

declare(strict_types=1);


namespace App19\Classes;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }



    public function render()
    {
        // include $this->view;
        include VIEW_PATH . $this->view;
    }


}












MAS ISSO AINDA NOS DÁ 1 ERROR, PQ AINDA NÃO COLOCAMOS A EXTENSION PARA 
ESSA FILE,
TIPO ASSIM:












<?php

declare(strict_types=1);


namespace App19\Classes;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }



    public function render()
    {
        // include $this->view;
        include VIEW_PATH . $this->view . '.php';
    }


}














CERTO...






COM ESSA EXTENSION ADICIONADA, FINALMENTE CONSEGUIMOS RENDERIZAR NOSSA FILE...












EX:








<?php

declare(strict_types=1);


namespace App21;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }



    public function render()
    {
        // include $this->view;
        include VIEW_PATH . '/' . $this->view . '.php';
    }


}













certo... a form é renderizada, sim,




MAS FICAMOS COM UM OUTRO PROBLEMA:









''Fatal error: Uncaught TypeError - Return value must be of type string, NULL returned in HomeController'..












--> ISSO ACONTECEU PQ NOSSO HOMECONTROLLER 


ESTÁ ESPERANDO O RETURN DE UMA __ STRING,


MAS ESTAMOS RETORNANDO 

'null'...







--> ISSO ACONTECEU PQ NÃO ESTAMOS RETORNANDO COISA ALGUMA DO METHOD DE 'render()',
    E PRECISAMOS RETORNAR 1 STRING...








--> MAS COMO PODEMOS RETORNAR UMA STRING?






REVEJA O METHOD:





    public function render()
    {
        // include $this->view;
        include VIEW_PATH . '/' . $this->view . '.php';
    }











NÓS NÃO PODEMOS REALMENTE RETORNAR ISSO COMO 1 STRING...





N PODEMOS PQ ''WHEN YOU INCLUDE SOMETHING,
                IT WILL ACTUALLY _ EVALUATE_ THAT 
                PHP FILE _ AND RUN THAT SCRIPT''...







--> ISSO QUER DIZER QUE A PAGE É RENDERIZADA    
    NO EXATO MOMENTO/ASSIM QUE O STATEMENT DE 'include'

    É _ ALCANÇADO...



    -> E ISSO NÃO É IDEAL, EM MTOS CASES... 


    EX:


    '''WHAT IF WE WANTED TO EXECUTE SOME CODE AFTERWARDS??

        WHAT IF WE WANTED TO SEND SOME HEADERS,
        OR RUN SOME ADDITIONAL CODE BEFORE FINALLY 
        OUTPUTTING SOMETHING TO THE SCREEN???''


    





-> O OBJETIVO, AQUI,
    É _ RENDERIZAR ESSE 'include' COMO 

    1 STRING... E _ PODEMOS FAZER ISSO POR MEIO 
    
                    DO RECURSO DE 

                    'OUTPUT_BUFFERING'...




--> EM OUTRAS PALAVRAS, PODEMOS:



1) COMEÇAR O _ OUTPUT_BUFFERING _ ANTES__ DO 'INCLUDE' DA FILE...



2) FAZER O GET DO CONTENT DO INTERNAL BUFFER





3) RETORNAR O CONTENT DO 'INTERNAL BUFFER' 

    COMO 1 __ STRING_...







--> PARA FAZER ISSO,
    PODEMOS USAR 


    AS HELPER FUNCTIONS DO PHP...






--> PARA 'START THE OUTPUT_BUFFERING',
    PODEMOS 


    USAR A FUNCTION DE 'ob_start()'...







-> DEPOIS DISSO, RODAMOS O 'INCLUDE' do nosso arquivo php...








--> POR FIM, PODEMOS FAZER __ RETURN __ 


DO VALUE DE 'ob_get_clean()',



QUE 

VAI SIMPLESMENTE 

'''GET THE CONTENTS OF THE INTERNAL BUFFER,
    AND THEN CLEANS IT UP, AFTERWARDS'''....











    FICA TIPO ASSIM:











<?php

declare(strict_types=1);


namespace App21;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }



    public function render()
    {
        // include $this->view; // This won't work, because the view is not in the same folder as the controller, and because of the lack of output buffering.

        ob_start(); // This will start the output buffering.

        include VIEW_PATH . '/' . $this->view . '.php'; // This will include the view file's content.

        return ob_get_clean(); // This will return the content of the output buffer, correctly.
    }


}























agora, se refreshamos a página,


O ERRO DESAPARECE, E A VIEW É RENDERIZADA ADEQUADAMENTE...













--> É CLARO QUE HÁ MAIS ALGUMAS COISAS QUE PODEMOS TWEAKAR, AQUI...










'''WHAT IF THIS VIEW DOESN'T EXIST???''




--> É POR ISSO QUE PRECISAMOS FAZER O HANDLE ADEQUADAMENTE COM IF-ELSE...




EX:






<?php

declare(strict_types=1);


namespace App21;

use App21\Exceptions\ViewNotFoundException;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }



    public function render()
    {
        // include $this->view; // This won't work, because the view is not in the same folder as the controller, and because of the lack of output buffering.

        $viewPath = VIEW_PATH . '/' . $this->view . '.php';

        if (!file_exists($viewPath)) {
            throw new ViewNotFoundException();
        }

        ob_start(); // This will start the output buffering.

        include $viewPath;  // This will include the view file's content.

        return ob_get_clean(); // This will return the content of the output buffer, correctly.
    }


}














CERTO.... E 


ESSA 'ViewNotFoundException' ficou assim:







<?php

declare(strict_types=1);


namespace App21\Exceptions;

class ViewNotFoundException extends \Exception
{
    protected $message = 'View not found';

}









CERTO...





COLOCAMOS O RETURN TYPE ADEQUADO, TIPO ASSIM:






    public function render(): bool|string
    {
        // include $this->view; // This won't work, because the view is not in the same folder as the controller, and because of the lack of output buffering.

        $viewPath = VIEW_PATH . '/' . $this->view . '.php';

        if (!file_exists($viewPath)) {
            throw new ViewNotFoundException();
        }

        ob_start(); // This will start the output buffering.

        include $viewPath;  // This will include the view file's content.

        return ob_get_clean(); // This will return the content of the output buffer, correctly.
    }
















--> LÁ NA PARTE INFERIOR,


COLOCAMOS O CAST COMO '(string)',


para que isso SEMPRE RETORNE UMA STRING,
STRICTLY...













<?php

declare(strict_types=1);


namespace App21;

use App21\Exceptions\ViewNotFoundException;


class View
{

    public function __construct(protected string $view, public array $params = [])
    {


    }



    public function render(): bool|string
    {
        // include $this->view; // This won't work, because the view is not in the same folder as the controller, and because of the lack of output buffering.

        $viewPath = VIEW_PATH . '/' . $this->view . '.php';

        if (!file_exists($viewPath)) {
            throw new ViewNotFoundException();
        }

        ob_start(); // This will start the output buffering.

        include $viewPath;  // This will include the view file's content.

        return (string) ob_get_clean(); // This will return the content of the output buffer, correctly.
    }


}













CERTO...









TUDO CONTINUA FUNCIONANDO...








NA PAGE DE INVOICES,


NADA ACABA RENDERIZADO...








-> ISSO ACONTECEU PQ AINDA NAÕ ATUALIZAMOS 

A PARTE DE 'InvoiceController'....
















--> EM 'HomeController',

o professor 



aponta que ELE NÃO GOSTA MT DESSA SINTAXE:





    public function index()
    {


        return (new \App21\View('index'))->render();

    }









--> ELE NÃO GOSTA 

DO 'new()'


COM OS PARENTESES AO REDOR 

E O CALL DIRETO DE 'render()'

neses object...






-> O PROFESSOR ACHA QUE O USO DE UM METHOD ESTÁTICO 
SERIA BEM MAIS CLEAN,


TIPO ASSIM:




    public function index()
    {


        return View::make('index');
    }









e assim (View.php):






    public static function make(string $view, array $params = []): static
    {
        return new static($view, $params);
    } 
















DEPOIS, ESCREVEMOS ASSIM:




class HomeController
{

    public function index(): View
    {

        return View::make('index');
    }
















CERTO... AGORA COPIAMOS ISSO E COLAMOS NO CONTROLLER DE 

'InvoiceController':













<?php

declare(strict_types=1);


namespace App21\Controllers;

use App21\View;


class InvoiceController
{

    public function index(): View
    {

        return View::make('invoices/index');
    }

    public function create(): View
    {
        return View::make('invoices/create');
    }

    public function store(): void
    {
        $amount = $_POST['amount'];

        var_dump($amount);
    }
}

















OK... ISSO VAI CRIAR VIEWS PARA CADA TIPO DE VIEW...





TUDO POR MEIO DESSE STATIC METHOD...
















CERTO, MAS É CLARO QUE HÁ VÁRIAS COISAS QUE ESTÃO FALTANDO, NESSA 

IMPLEMENTAÇÃO ATUAL DAS VIEWS....














1o Problema --> NÓS AINDA NÃO TEMOS 'PROPER SUPPORT' para 
                o pass de parameters, nesses calls de '::make'...




                --> NÓS ESTAMOS FAZENDO ACCEPT DESSE PARAMETER DE '$params'
                no constructor de 'View',
                MAS NÃO ESTAMOS FAZENDO COISA ALGUMA COM ELES...






                --> OUTRO PROBLEMA QUE TEMOS, AQUI,


                É QUE NÃO TEMOS NENHUM TIPO DE 

                'LAYOUT SUPPORT'...





                POR EXEMPLO,

                ESTAMOS RENDERIZANDO UM ARQUIVO 'VIEW' 
                DIRETAMENTE...




                --> isso quer dizer que SE VC QUER 
                    RENDERIZAR UMA 'FULL HTML PAGE',

                    VC É FORÇADO 




                    A COLOCAR O HTML INTEIRO DENTRO DE 


                    'views/index.php'...


                





                --> VC SERIA FORÇADO A DUPLICAR 1 MONTE DE CÓDIGO,
                    CADA FILE 

                    TERIA QUASE 1 HTML EXATAMENTE IGUAL...








                    -> O CÓDIGO É DUPLICADO 1 MONTE, A ÚNICA PARTE 
                    QUE REALMENTE MUDA, ENTRE PAGES,

                    É O BODY...





                --> E HÁ DIFERENTES MANEIRAS DE IMPLEMENTAR SUPORTE 
                A LAYOUTS...






                --> NÓS NÃO VAMOS IMPLEMENTAR ISSO NESSA AULA,
                MAS O PROFESSOR VAI DAR ALGUNS HINTS,

                PARA IMPLEMENTARMOS NÓS MESMOS...











                ''ONE WAY YOU COULD DO THAT 
                IS BY EXTRACTING THE WHOLE 
                CODE INTO SOMETHING LIKE A 'Layout.php'
                view file, and then, in the body,


                YOU COULD PLACE SOME SORT OF PLACEHOLDER,

                LIKE 

                '{{content}}',




LIKE THIS:














<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    … {{ content}}
</body>

</html>










TIPO ASSIM...











AÍ, DE DENTRO DA CLASS DE 'View',

VC PODERIA COLOCAR ALGUNS OPTIONAL PARAMETERS EM 'render()",


TIPO ASSIM:






    public function render(bool $withLayout = false): bool|string
    {

        $viewPath = VIEW_PATH . '/' . $this->view . '.php';

        if (!file_exists($viewPath)) {
            throw new ViewNotFoundException();
        }

        ob_start(); 

        include $viewPath;  

        return (string) ob_get_clean(); 
    }













-> AÍ, SE ESSE 'withLayout'

FICASSE SETTADO COMO 'TRUE',




VC RENDERIZARIA 1 LAYOUT DA MESMA FORMA 




QUE RENDERIZAMOS 1 VIEW 
AQUI,


MAS EM OUTRA VARIABLE,


PARA 


AÍ 




FAZER O 'FIND AND REPLACE'

DAQUELE 

'{{content}}' 




COM O CONTENT 



DE 

'return (string) ob_get_clean()'...














COM ISSO, VC FICA CAPAZ DE 'RENDER THE FULL PAGE, WITH THE LAYOUT',


ou, então, renderizar APENAS 1 SIMPLES VIEW FILE,

SEM NENHUM LAYOUT...








-> SE VC QUER DEIXAR AINDA MAIS CUSTOMIZÁVEL E PEGAR DIFERENTES 
    LAYOUTS,


    VC PODE, EM VEZ DE PASSAR 1 'BOOLEAN',

    PASSAR 1 

    'LAYOUT VIEW FILE'...  e, por default,

                                VC DEIXARIA ESSA 'layout view file'

                                como 1 empty string... e se estiver 
                                settada 


                                como empty string,
                                 
                                 VC NÃO USA QUALQUER LAYOUT...




-> ''AND IF YOU ARE PASSING IN A VALID LAYOUT AND THE LAYOUT FILE 
    EXISTS, YOU WOULD RENDER THAT IN A STRING, AND DO THE SAME THING 
    MENTIONED BEFORE''...




















--> OK... AGORA DEVEMOS PASSAR ALGUNS PARAMETERS, LÁ DOS CONTROLLERS,

    PARA NOSSAS VIEWS,

     E ENTÃO ACESSAR ESSES PARAMETERS, DENTRO DE NOSSAS VIEW FILES...











    --> PARA ISSO, 


    PODEMOS COMEÇAR ASSIM, no 'HOME CONTROLLER':

















    public function index(): View
    {



        return View::make('index', []);
    }












COM ISSO, PASSAMOS DATA, UM ASSOCIATIVE ARRAY,

COMO SEGUNDO PARAMETER DE '::make()'...










-> TIPO ASSIM:



     public function index(): View
    {


        // return (new \App21\View('index'))->render();

        return View::make('index', ['foo' => 'bar']);
    }














CERTO...











AGORA, SE VAMOS ATÉ O 'index.php'



de 'views/index.php',










DIGAMOS QUE QUEREMOS FAZER PRINT DA VARIABLE DE 'foo',

dentro 

do html...




TIPO ASSIM:












<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1></h1>
    <!-- … {{ content}} -->
</body>

</html>











--> QUEREMOS PRINTAR ALGO DENTRO DE 'h1'...













--> UMA MANEIRA PELA QUAL PODEMOS FAZER ISSO,

    

    ''AS THE PARAMETERS ARE CONTAINED WITHIN THE $params property 
    and we are simply INCLUDING the view with 'include $viewPath',

    THIS MEANS THAT THE VIEW FILE __ HAS ACCESS TO THE 
    '$this' variable, WHICH HAS ACCESS TO THE '$params' property...''









--> ISSO QUER DIZER QUE PODERÍAMOS FAZER 1 ECHO COMO ESTE AQUI, NO HTML DO .php mesmo:






<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1><?= $this->params['foo'] ?></h1>
    <!-- … {{ content}} -->
</body>

</html>















e isso realmente funcionará...







MAS É CLARO QUE ISSO PODE __ NÃO SER IDEAL___...







PODE NÃO SER IDEAL 

PQ 


VC 

PODE NÃO  



QUERER__ 'LOOK INTO THE params array DIRECTLY'...















-> O PROFESSOR RESSALTA QUE _ HÁ MTAS DIFERENTES FORMAS 
    DE IMPLEMENTAR ESSE OUTPUT AÍ...








--> MAS ELE VAI NOS MOSTRAR ALGUMAS DESSAS MANEIRAS...










-> ESSA É A PRIMEIRA MANEIRA, MAS NÃO É IDEAL..

















2a MANEIRA --> 


    ''AS WE ARE STORING THE PARAMETERS IN a '$params' array 
        AND WE WANT __ TO ACCESS ELEMENTS THAT ARE STORED WITHIN 
        THAT ARRAY, WE COULD ACTUALLY USE the 

        '__get()' MAGIC METHOD TO EXTRACT THE DATA FROM THE PARAMS ARRAY...''


    








PARA ISSO, ESCREVERÍAMOS TIPO ASSIM, LÁ EM 'View.php':









 

    // Used to output params in the view (for layouting):
    public function __get(string $name): mixed
    {
        return $this->params[$name] ?? null;
    }










COM ISSO, SERÁ RETORNADO 1 VALUE DO ARRAY DE '$params',


SE ESSE VALUE EXISTIR... CASO CONTRÁRIO,

FICAREMOS 


COM 'null'....










--> PARA CONSEGUIRMOS ATIVAR ESSE GETTER METHOD, LÁ NO HTML DO PHP,


BASTA ESCREVER ASSIM:






<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1> 
        <?= $this->foo ?> <!-- ALSO NOT IDEAL -->
    </h1>
    <!-- … {{ content}} -->
</body>

</html>











ou seja,


'$this->foo'...










-> MAS O PROFESSOR APONTA QUE __ iSSO TAMBÉM NÃO É IDEAL...













''WE DON'T WANT TO BE ACCESSING DATA, USING THE '$this' variable''...









--> O QUE QUEREMOS, É FAZER ALGO COMO ISTO:






<?= $foo ?>







--> MAS ESSA VARIABLE, ATUALMENTE, NÃO EXISTE...

 






--> ELA PRECISA SER DEFINIDA... 





--> MESMO COM ELA DEFINIDA, NO SEU CÓDIGO,
    SEU IDE AINDA 

    VAI MARCAR 

    ESSE TIPO DE VARIABLE COMO 'UNDEFINED'...




    (no phpstorm é assim, por exemplo)...







--> LÁ NA CLASS DE 'View',



O PROFESSOR EXPLICA QUE 



UMA MANEIRA POSSÍVEL DE DEIXAR ESSA VARIABLE COMO DEFINED 








É SIMPLESMENTE:




1) 'loop through each variable, inside of the '$params' property ' 



2) THEN, use VARIABLE VARIABLES, for this...









TIPO ASSIM:





    public function render(): bool|string
    {
     

        $viewPath = VIEW_PATH . '/' . $this->view . '.php';

        if (!file_exists($viewPath)) {
            throw new ViewNotFoundException();
        }


        foreach($this->params as $key => $value) {
            $$key = $value; // VARIABLE VARIABLES
        }

        ob_start(); 

        include $viewPath;  

        return (string) ob_get_clean();
    }














O QUE ISSO FAZ,
NO CASO,

É 


criar 1 variable de nome 
'$foo',

com aquele value '$value'...







SERÁ CRIADA 1 VARIABLE (com '$')

para cada 



KEY DENTRO DO ARRAY DE 'params'...










OK... SE RECARREGAMOS A PÁGINA, TUDO DÁ CERTO...













alternativamente,


vc poderia usar a function de 'extract()',


QUE FARIA A MESMA COISA,

E AS COISAS AINDA FUNCIONARIAM...












TIPO ASSIM:





    public function render(): bool|string
    {
     

        $viewPath = VIEW_PATH . '/' . $this->view . '.php';

        if (!file_exists($viewPath)) {
            throw new ViewNotFoundException();
        }


        extract($this->params);

        ob_start(); 

        include $viewPath;  

        return (string) ob_get_clean();
    }

















CERTO... MAS VC DEVE TER MT CUIDADO COM ESSES 2 APPROACHES,


O 


DE 

'VARIABLE VARIABLES'



E 


O 


DE 'extract()'..









-> ISSO PQ, SE VC PASSA ALGUMA 'USER-PROVIDED DATA',


    ESSES METHODS AÍ __ PODEM SER__ SUPER EXPLOITADOS...







--> NO NOSSO CASO, 'params' 
    estão safe PQ 

    ELAS NÃO SÃO USER-PROVIDED,

    E SABEMOS EXATAMENTE O QUE ELAS SERÃO,



    PQ ESPECIFICAMOS ELAS ANTES
     

     (aquele params value de '['foo' => 'bar' ])










--> MAS SE PASSAMOS ALGO COMO 



'return View::make('index', $_GET);',







ISSO SERÁ UM GRANDE PROBLEMA PARA NÓS,

PQ 



O USER PODERÁ INSERIR COISAS MALICIOSAS 

NA QUERY_STRING,

na url...









--> E ISSO PODE EXPLOITAR SEU APP....










--> O PROFESSOR MOSTRA 1 SIMPLES EXEMPLO...








-> BASTA COLOCAR 'localhost:8000/?viewPath=/',



LÁ NA URL,


PARA QUEBRAR TODO NOSSO APP...





ISSO ACONTECE, NO CASO,

POR CONTA DE 'extract()'...










--> É POR ISSO QUE VC DEVE TER MT  CUIDADO QUANDO USA 'VARIABLE VARIABLES'

            e 'EXTRACT()'...









-> por isso que ''YOU SHOULD NOT PASS ANY USER INFORMATION, WHEN USING 
                    VARIABLE VARIABLES OR 'EXTRACT()'...''












OK... AGORA QUE TEMOS VIEWS E CONTROLLERS FUNCIONANDO,

A ÚLTIMA PARTE É O IMPLEMENT DOS __ MODELS...













MODELS --> PODEM USAR DATABASES
            OU QUALQUER OUTRA DATA STRUCTURE/STORE..






--> NÃO VAMOS COBRIR MODELS NESSA LESSON,
    PQ AINDA NÃO COBRIMOS DATABASES E PDO...









--> FAREMOS ISSO NAS PRÓXIMAS LESSONS...








-> MAS, BASICAMENTE, DENTRO DO METHOD DE 'store()',

    DENTRO DO CONTROLLER DE 'InvoiceController',



    PODERÍAMOS TER 1 CÓDIGO COMO  ESTE:











    public function store(): void
    {
        $invoice = new Invoice();

        $amount = $_POST['amount'];

        var_dump($amount);
    }











    --> AÍ, DEPOIS DE OBTERMOS 

    A DATA DO REQUEST (QUE É O TRABALHO DO CONTROLLER)

    E PROCESSARMOS ESSA DATA (PREPARÁ-LA PARA USO),


    COMO 'DO VALIDATION...


    PODEMOS SIMPLESMENTE PASSAR ESSA DATA 


    A ALGUM METHOD DE '$invoice',


    como '->store()',







    E AÍ 

    

    RECEBER 1 RESULTADO DE VOLTA, DESSE METHOD... 



    RETORNAMOS ESSE RESULT, DO CONTROLLER,


    OU NA FORMA DE 1 VIEW, OU NA FORMA DE JSON,


    PARA QUE O FRONTEND JAVASCRIPT POSSA 
    FAZER O UPDATE APROPRIADO NA TELA,

    PARA QUE O USER CONSIGA 

    VISUALIZAR A MUDANÇA,...













''''VALIDATION''' -> A VALIDATION DEVE IR DENTRO DO CONTROLLER,
                    OU DENTRO DO MODEL?




                    --> ALGUNS DIZEM QUE VALIDATION É TRABALHO 
                        DO MODEL (BUSINESS LOGIC),


                        E OUTROS DIZEM QUE É DO CONTROLLER...




                    --> A OPINIÃO DO PROFESSOR É QUE 

                    A 'FORM VALIDATION' 

                    DEVE SER O TRABALHO DO CONTROLLER...




                --> AINDA MELHOR, DEVE SER O JOB DE UM 

                'SEPARATE LAYER' 

                EM RELAÇÃO AO CONTROLLER,


                QUE __ SE ENCARREGARIA DE TODOS OS FORM REQUESTS 
                E VALIDATION 

                (de forma similar à maneira que 
                o LARAVEL faz...)



                (COM ISSO, TIRAMOS A VALIDATION
                DO 'CONTROLLER', PARA OUTRO LAYER,

                UM DAQUELES 'SUB-LAYERS' QUE O PROFESSOR HAVIA MENCIONADO 
                ANTERIORMENTE,

                EM QUE __ EXTRAÍMOS A VALIDATION E FORM-REQUEST RELATED 
                FUNCTIONALITY, DESSAS CLASSES DE VALIDATION,

                E AÍ PASSAMOS ESSA DATA AO MODEL... 

                
                __ COMO RESULTADO DISSO, SEUS CONTROLLERS VÃO FICAR 'THIN',
                PQ ESSE É O OBJETIVO,

                'MAKE YOUR CONTROLLERS AS THIN AS POSSIBLE'...
                
                 )






