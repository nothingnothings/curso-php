








--> CONTINUAREMOS COM O NOSSO REFACTORING...











-> DESSA VEZ, VAMOS REFACTOR
    A PARTE DO AUTHCONTROLLER...












---> O AUTHCONTROLLER ESTÁ ASSIM:










<?php declare(strict_types=1);

namespace App\Controllers;

use App\Contracts\AuthInterface;
use App\Entity\User;
use App\Exception\ValidationException;
use Psr\Http\Message\ResponseInterface as Response;
use Slim\Psr7\Request as Request;
use Slim\Views\Twig;
use Valitron\Validator;


class AuthController
{

    public function __construct(private readonly Twig $twig,  private readonly AuthInterface $auth) {}

    public function loginView(Request $request, Response $response): Response
    {
        return $this->twig->render($response, 'auth/login.twig');
    }



    public function registerView(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'auth/register.twig');
    }


    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;


       $v = new Validator($data);

       $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
       $v->rule('email', 'email');
       $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

       $v->rule(
            function($field, $value, $params, $fields) use ($email) {
      
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers; // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message("User with the given email address already exists.");


        if(!$v->validate()) {
            throw new ValidationException($v->errors());
        } 
       
       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);

       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;
    }


    public function logIn(Request $request, Response $response): Response
    {
        // 1. Validate the request data  // * DONE  

        $data = $request->getParsedBody();
        ['email' => $email, 'password' => $password ] = $data;
     
        $v = new Validator($data);

        $v->rule('required', ['email', 'password']);
        $v->rule('email', 'email');


        // 2. Check the user credentials // * DONE  
        if(!$v->validate()) {
            echo 'Entered';
            var_dump($v->errors());
            throw new ValidationException($v->errors());
        } 

        if($this->auth->attemptLogin($data)) {
            throw new ValidationException(['password' => ['You have entered an invalid username or password.']]);
        }

        // 4. Redirect user to the home page // * DONE  
        return $response->withHeader('Location', '/')->withStatus(302); 
    }


    public function logOut(Request $request, Response $response): Response
    {
        $this->auth->logout();


        return $response->withHeader('Location', '/')->withStatus(302);
    }
}















-> O PROFESSOR ACHA QUE ESSE CONTROLLER ESTÁ 'DOING TOO MUCH'...








-> É UMA GOOD PRACTICE DEIXAR SEUS CONTROLLERS SLIM....










-> A PRIMERIA COISA QUE O PROFESSOR QUER REFATORAR É ESSA PARTE DE VALIDATION:









    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;


       $v = new Validator($data);

       $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
       $v->rule('email', 'email');
       $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

       $v->rule(
            function($field, $value, $params, $fields) use ($email) {
      
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers; // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message("User with the given email address already exists.");


        if(!$v->validate()) {
            throw new ValidationException($v->errors());
        } 
       
       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);

       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;
    }















ELE QUER COLOCAR ISSO EM 1 CLASS DE VALIDATION PRÓPRIA,

EXTRAIR ISSO AÍ...







--> VEREMOS ISSO EM ALGUNS MINUTOS, MAS, ANTES DISSO,


TEMOS QUE MEXER EM OUTRA COISA..








-> É ESTA PARTE, DE USER REGISTRATION:





       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);

       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;











--> ESTAMOS CRIANDO 1 NOVO USER DENTRO DO CONTROLLER...


    ISSO SIGNIFICA QUE ESTAMOS ACESSANDO O ENTITYMANAGER 

    E DECIDINDO COMO VAMOS 'HASH THE PASSWORD',


    TUDO DENTRO DE ESSE CONTROLLER...








-> TAMBÉM, DEPOIS QUE O USER FAZ REGISTER,
    NÓS TAMBÉM NÃO ESTAMOS REDIRECTING O USER,

    E TAMBÉM NÃO ESTAMOS REALMENTE 'AUTHENTICATING' O USER...






-> QUEREMOS AUTHENTICATE O USER ASSIM QUE ELE FAZ SIGN UP...











--> É POR ISSO QUE, EM VEZ DE RETORNAR 1 PLAIN RESPONSE,


QUEREMOS RETORNAR 1 RESPONSE COM O 'LOCATION HEADER',


TUDO PARA QUE CONSIGAMOS REDIRECIONAR O USER à HOME PAGE,


COM STATUS 302,


TIPO ASSIM:







       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);

       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        // return $response;

        return $response->withHeader('Location', '/')->withStatus(302);






 




DEPOIS DISSO,


O PROFESSOR QUER 

OUTSOURCE ESSA PARTE TODA DE USER CREATION,




PARA DEIXAR A CLASS DE 'AUTH' 

HANDLAR A REGISTRATION...








-> ISSO PQ _ NÓS JÁ REFATORAMOS TODO 'AUTH-RELATED STUFF'


PARA DENTRO 

DA 
CLASS DE 'Auth.php'...






-> É POR ISSO QUE ESCREVEMOS ASSIM:





       
    //    $user = new User();

    //    $user->setName($name);
    //    $user->setEmail($email);
    //    $user->setHashedPassword($password);

    //    $this->entityManager->persist($user);
    //    $this->entityManager->flush();

       $this->auth->register();
       
       var_dump($data, 'THE DATA');

        // return $response;

        return $response->withHeader('Location', '/')->withStatus(302);










CERTO... AGORA BASTA CRIAR ESSE METHOD DE 'register()',

dentro 



da class 'Auth'...







tipo assim:



<?php declare(strict_types=1);

namespace App\Contracts;

interface AuthInterface
{
    public function user(): ?UserInterface;

    public function attemptLogin(array $data): bool;

    public function checkCredentials(UserInterface $user, array $credentials): bool;

    public function logout(): void;

    public function register(array $data): UserInterface;
}




E ASSIM:





    public function register(array $data): UserInterface
    {
       $user = $this->userProvider->createUser();


    }












--> VAMOS COMEÇAR COM 1 METHOD COMO 'createUser',


que vai existir nesse 'UserProvider' class...







-> esse method de create user vai 


ter alguma lógica como 



'$user = new User();

return  $user;'













O METHOD DE 'register' vai ao mesmo tempo:



1) CRIAR O USER 



2) USAR O USER NO LOGIN,
    PARA AUTHENTICATE O USER, NA PÁGINA





É POR ISSO QUE FICA ASSIM:



    public function register(array $data): UserInterface
    {
       // Create User:
       $user = $this->userProvider->createUser($data);

       // Authenticate User (use created user in login):
       $credentials = [
           'email' => $data['email'],
           'password' => $data['password']
       ];

       $this->attemptLogin($credentials);

       return $user;
    }










mas o professor também refatora o method de 'attemptLogin',




ELE PEGA AQUELAS 3 LINHAS:






        $this->session->regenerate();
        $this->session->put('user', $user->getId());

        $this->user = $user;








E COLOCA EM 1 OUTRO METHOD, DE NOME 





'$this->logIn($user);'







-> AÍ CRIAMOS ESSE METHOD,  EM 'Auth.php':











    public function attemptLogin(array $credentials): bool
    {
        $user = $this->userProvider->getByCredentials($credentials);


        if (!$user || !$this->checkCredentials($user, $credentials)) {
           return false;
        }


        $this->logIn($user);

        return true;
    }








E ASSIM:




    public function logIn(UserInterface $user): void 
    {
        $this->session->regenerate();
        $this->session->put('user', $user->getId());

        $this->user = $user;
    }













CERTO...








AGORA PODEMOS USAR ESSE MESMO METHOD,

'logIn',

LÁ EM 'register()',

TIPO ASSIM:





    public function register(array $data): UserInterface
    {
       // Create User:
       $user = $this->userProvider->createUser($data);

       $this->logIn($user);

       return $user;
    }













A FUNCTION DE 'createUser',

lá em 'UserProviderService', fica assim:





    public function createUser(array $data): UserInterface
    { 
        $user = new User();
        
        $user->setName($data['name']);
        $user->setEmail($data['email']);
        $user->setHashedPassword($data['password']);

        $this->entityManager->persist($user);
        $this->entityManager->flush();

        return $user;
    }











COM ISSO, NOSSO CONTROLLER DE AUTHCONTROLLER FICOU BEM MELHOR,


PQ AGORA 



''IT DOES NOT HAVE TO WORRY OR KNOW ABOUT THE ENTITY MANAGER''...






-> AGORA ELE APENAS CHAMA O METHOD DE '$this->auth->register()',


QUE JÁ HANDLA A PARTE DE USER CREATION, JUNTO COM A PARTE DE USER AUTHENTICATION...









EX:






    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;


       $v = new Validator($data);

       $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
       $v->rule('email', 'email');
       $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

       $v->rule(
            function($field, $value, $params, $fields) use ($email) {
      
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers; // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message("User with the given email address already exists.");


        if(!$v->validate()) {
            throw new ValidationException($v->errors());
        } 
       
       $this->auth->register($data);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }














-> O PROFESSOR APONTA QUE ESSA VARIABLE DE '$data'

É OUTRO EXCELENTE CANDIDATO PARA UM DTO...




       $this->auth->register($data);




-> MESMA COISA PARA O METHOD DE 'register()':




    public function register(array $data): UserInterface;












EM VEZ DE ACEITAR 1 ARRAY,

ELE PODE ACEITAR UM DATA DTO...






-> FARÍAMOS A MESMA COISA NO UserProviderServiceInterface,

com o 'createUser':






<?php declare(strict_types=1);

namespace App\Contracts;

interface UserProviderServiceInterface
{
    public function getById(int $userId): ?UserInterface;

    public function getByCredentials(array $credentials): ?UserInterface;

    public function createUser(array $data): UserInterface;
}











-> PODEMOS CRIAR ESSE DTO...






-> VAMOS TENTAR CRIAR, SOZINHOS...











OK.... FIZ TUDO ISSO...







EX:









<?php declare(strict_types=1);

namespace App\DTOs;

class UserData
{
    public function __construct(
        public readonly string $name,
        public readonly string $email,
        public readonly string $password
    ) {}
}









OK... AÍ TENTAMOS ENTRAR NA PAGE,


CRIAMOS 1 NOVO USER, PARA TESTAR SE O AUTHENTICATE E REDIRECT AO DASHBOARD FUNCIONA...













OK, ESTÁ FUNCIONANDO... MAS O PROFESSOR QUER REFATORAR MAIS UMA PARTE, A PARTE DE VALIDATION EM 
'register()':






   public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($name, $email, $password);


       $v = new Validator($data);

       $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
       $v->rule('email', 'email');
       $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

       $v->rule(
            function($field, $value, $params, $fields) use ($email) {
      
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers; // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message("User with the given email address already exists.");


        if(!$v->validate()) {
            throw new ValidationException($v->errors());
        } 
       
       $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }








ELE QUER EXTRAIR TODAS ESSAS RULES E TUDO RELACIONADO À VALIDATION, EM CLASSES PRÓPRIAS:


       $v = new Validator($data);

       $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
       $v->rule('email', 'email');
       $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

       $v->rule(
            function($field, $value, $params, $fields) use ($email) {
      
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers; // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message("User with the given email address already exists.");


        if(!$v->validate()) {
            throw new ValidationException($v->errors());
        } 











    -> PODEMOS TER 1 VALIDATION CLASS PARA A USER REGISTRATION,

    QUE VAI CONTER AS RULES 

    E VALIDATION PARA A PARTE DE REGISTRATION...





--> E PODEMOS TER 1 VALIDATION CLASS PARA O USER LOGIN,

E ASSIM POR DIANTE..












-> É POR ISSO QUE VALE A PENA REFATORAR O CÓDIGO PARA ALGO ASSIM:







$data = (new RegisterUserRequestValidator())->validate($request->getParsedBody());  








OU SEJA, TEREMOS ESSA CLASS 'RegisterUserRequestValidator()'






--> VAMOS COLOCAR ISSO EM 1 NAMESPACE PRÓPRIO, COMO 'REQUESTVALIDATORS'...







-> ESSE RegisterUserRequestValidator 

VAI TER 1 ÚNICO METHOD, 'validate':







<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\Contracts\RegisterUserRequestValidatorInterface;
use App\Contracts\RequestValidatorInterface;
use App\DTOs\UserData;
use App\Entity\User;
use Doctrine\ORM\EntityManager;

class RegisterUserRequestValidator implements RegisterUserRequestValidatorInterface
{
    public function __construct( private readonly EntityManager $entityManager) {}

    public function validate(UserData $userData): array
    {
        $v = new \Valitron\Validator($userData);

        $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
        $v->rule('email', 'email');
        $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

        $v->rule(
            function ($field, $value, $params, $fields) use ($userData) {
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers;  // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message('User with the given email address already exists.');

        if (!$v->validate()) {
            throw new \App\Exception\ValidationException($v->errors());
        }

        return $v->errors();
    }
}








O CONTROLLER VAI FICAR TIPO ASSIM:









    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($name, $email, $password);
        $parsedBody = $request->getParsedBody();

        $data = (new RegisterUserRequestValidator())->validate($parsedBody); 

        $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }

















OK... INJETAMOS O ENTITYMANAGER,


E AÍ 



ELE VAI RETORNAR O ARRAY DE ERRORS, SE OCORREREM QUAISQUER ERRORS...














-> MAS AQUI TEMOS 1 PROBLEMA:


''WE ARE EXPECTING ENTITY MANAGER AS A DEPENDENCY, IN THE CONSTRUCTOR...

AND WE ARE INSTANTIATING THIS CLASS DIRECTLY IN THE CONTROLLER''..








OU SEJA,

NESTE TRECHO:






        $data = (new RegisterUserRequestValidator())->validate($parsedBody); 









PRECISARÍAMOS PASSAR O ENTITY MANAGER A ESSA CALL...









MAS O PROFESSOR N QUER PASSAR O ENTITYMANAGER MANUALMENTE,


TODA VEZ QUE ELE QUER CRIAR 1 REQUESTVALIDATOR OBJECT... 










EM VEZ DISSO, O PROFESSOR 


''WANTS SOMETHING LIKE A CONTAINER,

THAT WILL BE RESPONSIBLE FOR GENERATING A NEW INSTANCE OF THIS REQUESTVALIDATOR 
CLASS, OR ANY REQUESTVALIDATOR CLASS, THAT WE GENERATE FROM NOW ON''...









-> COMO O PROFESSOR DIZ QUE 

''WE NEED ""SOMETHING"" TO GENERATE 
OR  CREATE AN INSTANCE OF REQUEST VALIDATOR CLASSES''',





ISSO QUER DIZER QUE 

PRECISAMOS DE UM FACTORY CLASS,




QUE ENTÃO GERARÁ ESSAS COISAS, 'READY-TO-USE'...







OK... É POR ISSO QUE VAMOS CRIAR 1 NOVO NAMESPACE, 'FACTORIES',

EM QUE VAMOS COLOCAR 


O 


'ValidatorFactory',

ou algo do gênero...









TIPO ALGO ASSIM:









<?php declare(strict_types=1);

namespace App\Factories;

use App\Contracts\ValidatorInterface;
use App\RequestValidators\RegisterUserRequestValidator;
use Doctrine\ORM\EntityManager;

class ValidatorFactory
{

    public function __construct(private readonly EntityManager $entityManager) {}

    public function createValidator(string $validatorName): ValidatorInterface
    {
        switch ($validatorName) {
            case 'RegisterUserRequestValidator':
                return new RegisterUserRequestValidator($this->entityManager);
            default:
                throw new \Exception('Validator not found');
        }
    }
}












AÍ, NO CASO,


VAMOS USAR ESSE NEGÓCIO PARA CRIAR 1 VALIDATOR LÁ NO AUTHCONTROLLER,

TIPO ASSIM:







<?php declare(strict_types=1);

namespace App\Factories;

use App\Contracts\ValidatorInterface;
use App\RequestValidators\RegisterUserRequestValidator;
use Doctrine\ORM\EntityManager;

class ValidatorFactory
{

    public function __construct(private readonly EntityManager $entityManager) {}

    public static function makeValidator(string $validatorName): ValidatorInterface
    {
        switch ($validatorName) {
            case 'RegisterUserRequestValidator':
                return new RegisterUserRequestValidator(self::$entityManager);
            default:
                throw new \Exception('Validator not found');
        }
    }
}

















AÍ, COM ISSO, PODEMOS CHAMAR ASSIM, NO AUTHCONTROLLER:







    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($name, $email, $password);
        $parsedBody = $request->getParsedBody();

        $registerValidator = ValidatorFactory::makeValidator('RegisterUserRequestValidator');

        $data = $registerValidator->validate($parsedBody);

        $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }










EX:







        $registerValidator = ValidatorFactory::makeValidator('RegisterUserRequestValidator');

        $data = $registerValidator->validate($parsedBody);

        $this->auth->register($userData);















-> O JOB DA FACTORY É BASICAMENTE 'CREATE AND RESOLVE 
                                NEW INSTANCE OF AN OBJECT,
                                AND RETURN IT'...















--> O PROFESSOR PREFERE ESCREVER ASSIM:





$data = $this->requestValidatorFactory->make(RegisterUserRequestValidator::class)->validate($request->getParsedBody());





MAS É CLARO QUE ISSO É BASICAMENTE A MESMA COISA QUE EU ESCREVI...














ESTE CÓDIGO FICOU BOM:








<?php declare(strict_types=1);

namespace App\Factories;

use App\Contracts\ValidatorInterface;
use App\RequestValidators\RegisterUserRequestValidator;
use Doctrine\ORM\EntityManager;

class ValidatorFactory
{

    public function __construct(private readonly EntityManager $entityManager) {}

    public static function make(string $validatorName): ValidatorInterface
    {
        switch ($validatorName) {
            case 'RegisterUserRequestValidator':
                return new RegisterUserRequestValidator(self::$entityManager);
            default:
                throw new \Exception('Validator not found');
        }
    }
}














OK...








MAS AINDA PRECISAMOS BINDAR ESSA FACTORY LÁ 




NO 'container_bindings',


para ficarmos com 1 concrete implementation,

tipo assim:







    RequestValidatorFactoryInterface::class => fn(ContainerInterface $container) => $container->get(ValidatorFactory::class),




















--> MAS O PROFESSOR ESCREVEU DE FORMA DIFERENTE, TIPO ASSIM:






<?php declare(strict_types=1);

namespace App\Factories;

use App\Contracts\RequestValidatorInterface;
use App\RequestValidators\RegisterUserRequestValidator;
use Doctrine\ORM\EntityManager;

class ValidatorFactory
{

    public function __construct(private readonly EntityManager $entityManager) {}

    public static function make(string $validatorName): RequestValidatorInterface
    {

        $validator = $this->container->get($class);
    }
}













--> mas não faz diferença...







mas o professor faz uns checks melhores:












<?php declare(strict_types=1);

namespace App\Factories;

use App\Contracts\RequestValidatorInterface;
use App\RequestValidators\RegisterUserRequestValidator;
use Doctrine\ORM\EntityManager;
use Psr\Container\ContainerInterface;

class ValidatorFactory
{

    public function __construct(private readonly ContainerInterface $container) {}

    public function make(string $class): RequestValidatorInterface
    {

        $validator = $this->container->get($class);

        if ($validator instanceof RequestValidatorInterface) {
            return $validator;
        }

        throw new \RuntimeException('Failed to instantiate the request validator class: ' . $class );  

    }
}








EX:






    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($name, $email, $password);
        $parsedBody = $request->getParsedBody();


        $data = $this->requestValidatorFactory
                    ->make(RegisterUserRequestValidator::class)
                    ->validate($parsedBody);

        $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }






TEMOS QUE REFATORAR A PARTE DE 'LOGIN', TAMBÉM,

PQ ELA AINDA ESTÁ USANDO AQUELAS RULES ANTIGAS:











    public function logIn(Request $request, Response $response): Response
    {
        // 1. Validate the request data  // * DONE  

        $data = $request->getParsedBody();
        ['email' => $email, 'password' => $password ] = $data;
     
        $v = new Validator($data);

        $v->rule('required', ['email', 'password']);
        $v->rule('email', 'email');


        // 2. Check the user credentials // * DONE  
        if(!$v->validate()) {
            echo 'Entered';
            var_dump($v->errors());
            throw new ValidationException($v->errors());
        } 

        if($this->auth->attemptLogin($data)) {
            throw new ValidationException(['password' => ['You have entered an invalid username or password.']]);
        }

        // 4. Redirect user to the home page // * DONE  
        return $response->withHeader('Location', '/')->withStatus(302); 
    }




VAMOS DEIXAR TIPO ASSIM:






<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\Contracts\RequestValidatorInterface;
use App\DTOs\UserData;
use Doctrine\ORM\EntityManager;

class LoginUserRequestValidator implements RequestValidatorInterface
{
    public function __construct( private readonly EntityManager $entityManager) {}

    public function validate(UserData $userData): array
    {
        $v = new \Valitron\Validator($userData);

        $v->rule('required', ['email', 'password']);
        $v->rule('email', 'email');


        if (!$v->validate()) {
            throw new \App\Exception\ValidationException($v->errors());
        }

        return $v->errors();
    }
}














OK... COM ISSO, CRIAMOS NOVAS CLASSES DE VALIDATOR,





COM ESSA FACTORY...







-> DEIXAMOS 
    NOSSOS CONTROLLERS BEM MAIS THIN E FÁCEIS DE MAINTAIN...






    -> USAMOS MAIS INTERFACES E APRENDEMOS 


    MAIS SOBRE O DESIGN PATTERN DE FACTORIES...








--> HÁ DIVERSAS MANEIRAS DE IMPLEMENTAR AS MESMAS COISAS...


















-> POR EXEMPLO,


O LARAVEL FORNECE A FUNCTIONALITY 
DE 

'CUSTOM REQUEST CLASSES',



EM QUE VC PODE 



''INJECT CUSTOM REQUEST CLASS IN CONTROLLER METHODS,
INSTEAD OF THE REGULAR REQUEST CLASS...

WITH THAT, YOU WOULD DEFINE THE VALIDATION RULES FROM INSIDE THAT 
CUSTOM REQUEST CLASS... THEN, LARAVEL WOULD 
TAKE CARE OF THE ACTUAL VALIDATION AND THE THROW OF EXCEPTIONS AND ETC''....









poderíamos escrever algo parecido, mas seria complicar demais o código...









-> AGORA VAMOS TESTAR O CÓDIGO, PARA VER SE ESTÁ TUDO FUNCIONANDO:












    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($name, $email, $password);
        $parsedBody = $request->getParsedBody();


        $data = $this->requestValidatorFactory
                    ->make(RegisterUserRequestValidator::class)
                    ->validate($parsedBody);

        $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }


    public function logIn(Request $request, Response $response): Response
    {
        // 1. Validate the request data and check the user's credentials  // * DONE  

        $data = $this->requestValidatorFactory->make(UserLoginRequestValidator::class)->validate($request->getParsedBody());
            
        if (!$this->auth->attemptLogin($data)) {
            throw new ValidationException(['password' => ['You have entered an invalid username or password.']]);
        }

        // 2. Redirect user to the home page // * DONE  
        return $response->withHeader('Location', '/')->withStatus(302); 
    }


    public function logOut(Request $request, Response $response): Response
    {
        $this->auth->logout();

        return $response->withHeader('Location', '/')->withStatus(302);
    }

















CERTO...







ESTÁ TUDO FUNCIONANDO...






HÁ OUTRA COISA QUE PODERÍAMOS TER MELHORADO...








-> AINDA ESTAMOS  ACESSANDO O ENTITYMANAGER,

DE DENTRO DO REQUESTVALIDATOR:












<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\Contracts\RequestValidatorInterface;
use App\DTOs\UserData;
use App\Entity\User;
use Doctrine\ORM\EntityManager;

class RegisterUserRequestValidator implements RequestValidatorInterface
{
    public function __construct( private readonly EntityManager $entityManager) {}

    public function validate(UserData $userData): array
    {
        $v = new \Valitron\Validator($userData);

        $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
        $v->rule('email', 'email');
        $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

        $v->rule(
            function ($field, $value, $params, $fields) use ($userData) {
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers;  // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message('User with the given email address already exists.');

        if (!$v->validate()) {
            throw new \App\Exception\ValidationException($v->errors());
        }

        return $v->errors();
    }
}











PODERÍAMOS MELHORAR ISSO POR MEIO 

DO EXTRACT DAS RULES A 1 CUSTOM RULE CLASS... MAS 

ISSO É MEIO OVERKILL.... JÁ EXTRAÍMOS TODAS AS VALIDATION RULES 

PARA DENTRO 

DE ESSA CLASS DE 'RegisterUserRequestValidator',


é fine acessar o entityManager aí dentro...






-> NA PRÓXIMA AULA, 

VEREMOS ALGUNS OUTROS TÓPICOS..






-> IMPLEMENTAREMOS AS FUNCTIONALITIES DE EMAIL VERIFICATION E FORGOT PASSWORD MAIS TARDE...