






CREATE 


READ 


UPDATE 



DELETE...














--> SÃO BASIC ACTIONS QUE PODEM SER APLICADAS SOBRE DATA...





--> VAMOS COMEÇAR COM AS CATEGORIES, NESSA AULA,

PQ É MAIS SIMPLES,

E VAI NOS AJUDAR COM AS FOUNDATIONS PARA OUTROS COMPONENTS,

COMO TRANSACTIONS...








-> O PROFESSOR QUER NOS MOSTRAR ALGUMAS CHANGES QUE ELE FEZ,

POR TRÁS DAS SCENES..




-> 

QUANDO CLICAMOS EM 'TRANSACTIONS',

SOMOS LEVADOS PARA A PAGE DE TRANSACTIONS,

QUE ATUALMENTE ESTÁ VAZIA...








-> ESSA PAGE TEM 1 BUTTON DE '+ NEW CATEGORY'..









--> O HEADER AINDA NÃO ESTÁ FUNCIONANDO...







--> QUANDO CLICAMOS EM 'NEW CATEGORY',

É ABERTO 1 MODAL COM 1 FORM...








--> ESSA FORM TEM APENAS 1 ÚNICO FIELD,


CATEGORY NAME,


PQ ISSO É TUDO QUE É NECESSÁRIO PARA 1 CATEGORY SER CRIADA....








--> NESSA PAGE,

TEREMOS 1 TABLE COM TODAS AS CATEGORIES,


MAS AINDA NÃO FIZEMOS ISSO FUNCIONAR...










-> E ESSA TABLE VAI NOS DEIXAR EDIT E DELETE AS CATEGORIES 
JÁ CRIADAS...






--> PARA ISSO, 
 

 ABRIMOS O CÓDIGO, E VISUALIZAMOS AS MUDANÇAS NELE...






 --> PRIMEIRAMENTE,

  TEMOS 1 NOVO CONTROLLER,


  'CategoriesController',

  com este código:

  

<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Models\Category;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig) {}

    public function index(Request $request, Response $response): Response
    {
        
        return $this->twig->render($response, 'categories/index.twig');
    }
}















E OUTROS METHODS, COMO ESTES:









<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Models\Category;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig) {}

    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }

    public function store(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }

    public function delete(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }
}








CERTO... 





ATÉ AÍ, TUDO BEM...





ESSES METHODS ESTAO VAZIOS, POR ENQUANTO...








-> NO ARQUIVO 'web.php',

DE NOSSAS ROUTES,





O PROFESSOR AGRUPOU VÁRIAS DAS ROUTES, PARA DEIXAR O CÓDIGO MAIS ORGANIZADO...







ANTES ESTAVA ASSIM:








<?php declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\HomeController;
use App\Middleware\AuthMiddleware;
use App\Middleware\GuestMiddleware;
use Slim\App;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index'])->add(AuthMiddleware::class);

    $app->get('/login', [AuthController::class, 'loginView'])->add(GuestMiddleware::class);
    $app->get('/register', [AuthController::class, 'registerView'])->add(GuestMiddleware::class);
    $app->post('/login', [AuthController::class, 'login'])->add(GuestMiddleware::class);
    $app->post('/register', [AuthController::class, 'register'])->add(GuestMiddleware::class);
    $app->post('/logout', [AuthController::class, 'logOut'])->add(AuthMiddleware::class);


    
};
















mas agora ficou ASSIM:









<?php

declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\CategoriesController;
use App\Controllers\HomeController;
use App\Middleware\AuthMiddleware;
use App\Middleware\GuestMiddleware;
use Slim\App;
use Slim\Routing\RouteCollectorProxy;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index'])->add(AuthMiddleware::class);

    $app->group('', function (RouteCollectorProxy $guest) {
        $guest->get('/login', [AuthController::class, 'loginView']);
        $guest->get('/register', [AuthController::class, 'registerView']);
        $guest->post('/login', [AuthController::class, 'login']);
        $guest->post('/register', [AuthController::class, 'register']);
    })->add(GuestMiddleware::class);

    $app->post('/logout', [AuthController::class, 'logOut'])->add(AuthMiddleware::class);

    $app->group('/categories', function (RouteCollectorProxy $categories) {
        $categories->get('', [CategoriesController::class, 'index']);
        $categories->post('', [CategoriesController::class, 'store']);
        $categories->delete('', [CategoriesController::class, 'delete']);
    })->add(AuthMiddleware::class);
};









-> O ROUTING DO SLIM 


TEM 1 FEATURE QUE NOS DEIXA 

AGRUPAR AS ROUTES...











PODEMOS AGRUPAR 



POR ALGUM PATH,

OU ENTÃO APENAS AGRUPAR 


POR LÓGICA (sem prefix algum)...






-> COM ISSO,


FICAMOS COM AS ROUTES DE 



/login
/register 

/logout 

e 


/categories/id 







-> TODAS AS ROUTES DE 'categories'


PRECISAM 



DO AUTH MIDDLEWARE PARA FUNCIONAREM,



PQ O USER PRECISA ESTAR AUTHENTICATED 

PARA CONSEGUIR DISPARAR REQUESTS CONTRA ESSAS ROUTES...












-> OK... MAS COMO FICOU O TWIG TEMPLATE DO 'CATEGORIES'?










-> ASSIM:









{% extends 'layout.twig' %}

{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('categories') }}
{% endblock %}

{% block title %}Categories{% endblock %}

{% block content %}
    <div class="categories container content-body">
        <div class="text-end">
            <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newCategoryModal">
                <i class="bi bi-plus-circle me-1"></i>
                New Category
            </button>
        </div>
        <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <form action="/categories" method="post">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">New Category</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            {{ csrf.fields | raw }}
                            <div class="form-outline form-white mb-4">
                                <input type="text" name="name" required
                                       class="form-control form-control-lg"
                                       placeholder="Category Name" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle me-1"></i>
                                Close
                            </button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle me-1"></i>
                                Create
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
        {% include 'categories/edit_category_modal.twig' %}
        {% if categories %}
            <div id="categoriesTable">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Created At</th>
                            <th>Updated At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for category in categories %}
                            <tr>
                                <td>{{ category.name }}</td>
                                <td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>
                                <td>
                                    <div class="d-flex flex-">
                                        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>
                                        <button class="ms-2 btn btn-outline-primary edit-category-btn"
                                                data-id="{{ category.id }}">
                                            <i class="bi bi-pencil-fill"></i>
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% endif %}
    </div>
{% endblock %}















COM ISSO, ESTAMOS FAZENDO EXTEND DO LAYOUT UNIVERSAL QUE TEMOS 
EM 1 FILE EXTERNA,


E DEPOIS ESTAMOS FAZENDO O LOAD DO JAVASCRIPT NECESSÁRIO....




COM ESTE CÓDIGO:


{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('categories') }}
{% endblock %}












--> AÍ, 

NO BLOCO DE 'CONTENT',




TEMOS A PARTE DE 'NEW CATEGORY', AQUELE BUTTON,


QUE ABRE O MODAL PARA CRIAR 1 NOVA CATEGORY...






->  MAIS PARA BAIXO, TEMOS O 'modal-dialog',


que possui 1 único input field:





        <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <form action="/categories" method="post">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">New Category</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            {{ csrf.fields | raw }}
                            <div class="form-outline form-white mb-4">
                                <input type="text" name="name" required
                                       class="form-control form-control-lg"
                                       placeholder="Category Name" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle me-1"></i>
                                Close
                            </button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle me-1"></i>
                                Create
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>










        --> AINDA MAIS PARA BAIXO,


        TEMOS A DIV DE ID 'categoriesTable',

    


que contém a table de categories,

que só aparece se temos alguma category adicionada...









--> AÍ LOOPAMOS POR DENTRO DAS CATEGORIES,
CRIANDO 1 ROW PARA CADA CATEGORY...








--> E TEMOS 2 BUTTONS EM CADA CATEGORY:







1) EDIT BUTTON 


2) DELETE BUTTON 










EX:





    {% for category in categories %}
                            <tr>
                                <td>{{ category.name }}</td>
                                <td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>
                                <td>
                                    <div class="d-flex flex-">
                                        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>
                                        <button class="ms-2 btn btn-outline-primary edit-category-btn"
                                                data-id="{{ category.id }}">
                                            <i class="bi bi-pencil-fill"></i>
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        {% endfor %}


















A ACTION DE 'DELETE'

TEM 1 FORM AO SEU REDOR...











-> E É 1 POST REQUEST,

MAS TEMOS 1 INPUT DE TYPE 'HIDDEN',


COM UM VALUE DE 'DELETE'...




EX:







 <input type="hidden" name="_METHOD" value="DELETE" />











 O PROFESSOR AINDA NÃO TESTOU O DELETE NO SLIM PHP FRAMEWORK...


 FAREMOS ISSO NESSA AULA...








 --> O PROFESSOR 


 ADICIONOU UNS ICONS...







 --> PARA ISSO, ELE USOU A PACKAGE DE 'bootstrap-icons'...










 -> ELE TAMBÉM PRECISOU DO 'core-js',


 como dependency...








O COREJS TRAZ ALGUNS POLYFILLS NECESSÁRIOS PARA OLDER BROWSERS...











--> OK... SIGNIFICA QUE PRECISAMOS INSTALAR ESSES PACKAGES,



COM 



'npm install corejs bootstrap-icons'








certo...






TAMBÉM FICAMOS COM 1 NOVO ARQUIVO '.js',


DE NOME 'categories.js'...











NELE, ESTAMOS 


COM 1 EVENT LISTENER,


DE 'DOMContentLoaded'...




--> QUANDO ISSO ACONTECE,

O PROFESSOR ADICIONA 1 'event listener'


em cada 1 dos buttons,



para que 


SEJA EXTRAÍDO O 'data-id',



que é o CATEGORY ID,



DE CADA 1 DOS CATEGORY ITEMS,

SEMPRE QUE ELES SÃO CLICADOS...






O CÓDIGO É ESTE:









window.addEventListener('DOMContentLoaded', function () {


    this.document.querySelectorAll('.edit-category-btn').forEach(button => {
        button.addEventListener('click', function (event) {
            event.preventDefault();
            const categoryId = event.currentTarget.getAttribute('data-id');


            console.log(categoryId);
        });
    });
});















-> aí, em 'webpack.config.js',


ESTAMOS 


ADICIONANDO ESSE NOVO .js como entry,


ASSIM:



     */
    .addEntry("app", "./resources/js/app.js")
    .addEntry("dashboard", "./resources/js/dashboard.js")
    .addEntry("auth", "./resources/js/auth.js")
    .addEntry("categories", "./resources/js/category.js")














DEPOIS DISSO, DEVEMOS RODAR 

'npm run dev'...









CERTO... AGORA AS COISAS ESTÃO FUNCIONANDO....











MAS PRECISAMOS FAZER OS METHODS DE 'CategoriesController'


funcionarem....








COMEÇAMOS COM 'STORE':





    public function store(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }









QUEREMOS FAZER 2 COISAS, ANTES DE REDIRECIONAR O USER PARA A PAGE DE '/categories'

geral....







--> QUEREMOS:



1. VALIDATE REQUEST DATA 



2. CREATE A NEW CATEGORY RECORD, IN THE DATABASE...













-> COMO VC DEVE SE LEMBRAR,


O PROFESSOR SEMPRE ESCREVE CÓDIGO FEIO, E DEPOIS REFATORA....








--> MAS O PROFESSOR 


AGORA VAI DIRETO PARA O CÓDIGO LIMPO,

PQ JÁ TEMOS EXPERIÊNCIA...







-> LÁ NO METHOD 'register()',


    do AuthController,

    VC DEVE SE LEMBRAR 


    DO QUÃO FEIO ESTAVA O CÓDIGO, INICIALMENTE....





EVENTUALMENTE, O CÓDIGO FICOU BONITO, COM ESTE FORMATO:











    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($email, $password, $name);

        $data = $this->requestValidatorFactory
                    ->make(RegisterUserRequestValidator::class)
                    ->validate($userData);

        $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }












--> bem, nós vamos pegar esse código e colar lá na parte de 'CategoriesController',


no 'store':








    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
        'name' => $name, 
        'email' => $email, 
        'password' => $password, 
        'confirmPassword' => $confirmPassword
         ] = $data;
 
         $userData = new UserData($email, $password, $name);
 
         $data = $this->requestValidatorFactory
                     ->make(RegisterUserRequestValidator::class)
                     ->validate($userData);
 
         $this->auth->register($userData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }











MAS VAMOS ADAPTAR ISSO, PARA QUE FUNCIONE COM ESSE METHOD TAMBÉM...





O FORMATO FICARÁ MAIS OU MENOS ASSIM:








    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
        'name' => $name,  
         ] = $data;
 
         $categoryData = new CategoryData($name);
 
         $data = $this->requestValidatorFactory
                     ->make(CreateCategoryRequestValidator::class)
                     ->validate($categoryData);
 
         $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }










--> precisamos criar essa class de 'CreateCategoryRequestValidator'...









fazemos tipo assim:





<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\DTOs\CategoryData;
use Valitron\Validator;

class CreateCategoryRequestValidator
{
    public function validate(CategoryData $categoryData): CategoryData
    {
        $v = new Validator($categoryData);

        $v->rule('required', ['name']);
        $v->rule('string', ['name']);

        return $categoryData;
    }
}










PRECISAMOS QUE ESSE 'name' seja required, sim...





-> TAMBÉM QUEREMOS QUE A LENGTH MÁXIMA SEJA DE 50 

CARACTERES, TAMBÉM...





EX:







<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\DTOs\CategoryData;
use Valitron\Validator;

class CreateCategoryRequestValidator
{
    public function validate(CategoryData $categoryData): CategoryData
    {
        $v = new Validator($categoryData);

        $v->rule('required', ['name']);
        $v->rule('string', ['name']);
        $v->rule('lengthMax', 'name', 50);

        return $categoryData;
    }
}











ISSO FEITO, QUEREMOS IMPORTAR ESSA CLASS DENTRO DE NOSSO 

CONTROLLER,

TIPO ASSIM:



<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Models\Category;
use App\RequestValidators\CreateCategoryRequestValidator;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig) {}

    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }

    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
        'name' => $name,  
         ] = $data;
 
         $categoryData = new CategoryData($name);
 
         $data = $this->requestValidatorFactory
                     ->make(CreateCategoryRequestValidator::class)
                     ->validate($categoryData);
 
         $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }


    public function delete(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }
}










DPS DISSO, PRECISAMOS ACESSAR AQUELA FACTORY DE 'requestValidatorFactory'

ao constructor de 'categoriesController'...







FAZEMOS TIPO ASSIM:










    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
            'name' => $name,
        ] = $data;

        $categoryData = new CategoryData($name);

        $data = $this->requestValidatorFactory
            ->make(CreateCategoryRequestValidator::class)
            ->validate($categoryData);

        $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }











    PRECISAMOS DE UMA SERVICE 

    CLASS 

    PARA 

    ESSE 


'$this->category->create()'....









-> PRECISAMOS DISSO PARA CREATE THE CATEGORY,

PERSIST AND FLUSH IT...







> É POR ISSO QUE O PROFESSOR 



VAI QUERER ESCREVER ALGO COMO 


'$this->categoryService->create(

)'









--> O PROFESSOR N USOU UM DTO,

MAS EU USEI...









--> DEPOIS DISSO, CRIAMOS O CATEGORYSERVICE,


COM ESTE CÓDIGO:










<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Contracts\CategoryServiceInterface;
use App\Contracts\RequestValidatorFactoryInterface;
use App\Models\Category;
use App\RequestValidators\CreateCategoryRequestValidator;
use App\Services\CategoryService;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig, RequestValidatorFactoryInterface $requestValidatorFactory, private readonly CategoryServiceInterface $category) {}

    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }

    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
            'name' => $name,
        ] = $data;

        $categoryData = new CategoryData($name);

        $data = $this->requestValidatorFactory
            ->make(CreateCategoryRequestValidator::class)
            ->validate($categoryData);

        $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }


    public function delete(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }
}











JÁ CRIEI ESSA INTERFACE, TAMBÉM...










AGORA BASTA CRIAR ESSE SERVICE, E IMPLEMENTAR A INTERFACE 

NELE...





TIPO ASSIM:








<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\CategoryServiceInterface;
use App\DTOs\CategoryData;
use App\Entity\Category;

class CategoryService implements CategoryServiceInterface
{
    public function create(CategoryData $categoryData): Category
    {
        $category = new Category();
        $category->setName($categoryData->name);

        return $category;
    }
}











ESSE É UM BOM COMEÇO...









MAS FALTA O 

'entityManager->persist()'


e 

'entityManager->flush()'...







TIPO ASSIM:





<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\CategoryServiceInterface;
use App\DTOs\CategoryData;
use App\Entity\Category;
use Doctrine\ORM\EntityManager;

class CategoryService implements CategoryServiceInterface
{

    public function __construct(private readonly EntityManager $entityManager) {}


    public function create(CategoryData $categoryData): Category
    {
        $category = new Category();
        $category->setName($categoryData->name);

        $this->entityManager->persist($category);
        $this->entityManager->flush();

        return $category;
    }
}














OK...






mas só isso não basta...

