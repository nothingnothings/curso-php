






CREATE 


READ 


UPDATE 



DELETE...














--> SÃO BASIC ACTIONS QUE PODEM SER APLICADAS SOBRE DATA...





--> VAMOS COMEÇAR COM AS CATEGORIES, NESSA AULA,

PQ É MAIS SIMPLES,

E VAI NOS AJUDAR COM AS FOUNDATIONS PARA OUTROS COMPONENTS,

COMO TRANSACTIONS...








-> O PROFESSOR QUER NOS MOSTRAR ALGUMAS CHANGES QUE ELE FEZ,

POR TRÁS DAS SCENES..




-> 

QUANDO CLICAMOS EM 'TRANSACTIONS',

SOMOS LEVADOS PARA A PAGE DE TRANSACTIONS,

QUE ATUALMENTE ESTÁ VAZIA...








-> ESSA PAGE TEM 1 BUTTON DE '+ NEW CATEGORY'..









--> O HEADER AINDA NÃO ESTÁ FUNCIONANDO...







--> QUANDO CLICAMOS EM 'NEW CATEGORY',

É ABERTO 1 MODAL COM 1 FORM...








--> ESSA FORM TEM APENAS 1 ÚNICO FIELD,


CATEGORY NAME,


PQ ISSO É TUDO QUE É NECESSÁRIO PARA 1 CATEGORY SER CRIADA....








--> NESSA PAGE,

TEREMOS 1 TABLE COM TODAS AS CATEGORIES,


MAS AINDA NÃO FIZEMOS ISSO FUNCIONAR...










-> E ESSA TABLE VAI NOS DEIXAR EDIT E DELETE AS CATEGORIES 
JÁ CRIADAS...






--> PARA ISSO, 
 

 ABRIMOS O CÓDIGO, E VISUALIZAMOS AS MUDANÇAS NELE...






 --> PRIMEIRAMENTE,

  TEMOS 1 NOVO CONTROLLER,


  'CategoriesController',

  com este código:

  

<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Models\Category;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig) {}

    public function index(Request $request, Response $response): Response
    {
        
        return $this->twig->render($response, 'categories/index.twig');
    }
}















E OUTROS METHODS, COMO ESTES:









<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Models\Category;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig) {}

    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }

    public function store(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }

    public function delete(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }
}








CERTO... 





ATÉ AÍ, TUDO BEM...





ESSES METHODS ESTAO VAZIOS, POR ENQUANTO...








-> NO ARQUIVO 'web.php',

DE NOSSAS ROUTES,





O PROFESSOR AGRUPOU VÁRIAS DAS ROUTES, PARA DEIXAR O CÓDIGO MAIS ORGANIZADO...







ANTES ESTAVA ASSIM:








<?php declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\HomeController;
use App\Middleware\AuthMiddleware;
use App\Middleware\GuestMiddleware;
use Slim\App;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index'])->add(AuthMiddleware::class);

    $app->get('/login', [AuthController::class, 'loginView'])->add(GuestMiddleware::class);
    $app->get('/register', [AuthController::class, 'registerView'])->add(GuestMiddleware::class);
    $app->post('/login', [AuthController::class, 'login'])->add(GuestMiddleware::class);
    $app->post('/register', [AuthController::class, 'register'])->add(GuestMiddleware::class);
    $app->post('/logout', [AuthController::class, 'logOut'])->add(AuthMiddleware::class);


    
};
















mas agora ficou ASSIM:









<?php

declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\CategoriesController;
use App\Controllers\HomeController;
use App\Middleware\AuthMiddleware;
use App\Middleware\GuestMiddleware;
use Slim\App;
use Slim\Routing\RouteCollectorProxy;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index'])->add(AuthMiddleware::class);

    $app->group('', function (RouteCollectorProxy $guest) {
        $guest->get('/login', [AuthController::class, 'loginView']);
        $guest->get('/register', [AuthController::class, 'registerView']);
        $guest->post('/login', [AuthController::class, 'login']);
        $guest->post('/register', [AuthController::class, 'register']);
    })->add(GuestMiddleware::class);

    $app->post('/logout', [AuthController::class, 'logOut'])->add(AuthMiddleware::class);

    $app->group('/categories', function (RouteCollectorProxy $categories) {
        $categories->get('', [CategoriesController::class, 'index']);
        $categories->post('', [CategoriesController::class, 'store']);
        $categories->delete('', [CategoriesController::class, 'delete']);
    })->add(AuthMiddleware::class);
};









-> O ROUTING DO SLIM 


TEM 1 FEATURE QUE NOS DEIXA 

AGRUPAR AS ROUTES...











PODEMOS AGRUPAR 



POR ALGUM PATH,

OU ENTÃO APENAS AGRUPAR 


POR LÓGICA (sem prefix algum)...






-> COM ISSO,


FICAMOS COM AS ROUTES DE 



/login
/register 

/logout 

e 


/categories/id 







-> TODAS AS ROUTES DE 'categories'


PRECISAM 



DO AUTH MIDDLEWARE PARA FUNCIONAREM,



PQ O USER PRECISA ESTAR AUTHENTICATED 

PARA CONSEGUIR DISPARAR REQUESTS CONTRA ESSAS ROUTES...












-> OK... MAS COMO FICOU O TWIG TEMPLATE DO 'CATEGORIES'?










-> ASSIM:









{% extends 'layout.twig' %}

{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('categories') }}
{% endblock %}

{% block title %}Categories{% endblock %}

{% block content %}
    <div class="categories container content-body">
        <div class="text-end">
            <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newCategoryModal">
                <i class="bi bi-plus-circle me-1"></i>
                New Category
            </button>
        </div>
        <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <form action="/categories" method="post">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">New Category</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            {{ csrf.fields | raw }}
                            <div class="form-outline form-white mb-4">
                                <input type="text" name="name" required
                                       class="form-control form-control-lg"
                                       placeholder="Category Name" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle me-1"></i>
                                Close
                            </button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle me-1"></i>
                                Create
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
        {% include 'categories/edit_category_modal.twig' %}
        {% if categories %}
            <div id="categoriesTable">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Created At</th>
                            <th>Updated At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for category in categories %}
                            <tr>
                                <td>{{ category.name }}</td>
                                <td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>
                                <td>
                                    <div class="d-flex flex-">
                                        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>
                                        <button class="ms-2 btn btn-outline-primary edit-category-btn"
                                                data-id="{{ category.id }}">
                                            <i class="bi bi-pencil-fill"></i>
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% endif %}
    </div>
{% endblock %}















COM ISSO, ESTAMOS FAZENDO EXTEND DO LAYOUT UNIVERSAL QUE TEMOS 
EM 1 FILE EXTERNA,


E DEPOIS ESTAMOS FAZENDO O LOAD DO JAVASCRIPT NECESSÁRIO....




COM ESTE CÓDIGO:


{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('categories') }}
{% endblock %}












--> AÍ, 

NO BLOCO DE 'CONTENT',




TEMOS A PARTE DE 'NEW CATEGORY', AQUELE BUTTON,


QUE ABRE O MODAL PARA CRIAR 1 NOVA CATEGORY...






->  MAIS PARA BAIXO, TEMOS O 'modal-dialog',


que possui 1 único input field:





        <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <form action="/categories" method="post">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">New Category</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            {{ csrf.fields | raw }}
                            <div class="form-outline form-white mb-4">
                                <input type="text" name="name" required
                                       class="form-control form-control-lg"
                                       placeholder="Category Name" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle me-1"></i>
                                Close
                            </button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle me-1"></i>
                                Create
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>










        --> AINDA MAIS PARA BAIXO,


        TEMOS A DIV DE ID 'categoriesTable',

    


que contém a table de categories,

que só aparece se temos alguma category adicionada...









--> AÍ LOOPAMOS POR DENTRO DAS CATEGORIES,
CRIANDO 1 ROW PARA CADA CATEGORY...








--> E TEMOS 2 BUTTONS EM CADA CATEGORY:







1) EDIT BUTTON 


2) DELETE BUTTON 










EX:





    {% for category in categories %}
                            <tr>
                                <td>{{ category.name }}</td>
                                <td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>
                                <td>
                                    <div class="d-flex flex-">
                                        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>
                                        <button class="ms-2 btn btn-outline-primary edit-category-btn"
                                                data-id="{{ category.id }}">
                                            <i class="bi bi-pencil-fill"></i>
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        {% endfor %}


















A ACTION DE 'DELETE'

TEM 1 FORM AO SEU REDOR...











-> E É 1 POST REQUEST,

MAS TEMOS 1 INPUT DE TYPE 'HIDDEN',


COM UM VALUE DE 'DELETE'...




EX:







 <input type="hidden" name="_METHOD" value="DELETE" />











 O PROFESSOR AINDA NÃO TESTOU O DELETE NO SLIM PHP FRAMEWORK...


 FAREMOS ISSO NESSA AULA...








 --> O PROFESSOR 


 ADICIONOU UNS ICONS...







 --> PARA ISSO, ELE USOU A PACKAGE DE 'bootstrap-icons'...










 -> ELE TAMBÉM PRECISOU DO 'core-js',


 como dependency...








O COREJS TRAZ ALGUNS POLYFILLS NECESSÁRIOS PARA OLDER BROWSERS...











--> OK... SIGNIFICA QUE PRECISAMOS INSTALAR ESSES PACKAGES,



COM 



'npm install corejs bootstrap-icons'








certo...






TAMBÉM FICAMOS COM 1 NOVO ARQUIVO '.js',


DE NOME 'categories.js'...











NELE, ESTAMOS 


COM 1 EVENT LISTENER,


DE 'DOMContentLoaded'...




--> QUANDO ISSO ACONTECE,

O PROFESSOR ADICIONA 1 'event listener'


em cada 1 dos buttons,



para que 


SEJA EXTRAÍDO O 'data-id',



que é o CATEGORY ID,



DE CADA 1 DOS CATEGORY ITEMS,

SEMPRE QUE ELES SÃO CLICADOS...






O CÓDIGO É ESTE:









window.addEventListener('DOMContentLoaded', function () {


    this.document.querySelectorAll('.edit-category-btn').forEach(button => {
        button.addEventListener('click', function (event) {
            event.preventDefault();
            const categoryId = event.currentTarget.getAttribute('data-id');


            console.log(categoryId);
        });
    });
});















-> aí, em 'webpack.config.js',


ESTAMOS 


ADICIONANDO ESSE NOVO .js como entry,


ASSIM:



     */
    .addEntry("app", "./resources/js/app.js")
    .addEntry("dashboard", "./resources/js/dashboard.js")
    .addEntry("auth", "./resources/js/auth.js")
    .addEntry("categories", "./resources/js/category.js")














DEPOIS DISSO, DEVEMOS RODAR 

'npm run dev'...









CERTO... AGORA AS COISAS ESTÃO FUNCIONANDO....











MAS PRECISAMOS FAZER OS METHODS DE 'CategoriesController'


funcionarem....








COMEÇAMOS COM 'STORE':





    public function store(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }









QUEREMOS FAZER 2 COISAS, ANTES DE REDIRECIONAR O USER PARA A PAGE DE '/categories'

geral....







--> QUEREMOS:



1. VALIDATE REQUEST DATA 



2. CREATE A NEW CATEGORY RECORD, IN THE DATABASE...













-> COMO VC DEVE SE LEMBRAR,


O PROFESSOR SEMPRE ESCREVE CÓDIGO FEIO, E DEPOIS REFATORA....








--> MAS O PROFESSOR 


AGORA VAI DIRETO PARA O CÓDIGO LIMPO,

PQ JÁ TEMOS EXPERIÊNCIA...







-> LÁ NO METHOD 'register()',


    do AuthController,

    VC DEVE SE LEMBRAR 


    DO QUÃO FEIO ESTAVA O CÓDIGO, INICIALMENTE....





EVENTUALMENTE, O CÓDIGO FICOU BONITO, COM ESTE FORMATO:











    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

        $userData = new UserData($email, $password, $name);

        $data = $this->requestValidatorFactory
                    ->make(RegisterUserRequestValidator::class)
                    ->validate($userData);

        $this->auth->register($userData);
    
        return $response->withHeader('Location', '/')->withStatus(302);
    }












--> bem, nós vamos pegar esse código e colar lá na parte de 'CategoriesController',


no 'store':








    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
        'name' => $name, 
        'email' => $email, 
        'password' => $password, 
        'confirmPassword' => $confirmPassword
         ] = $data;
 
         $userData = new UserData($email, $password, $name);
 
         $data = $this->requestValidatorFactory
                     ->make(RegisterUserRequestValidator::class)
                     ->validate($userData);
 
         $this->auth->register($userData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }











MAS VAMOS ADAPTAR ISSO, PARA QUE FUNCIONE COM ESSE METHOD TAMBÉM...





O FORMATO FICARÁ MAIS OU MENOS ASSIM:








    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
        'name' => $name,  
         ] = $data;
 
         $categoryData = new CategoryData($name);
 
         $data = $this->requestValidatorFactory
                     ->make(CreateCategoryRequestValidator::class)
                     ->validate($categoryData);
 
         $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }










--> precisamos criar essa class de 'CreateCategoryRequestValidator'...









fazemos tipo assim:





<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\DTOs\CategoryData;
use Valitron\Validator;

class CreateCategoryRequestValidator
{
    public function validate(CategoryData $categoryData): CategoryData
    {
        $v = new Validator($categoryData);

        $v->rule('required', ['name']);
        $v->rule('string', ['name']);

        return $categoryData;
    }
}










PRECISAMOS QUE ESSE 'name' seja required, sim...





-> TAMBÉM QUEREMOS QUE A LENGTH MÁXIMA SEJA DE 50 

CARACTERES, TAMBÉM...





EX:







<?php declare(strict_types=1);

namespace App\RequestValidators;

use App\DTOs\CategoryData;
use Valitron\Validator;

class CreateCategoryRequestValidator
{
    public function validate(CategoryData $categoryData): CategoryData
    {
        $v = new Validator($categoryData);

        $v->rule('required', ['name']);
        $v->rule('string', ['name']);
        $v->rule('lengthMax', 'name', 50);

        return $categoryData;
    }
}











ISSO FEITO, QUEREMOS IMPORTAR ESSA CLASS DENTRO DE NOSSO 

CONTROLLER,

TIPO ASSIM:



<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Models\Category;
use App\RequestValidators\CreateCategoryRequestValidator;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig) {}

    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }

    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
        'name' => $name,  
         ] = $data;
 
         $categoryData = new CategoryData($name);
 
         $data = $this->requestValidatorFactory
                     ->make(CreateCategoryRequestValidator::class)
                     ->validate($categoryData);
 
         $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }


    public function delete(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }
}










DPS DISSO, PRECISAMOS ACESSAR AQUELA FACTORY DE 'requestValidatorFactory'

ao constructor de 'categoriesController'...







FAZEMOS TIPO ASSIM:










    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
            'name' => $name,
        ] = $data;

        $categoryData = new CategoryData($name);

        $data = $this->requestValidatorFactory
            ->make(CreateCategoryRequestValidator::class)
            ->validate($categoryData);

        $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }











    PRECISAMOS DE UMA SERVICE 

    CLASS 

    PARA 

    ESSE 


'$this->category->create()'....









-> PRECISAMOS DISSO PARA CREATE THE CATEGORY,

PERSIST AND FLUSH IT...







> É POR ISSO QUE O PROFESSOR 



VAI QUERER ESCREVER ALGO COMO 


'$this->categoryService->create(

)'









--> O PROFESSOR N USOU UM DTO,

MAS EU USEI...









--> DEPOIS DISSO, CRIAMOS O CATEGORYSERVICE,


COM ESTE CÓDIGO:










<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Contracts\CategoryServiceInterface;
use App\Contracts\RequestValidatorFactoryInterface;
use App\Models\Category;
use App\RequestValidators\CreateCategoryRequestValidator;
use App\Services\CategoryService;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Slim\Views\Twig;

class CategoriesController
{

    public function __construct(private readonly Twig $twig, RequestValidatorFactoryInterface $requestValidatorFactory, private readonly CategoryServiceInterface $category) {}

    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }

    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        [
            'name' => $name,
        ] = $data;

        $categoryData = new CategoryData($name);

        $data = $this->requestValidatorFactory
            ->make(CreateCategoryRequestValidator::class)
            ->validate($categoryData);

        $this->category->create($categoryData);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }


    public function delete(Request $request, Response $response): Response
    {
        // TODO

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }
}











JÁ CRIEI ESSA INTERFACE, TAMBÉM...










AGORA BASTA CRIAR ESSE SERVICE, E IMPLEMENTAR A INTERFACE 

NELE...





TIPO ASSIM:








<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\CategoryServiceInterface;
use App\DTOs\CategoryData;
use App\Entity\Category;

class CategoryService implements CategoryServiceInterface
{
    public function create(CategoryData $categoryData): Category
    {
        $category = new Category();
        $category->setName($categoryData->name);

        return $category;
    }
}











ESSE É UM BOM COMEÇO...









MAS FALTA O 

'entityManager->persist()'


e 

'entityManager->flush()'...







TIPO ASSIM:





<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\CategoryServiceInterface;
use App\DTOs\CategoryData;
use App\Entity\Category;
use Doctrine\ORM\EntityManager;

class CategoryService implements CategoryServiceInterface
{

    public function __construct(private readonly EntityManager $entityManager) {}


    public function create(CategoryData $categoryData): Category
    {
        $category = new Category();
        $category->setName($categoryData->name);

        $this->entityManager->persist($category);
        $this->entityManager->flush();

        return $category;
    }
}














OK...






mas só isso não basta...












--> PRECISAMOS VINCULAR A CATEGORY AO USER QUE A CRIOU...







-> É POR ISSO QUE COLOCAREMOS 'USER'

COMO 1 DOS PARAMETERS DO METHOD DE 'create'



em 'CategoryService',

TIPO ASSIM:






<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\CategoryServiceInterface;
use App\DTOs\CategoryData;
use App\Entity\Category;
use App\Entity\User;
use Doctrine\ORM\EntityManager;

class CategoryService implements CategoryServiceInterface
{

    public function __construct(private readonly EntityManager $entityManager) {}


    public function create(CategoryData $categoryData, User $user): Category
    {
        $category = new Category();
        $category->setName($categoryData->name);
        $category->setUser($user);

        $this->entityManager->persist($category);
        $this->entityManager->flush();

        return $category;
    }
}








CERTO... ISSO VAI SETTAR O NAME DA CATEGORY,

E TAMBÉM O USER VINCULADO A ELA (user_id dentro 
da category)....









-> MAS LÁ EM 'CategoriesController',


PRECISAMOS PASSAR O USER COMO ARGUMENT AO CALL 

DO METHOD... FAZEMOS ISSO TIPO ASSIM:









    public function store(Request $request, Response $response): Response
    {
        $data = $request->getParsedBody();


        ['name' => $name] = $data;

        $categoryData = new CategoryData($name);

        $data = $this->requestValidatorFactory
            ->make(CreateCategoryRequestValidator::class)
            ->validate($categoryData);

        $user = $request->getAttribute('user');

        $this->category->create($categoryData, $user);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }













CERTO... E ISSO REALMENTE FUNCIONA....









-> COM ISSO, TERMINAMOS COM A ETAPA N2...






TEMOS 3 ETAPAS, PORTANTO:


1) VALIDATE DATA 


2) CREATE THE ENTITY 



3) REDIRECT THE USER...








--> DEVEMOS TESTAR ISSO AÍ, PARA VER SE REALMENTE FUNCIONA...








--> TENTAMOS CRIAR ESSA CATEGORY, MAS FICAMOS COM 1 ERROR:




''CREATED_AT CANNOT BE NULL''...












-> PRECISAMOS SETTAR O VALUE DE 

'created_at'


QUANDO CRIAMOS 1 CATEGORY..







-> PRECISAMOS USAR 1 LIFECYCLE METHOD 

DENTRO 


DA ENTITY DE 'CATEGORY',


PARA QUE ISSO SEJA FEITO PARA NÓS, AUTOMATICAMENTE...




OU SEJA,

BASTA REPLICAR O ĆODIGO LÁ DE 

''USER'', COM OS ATTRIBUTES..











TIPO ASSIM:




    #[PrePersist, PreUpdate]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        if (!isset($this->createdAt)) {
            $this->createdAt = new \DateTime();
        }

        $this->updatedAt = new \DateTime();
    }










CERTO... MAS EM VEZ DE DUPLICAR ESSE CÓDIGO INTEIRO,



COLANDO LÁ NA ENTITY DE 'CategoriesController',






E EM VEZ DE FAZER A MESMA COISA NAS OUTRAS ENTITIES (
    PQ TEMOS OUTRAS ENTITIES COM ESSA MESMA COLUMN DE 
    'CREATED_AT',

    E TAMBÉM VAMOS QUERER O MESMO COMPORTAMENTO LÁ...
)








-> PARA EVITAR ESSA DUPLICATION,
    PODEMOS USAR ALGUM TIPO DE ABSTRACTION...







-> O PROFESSOR NÃO QUER 
    USAR INHERITANCE, PQ NÃO SERIA BOM....






-> EM VEZ DISSO, O QUE ELE VAI QUERER USAR É 

__ UM TRAIT__...






--> VAMOS QUERER EXTRAIR ESSE CÓDIGO EM 1 TRAIT...










-> vamos criar 1 directory de nome 'Traits',


dentro do folder de 'Entities'...









-> AÍ CRIAREMOS 1 NOVA CLASS, 


DE NOME 'HasTimestampsTrait'...







EX:








<?php

declare(strict_types=1);

namespace App\Entity\Traits;

use Doctrine\ORM\Mapping as ORM;

trait HasTImestampsTrait {

    
}










e vamos copiar e colar tanto a column de 'created_at'


como 'updated_at', para dentro desse trait...






EX:






<?php

declare(strict_types=1);

namespace App\Entity\Traits;

use Doctrine\ORM\Mapping as ORM;

trait HasTImestampsTrait
{

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTime $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime')]
    private \DateTime $updatedAt;
}











CERTO...








--> TAMBÉM PRECISAMOS COLOCAR O METHOD,


DE 


''


    #[PrePersist, PreUpdate]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        if (!isset($this->createdAt)) {
            $this->createdAt = new \DateTime();
        }

        $this->updatedAt = new \DateTime();
    }
''





QUER DIZER QUE O TRAIT VAI FICAR ASSIM:





<?php

declare(strict_types=1);

namespace App\Entity\Traits;

use Doctrine\ORM\Event\LifecycleEventArgs;
use Doctrine\ORM\Mapping as ORM;
use Doctrine\ORM\Mapping\PrePersist;
use Doctrine\ORM\Mapping\PreUpdate;

trait HasTImestampsTrait
{

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTime $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime')]
    private \DateTime $updatedAt;

    #[PrePersist, PreUpdate]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        if (!isset($this->createdAt)) {
            $this->createdAt = new \DateTime();
        }

        $this->updatedAt = new \DateTime();
    }
}












CERTO...











ISSO FEITO, BASTA USAR ESSES TRAITS 

NAS ENTITIES DE 'USER' E 'CATEGORY',


TIPO ASSIM:












<?php

declare(strict_types=1);

namespace App\Entity;

use App\Entity\Traits\HasTimestampsTrait;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Doctrine\ORM\Mapping\HasLifecycleCallbacks;

#[ORM\Entity, ORM\Table(name: 'categories')]
#[HasLifecycleCallbacks]  // Needed to make the 'onPrePersist' method work.
class Category
{
    use HasTimestampsTrait;

    public function __construct()
    {
        $this->transactions = new ArrayCollection();
    }

    #[ORM\Id]
    #[ORM\GeneratedValue()]
    #[ORM\Column(type: 'integer', options: ['unsigned' => true])]
    private int $id;

    #[ORM\Column(type: 'string')]
    private string $name;

    #[ORM\Column(type: 'datetime', name: 'created_at')]
    private \DateTime $createdAt;

    #[ORM\Column(type: 'datetime', name: 'updated_at')]
    private \DateTime $updatedAt;

    #[ORM\ManyToOne(targetEntity: User::class, inversedBy: 'categories')]
    private ?User $user;

    #[ORM\OneToMany(targetEntity: Transaction::class, mappedBy: 'categories')]
    private Collection $transactions;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getName(): ?string
    {
        return $this->name;
    }

    public function setName(string $name): self
    {
        $this->name = $name;

        return $this;
    }

    public function getCreatedAt(): ?\DateTimeInterface
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTimeInterface $createdAt): self
    {
        $this->createdAt = $createdAt;

        return $this;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    public function setUpdatedAt(\DateTimeInterface $updatedAt): self
    {
        $this->updatedAt = $updatedAt;

        return $this;
    }

    public function getUser(): ?User
    {
        return $this->user;
    }

    public function setUser(User $user): Category
    {
        $user->addCategory($this);

        $this->user = $user;

        return $this;
    }

    public function addTransaction(Transaction $transaction): Category
    {
        $this->transactions->add($transaction);

        return $this;
    }
}
















AO RECARREGARMOS A PAGE




E AO TENTARMOS CRIAR 1 NOVO 



CATEGORY,


CRIAMOS 1 CATEGORY NOVA E SOMOS REDIRECIONADOS 

COM SUCESSO...















--> CERTO... MAS A PAGE DE CATEGORIES 

AINDA NÃO ESTAMOS VENDO NADA SENDO DISPLAYED NA TELA...


NÃO TEMOS 

TABLE ALGUMA MOSTRANDO AS TABLES...








--> ISSO ESTÁ ASSIM PQ AINDA NÃO FIZEMOS PASS DOWN 

DAS CATEGORIES,

LÁ NO 'index' method,

no controller..





atualmente, o controller está assim:




    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'categories/index.twig');
    }










PRECISAMOS DO TERCEIRO PARAMETER,


QUE É O ARRAY DE KEYS QUE QUEREMOS PASSAR, COMO VALUES,


AO NOSSO TWIG TEMPLATE...










-> PARA ISSO, PODEMOS USAR O SERVICE DE 'CATEGORYSERVICE'


PARA 


RODAR 'getAll()'

ou qualquer method com nome similar,

para retornar todas nossas categories...





TIPO ASSIM:







    public function index(Request $request, Response $response): Response
    {

        return $this->twig->render(
            $response,
            'categories/index.twig',
            [
                'categories' => $this->category->getAll()
            ]
        );
    }










E ASSIM:




(CategoryService.PHP):


    public function getAll(): array
    {
        return $this->entityManager->getRepository(Category::class)->findAll();
    }














ISSO FEITO, RECARREGAMOS A PAGE, E AGORA FINALMENTE ENCONTRAMOS 

AS CATEGORIES NA PAGE...











--> MAS VC PODE ESTAR PENSANDO:


''HOW CAN TWIG TEMPLATE WORK WITH 
  THE ENTITY OBJECT?'' 








-> PQ É ISSO QUE ESTAMOS FAZENDO,


COM ESTE CÓDIGO:






'categories' => $this->categoryService->getAll()'....








-> ESTAMOS PASSANDO 1 COLLECTION/LIST 

DE 
ENTITY OBJECTS....





-> E ISSO, LÁ NO TWIG TEMPLATE,

É ACESSADO COM 



{{category.name}}

{{category.updated_at}},



ETC.... MAS O ESTRANHO É QUE 

ESSAS PROPERTIES SÃO 'PRIVATE'



LÁ NA ENTITY EM SI... 



É POR ISSO QUE QUEREMOS SABER

O QUE TORNA O TWIG CAPAZ DE ACESSAR ESSAS PROPERTIES,


MESMO ELAS SENDO PRIVATE, DENTRO DOS OBJECTS...















-> O PROFESSOR DIZ QUE O TWIG É ESPERTO O BASTANTE 

PARA SABER O QUE É SEU ACTUAL INTENT...









''WHAT IT DOES IS:


1) IT TRIES TO FIND IF THE NAME PROPERTY EXISTS,
    IN THE CLASS....




2) IF IT __EXISTS__ AND IS A PUBLIC PROPERTY,
    THEN IT WILL USE THAT....





3) IF IT DOESN'T EXIST,

IT WILL TRY TO EXECUTE THE '->getName()'

method, in this case...






--> OU SEJA,

ELE ESTÁ CHAMANDO O METHOD DE 'getName()',


sempre que 
a property de 'name' estiver como PRIVATE,

E NÃO PUBLIC... (e é exatamente esse o nosso caso, com a class de 'user' e a class de 'category', pq realmente temos GETTER METHODS)...















-> OK... MAIS 1 COISA QUE O PROFESSOR QUER 

APONTAR:







NO TEMPLATE index de 'category',



O PROFESSOR ESTÁ RODANDO 

AQUELE FILTER DE 

'date('m/d/Y g:i:A' )'



EM CIMA 

DE VALUES COMO 

'category.createdAt'...








ISSO É POSSÍVEL, NESSE CASO,

PQ 

os values realmente estão castados 

como 


DATETIMEOBJECTS,


O QUE DEIXA POSSÍVEL O APPLY DAQUELE FILTER

DO TWIG,
PARA TRANSFORMAR ESSES VALUES NOS FORMATOS QUE 


QUISERMOS...





EX:





<td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>













OK... MAS AGORA DEVEMOS IMPLEMENTAR A FUNCTIONALITY DE DELETE,


TIPO ASSIM,



LÁ EM 'CategoryService':










    public function delete(Category $category): void
    {
        $this->entityManager->remove($category);
        $this->entityManager->flush();
    }











NO CONTROLLER, TIPO ASSIM:








    public function delete(Request $request, Response $response): Response
    {  
         $categoryId = $request->getAttribute('categoryId');

        $this->categoryService->delete($categoryId);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }











MAS ISSO NÃO ESTÁ CERTO...



PQ O 'categoryId'

NÃO ESTÁ SENDO ARMAZENADO COMO ATTRIBUTE, DESSA FORMA,

NO NOSSO APP...









--> O PROFESSOR EXPLICA QUE PODEMOS DEIXAR 1 TERCEIRO ARGUMENT 


NA FUNCTION DE DELETE,


DE TIPO ''array'',





QUE VAMOS DEIXAR COMO '$args'...










-> USAREMOS ESSE '$args' PARA PEGAR 


OS PARAMS QUE ESTÃO/SERÃO PASSADOS 


NESSA ROUTE...










--> É ISSO QUE NOS DEIXA PEGAR OS PARAMETERS 
PASSADOS NA ROUTE, NA URL, ETC...






EX:





    public function delete(Request $request, Response $response, array $args): Response
    {  
         $categoryId = $request->getAttribute('categoryId');

        $this->categoryService->delete($categoryId);

        return $response->withHeader('Location', '/categories')->withStatus(302);
    }












    basta lembrar o route de '$categories->delete()',

    que tinha ESTE FORMATO:







        $categories->delete('{id}', [CategoriesController::class, 'delete']);



















-> ou seja, esse parameter de 'id'...








--> ESSE VALUE, DE 'ID',


DA CATEGORY,

NÃO VAI EXISTIR NO GET OU NO POST BODY...












-> PRECISAMOS EXTRAIR ISSO DOS ROUTE PARAMETERS...



E É JUSTAMENTE POR ISSO QUE O PROFESSOR 


COLOCOU ESSE TERCEIRO PARAMETER, DE NOME '$args',




QUE É UM ARRAY...












EXPLICAÇÃO DE COMO O DELETE REQUEST METHOD FUNCIONA:










'''BROWSER SUPPORTS GET AND POST REQUEST METHODS...''









--> É JUSTAMENTE POR ISSO QUE O HTML ESTÁ COM 1 

METHOD ATTRIBUTE DE 'post'...

EX:





        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>








ESTAMOS USANDO ESSE METHOD DE 'POST',



MAS ESTAMOS ACTUALLY ADICIONANDO 1 OUTRO 
INPUT FIELD, DE TIPO 'HIDDEN'


COM O NAME ATTRIBUTE DE '_METHOD',

e com um attribute de nome 'value',


com value de 'DELETE'...









O PROFESSOR TAMBÉM ADICIONOU 1 OUTRO MIDDLEWARE 


AO NOSSO ARQUIVO DE CONFIGURATION DE MIDDLEWARES,


CHAMADO DE 'MethodOverrideMiddleware'..







EX:




<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // Method Override Middleware:
    $app->add(\App\Middleware\MethodOverrideMiddleware::class);

    // CSRF fields in templates:
    $app->add(\App\Middleware\CsrfFieldsMiddleware::class);

    // CSRF protection:
    $app->add('csrf');

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Custom Old Form Data Middleware:
    $app->add(\App\Middleware\OldFormDataMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};



esse middleware serve para permitir que 


os methods sejam overriden.....





O CÓDIGO É TIPO ASSIM:


 








 <?php

declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class MethodOverrideMiddleware implements MiddlewareInterface
{
    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        $methodHeader = $request->getHeaderLine('X-Http-Method-Override');

        if ($methodHeader) {
            $request = $request->withMethod($methodHeader);
        } elseif (strtoupper($request->getMethod()) === 'POST') {
            $body = $request->getParsedBody();

            if (is_array($body) && !empty($body['_METHOD'])) {

                $request = $request->withMethod($body['_METHOD']);
            }

            if ($request->getBody->eof()) {
                $request->getBody->rewind();
            }
        }
        return $handler->handle($request);
    }
}













é por conta de eses middleware que conseguimos mappear 



'userId' 


a essa route específica, com o '/{id}'













--> O METHOD DE DELETE 


FICOU TIPO ASSIM:








    public function delete(int $id): void
    {
       $category = $this->entityManager->find(Category::class, $id);

        $this->entityManager->remove($category);
        $this->entityManager->flush();
    }












MAS NÃO TEMOS NENHUMA AUTH PARA O DELTE...








MAIS TARDE VEEREMOS MEDIDAS PARA AJUDAR COM ISSO...








--> RECARREGAMOS A PAGE,
E  AÍ 



EXAMINAMOS OS RESULTADOS...









-> ficamso com o  redirect de volta à page de 'categories'...








-> MAS A DATA NÃO FOI A PAGADA....






É PQ O PROFESSOR ESCREVEU DE RODAR '-flush()',



PARA APLICAR O RESULTADO NA DATABASE...






    public function delete(int $id): void
    {
       $category = $this->entityManager->find(Category::class, $id);

        $this->entityManager->remove($category);
        $this->entityManager->flush();
    }












--> mas o professor diz que 


o pattern de 


'' 

        $this->entityManager->remove($category);
        $this->entityManager->flush();

''


É RUIM...








mas pq isso é ruim?













--> É PQ ESTAMOS CHAMANDO OS METHODS DE 'GET' E 'POST'...




ESTAMOS CHAMANDO 'CREATE' E 'DELETE',


E AMBOS 

POSSUEM O CALL DE '$this->entityManager' ---> 











CERTO.... MAS DIGAMOS QUE TEMOS 1 IMPORTADOR 


QUE IMPORTA 1 MONTE DE CATEGORIES...






_-> 1 MONTE DE CATEGORIES,

E aí



TERÍAMOS DE RODAR 



OS CREATE EM 1 LOOP....









EM 1 LOOP,

NÃO SERIA BOM TER ESSE 'FLUSH'



NO FINAL DE 1 METHOD COMO 'create()',



ISSO PQ 




__ O 'persist()'


E

'flush()'

seriam chamados 1 milhao de vezes... e isso 

não é eficiente...









-> E É EXATAMENTE _POR ISSO__ 


QUE 

DEVEMOS SEMPRE 

TENTAR FOCAR NO CALL DO METHOD DE 'FLUSH'

APENAS 1 OU 2 VEZES 



DENTRO DE 1 MESMO HTTP REQUEST... 0 VEZES,

SE ESTIVERMOS MEXENDO COM ENTITIES...












-> MAS NO NOSSO CASE, AGORA,

SE FSSEMOS RODAR ESSE METHOD 



MÚLTIPLAS VEZES, FICARÍAMOS FLUSHING CADA VEZ QUE 
O METHOD DE 'Create' for chamado....




O MESMO OCORRE COM AS CATEGORIES...














--> HA MÚLTIPLAS MANEIRSA 




DE SE PROTEGER CONTRA CSRF....



















-. O PROFESSOR COLOCA 1 OUTRO ARGUMENT EM 'create',





TERCEIRO PARAMETER, 


algo como 1 boolean,


em que podemos check se é true.. aí vamos querer flushaer 
apenas se for true... 1 or 2 times....












no nosso caso, se fossemos chamar esse method múltiplas vezes,


vc ficaria com diversas calls 

de outros methods..














--> no momento, isso não é um problem,

mas pode ficar ruim se tivermos mais objects...







-----> o professor cria 1 novo method em 'categoryService',


de nome 'create',


que aí vai rodar 'persist' e flush'...








mas ele tira isso do código, pq ainda não 

é necessário...









-. oo professor vai usar esse código mais tarde, no curso...









-> AGORA TEMOS QUE ADICIONAR A FUNCTIONALITY DE EDIT...