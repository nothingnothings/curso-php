












-> cross-site scripting,

AKA 'XSS'...








-> VEREMOS ISSO, E VEREMOS COMO PROTEGER NOSSO SITE CONTRA ATAQUES DESSE TIPO...













XSS --> ''ARE A TYPE OF INJECTION, IN WHICH MALICIOUS 
            SCRIPTS ARE INJECTED INTO OTHERWISE BENING AND TRUSTED 
            WEBSITES... XSS ATTACKS OCCUR WHEN AN ATTACKER USES A WEB APP 
            TO SEND MALICIOUS CODE, GENERALLY IN THE FORM OF A BROWSER SIDE SCRIPT,
            TO A DIFFERENT END USER.''






        
    ''FLAWS THAT ALLOW THESE ATTACKS TO SUCCEED ARE QUITE WIDESPREAD, AND OCCUR ANYWHERE 
        A WEB APP USES INPUT FROM A USER WITHIN THE OUTPUT IT GENERATES WITHOUT VALIDATING 
        OR ENCODING IT...''

    



''AN ATTACKER CAN USE XSS TO SEND A MALICIOUS SCRIPT TO AN UNSUSPECTING USER.
    THE END USER'S BROWSER HAS NO WAY TO KNOW THAT THE SCRIPT SHOULD NOT BE TRUSTED,
    AND WILL EXECUTE THE SCRIPT.'''




    ''BECAUSE IT THINKS THE SCRIPT CAME FROM A TRUSTED SOURCE,

    THE MALICIOUS SCRIPT CAN ACCESS ANY COOKIES, SESSION TOKENS OR OTHER SENSITIVE 
    INFORMATION RETAINED BY THE BROWSER AND USED WITHIN THAT SITE. THESE SCRIPTS CAN EVEN 
    REWRITE THE CONTENT OF THE HTML PAGE...''











AGORA EXAMINAMOS NOSSA AUTHENTICATION FORM,


COMO 1 EXEMPLO, PARA ENTENDER O QUE É O XSS...









--> ANTES DE EXPLOITAR A VULNERABILIDADE XSS,
    O PROFESSOR QUER MENCIONAR QUE 



''I MADE A SMALL ADJUSTMENT, BEHIND THE SCENES''..









-> SE LOGGARMOS,
 

AGORA VEREMOS QUE O 'LOGGED-IN USER'S NAME'


vai aparecer DO LADO DO ÍCONE 

DA ACCOUNT, LÁ EM CIMA...








-> O PROFESSOR FEZ ISSO POR MEIO DO PASS DO USERNAME GLOBALMENTE,
    DA MESMA FORMA QUE O PROFESSOR FEZ COM OUTRAS COISAS COMO 
    'VALIDATION ERRORS',

    'CSRF' E ETC..
.








-> É NESTE TRECHO AQUI,

NO MIDDLEWARE DE 'AUTH':











<?php declare(strict_types=1);

namespace App\Middleware;

use App\Contracts\AuthInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Views\Twig;

class AuthMiddleware implements MiddlewareInterface
{
    public function __construct(private readonly ResponseFactoryInterface $responseFactory, private readonly AuthInterface $auth, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if ($user = $this->auth->user()) {

        $this->twig->getEnvironment()->addGlobal('auth', ['id' => $user->getId(), 'name' => $user->getName()]);

        return $handler->handle($request->withAttribute('user', $this->auth->user()));
        }
        
        return $this->responseFactory->createResponse()->withHeader('Location', '/login')->withStatus(302);
    }
}












ESTA LINHA:








       $this->twig->getEnvironment()->addGlobal('auth', ['id' => $user->getId(), 'name' => $user->getName()]);









ISSO VAI ADICIONAR ESSA KEY, DE 'auth',


GLOBALMENTE 

NOS NOSSOS TWIG TEMPLATES....




-> O PROFESSOR QUIS FAZER ISSO NO MIDDLEWARE DE AUTH 
PQ FAZ SENTIDO, 


PQ QUANDO O USER ESTÁ LOGGADO, FAZ SENTIDO 'PASS THE USER INFO GLOBALLY',
como 'user id' e o 'name'...







AÍ, LÁ NO TWIG TEMPLATE, BASTA ACESSAR E OUTPUTTAR ISSO DESTA FORMA:


        <div class="dropdown user-dropdown-menu" style="line-height: 0;">
                    <a href="#" class="text-decoration-none d-flex align-items-center" id="userDropDownMenu" data-bs-toggle="dropdown"
                       aria-expanded="false">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="icon">
                            <path fill-rule="evenodd" d="M7.5 6a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM3.751 20.105a8.25 8.25 0 0116.498 0 .75.75 0 01-.437.695A18.683 18.683 0 0112 22.5c-2.786 0-5.433-.608-7.812-1.7a.75.75 0 01-.437-.695z" clip-rule="evenodd" />
                        </svg>
                        <span>{{ auth.name }}</span>
                    </a>





















OK... AÍ VOLTAMOS E REGISTRAMOS 1 NOVO USER...









-> NA PAGE DE REGISTER, TEMOS ESTES FIELDS:





1) NAME 


2) EMAIL 


3) PASSWORD 


4) CONFIRM PASSWORD...










-> AS BOAS NOTÍCIAS, AQUI,

É QUE O USER PREENCHE ESSES 4 FIELDS,

CLICA EM 'REGISTER',


E AÍ 
1 ACCOUNT É CRIADA...






-> E AÍ O USER É AUTOMATICALLY LOGGED IN...









-> A MÁ NOTÍCIA É 

QUE 

O USER PODE INPUTTAR 

__ QUALQUER TIPO DE VALUE EM ALGUNS DESSES FIELDS... E 

ISSO PODE SER BEM HARMFUL...








--> COMO REGRA:



''NEVER TRUST USER INPUT,
ALWAYS ASSUME THE WORST...'''






-> 

-> PARA TESTAR ATAQUES MALICIOSOS, PODEMOS INPUTTAR AS INFOS ASSIM:



<span style="color: red;">Gio</span>

email: program+with+gio@gmail.com


PASSWORD: qualquer coisa...










-> certo...




apertamos enter -> somos redirecionados 



à home page, o user é registrado com sucesso,






MAS O NOSSO NAME FICARÁ DISPLAYADO EM RED...









-> SE INSPECIONAMOS O CONTEÚDO,


VEREMOS QUE 


O CONTEÚDO QUE FOI INSERIDO FOI 'RENDERED AND EXECUTED'...












-> ISSO PODE NÃO PARECER 1 BIG DEAL,

MAS O USER PODE INJETAR CÓDIGO MALICIOSO..









-> PODE INJETAR código que dispara requests 


ajax, código js que envia cookies ou outro tipo de sensitive data 


ao attacker...







também pode redirect o user, perform actions on behalf of the user,

ou deixar o site unusable..








-> as possibilidades são bem grandes...







-> há diferentes tipos de XSS ATTACKS..









-> o código também pode ser injetado em outros contextos,

como JAVASCRIPT, CSS, URL E ETC...











A SOLUÇÃO 


É:



''PROPERLY ESCAPE/ENCODE THE OUTPUT''...







OWASP.org --> MOSTRAM OS 10 MAIORES TIPOS DE VULNERABILITY...

















-> A BOA NOTÍCIA É QUE O TWIG JÁ NOS PROTEGE CONTRA ESSE TIPO DE ATTACK...








-> A SOLUTION DO TWIG É SUPER SIMPLES,



é o '{{}}'...








-> O BLADE TAMBÉM JÁ 




HANDLA ISSO PARA NÓS...









-> MAS SE VC USA 'PHP TEMPLATES',


OS NATIVOS,

VC 

PRECISA FAZER O ESCAPE DO OUTPUT POR CONTA PRÓPRIA....


E O PROFESSOR VAI NOS MOSTRAR COMO FAZER ISSO, DAQUI A POUCO..













-> O TWIG TEM ESCAPING ACTUALLY ENABLED POR DEFAULT...











-> O PROFESSOR DESABILITOU 

O ESCAPING 

APENAS 
DURANTE ESTA AULA,


PARA DEMONSTRAR COMO FUNCIONAM AS VULNERABILITIES...











-> PARA DESABILITAR O AUTOESCAPE,

BASTA PASSAR A OPTION DE 'autoescape' AO 'Twig::create()',

TIPO ASSIM:







    Twig::class => function (Config $config, ContainerInterface $container) {
        $twig = Twig::create(VIEW_PATH, [
            'cache' => STORAGE_PATH . '/cache/templates',
            'auto_reload' => AppEnvironment::isDevelopment($config->get('app_environment')),
            //'autoescape' => false,
        ]);

        $twig->addExtension(new IntlExtension());
        $twig->addExtension(new EntryFilesTwigExtension($container));
        $twig->addExtension(new AssetExtension($container->get('webpack_encore.packages')));

        return $twig;
    },














-> SE TIRAMOS ESSA OPTION,



O TWIG 

ACTUALLY FAZ ESCAPE DOS CHARS,


O QUE FAZ COM QUE ELES NÃO TENHAM EFEITOS NO SEU FRONTEND/NO CÓDIGO DO SEU APP...
















MAS COMO ISSO FUNCIONA? COMO O TWIG FAZ ISSO?












-> ELE FAZ ISSO POR MEIO DA FUNCTION ESPECIAL 




'htmlspecialchars()'... 







essa function faz esse escaping, além de ter mais algumas outras features...











-> ESSA FUNCTION BASICAMENTE CONVERTE 
    OS CARACTERES ESPECIAIS EM 'HTML ENTITIES'...







EX: < e > 



    SÃO CONSIDERADOS 'SPECIAL HTML CHARACTERS',

    E, POR ISSO, SEU USO É RESERVADO PARA APENAS O HTML...


    
    QUER DIZER QUE, QUANDO 1 OUTPUT É PROPERLY ESCAPED,
    ESSES CHARACTERS 

    SÃO 


    CONVERTIDOS 




    EM STRINGS COMO 


    '&amp;' 


    '&lt;',
     


     '&gt;',

     O QUE 



     FAZ COM QUE NÃO SEJAM 



     RENDERIZADOS COMO 'VALID HTML TAGS'...




    









-> O PROFESSOR COLOCA MAIS CÓDIGO MALICIOSO 


NO NAME 

FIELD...






EX:





<script>alert(1)</script>












-> COM ISSO, O JAVASCRIPT NÃO É EXECUTADO,


PQ ESTAMOS COM O ESCAPING ENABLED, POR TERMOS REMOVIDO AQUELA OPTION DE 

'autoescape: false'...










MAS SE DEIXAMOS ESSE 'autoescape: false' 






E 


SE DEIXAMOS 

AQUELE FILTER DE 


'{{ ... | raw }} '',






O CÓDIGO JAVASCRIPT INPUTTADO PELO USER REALMENTE SERÁ EXECUTADO... ( o que é péssimo)...















-> OK... MAS EXISTE 1 OUTRO FILTER, CHAMADO DE 'escape'...






{{ ... | escape }}







O QUE ESSE FILTER FAZ, NO CASO,


É O ESCAPE 



DO FIELD ESPECÍFICO EM QUE VC O COLOCOU...












-> E HÁ DIFERENTES ESTRATÉGIAS DE ESCAPE,

COM ESSE FILTER DE 'escape'...




EX:



html --> escapes a string for the HTML body context 

js --> escapes a string for Jvascript Context 



css -_> css context 


url --> uri or parameter contexts 



html_attr --> escapes a string for the HTML attribute context..













isso pq 

O OUTPUT PODE SER COLOCADO EM QUALQUER PARTE DO CÓDIGO... 


NÃO PRECISA SER OBRIGATORIAMENTE DENTRO DO CONTEXT DO HTML BODY...


PODE SER DENTRO DO CSS, DENTRO DO JAVASCRIPT, DENTRO DA URL (se vc está passing in algum tipo de user input dentro da url, por meio do $_GET superglobal... isso também poderia ficar vulnerável a CSRF ATTACKS)..













--> É POR ISSO QUE O USO DE TEMPLATING ENGINES É BOM, 
    PQ ELAS HANDLAM TUDO ISSO PARA NÓS,


    E PROVIDENCIAM OS FILTERS/FUNCTIONS/OPTIONS NECESSÁRIOS 
    PARA ESCAPE 


    TUDO DIREITINHO, DENTRO DO CONTEXTO DE CADA COISA...








--> CERTO... AGORA O PROFESSOR VAI MOSTRAR 1 EXEMPLO 

DE XSS DENTRO DE PHP TEMPLATES...



ISSO PQ NEM TODO MUNDO USA TWIG TEMPLATES... E É BOM 

SABER 

COMO FAZER O ESCAPING BÁSICO,



COM PHP TEMPLATES BÁSICOS...















-> PARA ISSO, O PROFESSOR VAI ATÉ O CONTROLLER DE 'HomeController',

E AÍ 



FAZ O INCLUDE DE UMA VIEWFILE DE NOME 'xss.php',

tipo assim:










<?php

declare(strict_types = 1);

namespace App\Controllers;

use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Slim\Views\Twig;

class HomeController
{
    public function __construct(private readonly Twig $twig)
    {
    }

    public function index(Request $request, Response $response): Response
    {

        include VIEW_PATH . '/xss.php';

        return $this->twig->render($response, 'dashboard.twig');
    }
}












_> MAS PRECISAMOS CRIAR ESSA FILE,

DENTRO DAS VIEWS...












-> DENTRO DELA, ESCREVEMOS TIPO ASSIM:





<h1>Hello <?= $name ?></h1>











E VAMOS PASSAR ESSA VARIABLE, DE DENTRO DO HOMECONTROLLER...











-> BASTA ESCREVER ASSIM:






 
 <?php

declare(strict_types = 1);

namespace App\Controllers;

use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Slim\Views\Twig;

class HomeController
{
    public function __construct(private readonly Twig $twig)
    {
    }

    public function index(Request $request, Response $response): Response
    {
        // User is the User entity object, so we can use its methods...
        $user = $request->getAttribute('user');
        
        include VIEW_PATH . '/xss.php';

        return $this->twig->render($response, 'dashboard.twig');
    }
}




















-> COM ISSO, FICAMOS COM ACESSO A ESSE 'user',



TIRADO DO REQUEST (estava armazenado como attribute)...










-> COM ISSO, PODEMOS CHAMAR '->getName()',

PARA OBTER O NAME DO USER...












-> LEMBRE-SE: O PROFESSOR HAVIA DEIXADO 1 VALUE DE 

USER COMO SENDO 



'<script>alert(1)</script>' 











-> QUANDO A PAGE É RENDERIZADA, AGORA,


O QUE VAI ACONTECER É ESTE OUTPUT:





<h1>Hello <script>alert(1)</script></h1>












E ISSO VAI REALMENTE EXECUTAR ESSE CÓDIGO JAVASCRIPT,

O QUE É TERRÍVEL...









ISSO ACONTECE/ESTÁ ACONTECENDO, NO CASO,


PQ 



ESSE CONTENT NÃO ESTÁ SENDO 'PROPERLY ESCAPED'... 












-> ISSO ESTÁ SENDO RENDERIZADO COMO 1 HTML ELEMENT,

E NÃO COMO TEXT... 








-> PARA FAZER ISSO NÃO RENDERIZAR COMO HTML,

PRECISAMOS USAR 



A FUNCTION DE 

'htmlspecialchars()'...






TIPO ASSIM:





<h1>Hello <?= htmlspecialchars($name, ENT_QUOTES) ?></h1>











-> o professor colocou uma flag de 'ENT_QUOTES',

esse segundo parameter...





-> O QUE ESSA FLAG FAZ É BASICAMENTE 

'HANDLE THE ENCODING AND ESCAPING FOR __ QUOTES...''









-> COMO TERCEIRO PARAMETER, TEMOS O PARAMETER OPCIONAL 

DE 'CHARACTER ENCODING'... --> SE VC NÃO SETTA NADA,
                                ELE USA 
                                O
                                 CHARSET DEFAULT...



                                 MAS O PROFESSOR GOSTA DE DEFINIR MANUALMENTE...





                                NO CASO, ELE DEIXA 1 ENCODING DE 
                                'UTF-8'...








EX:







<h1>Hello <?= htmlspecialchars($name, ENT_QUOTES, 'UTF-8') ?></h1>












VOLTAMOS AO BROWSER, RECARREGAMOS A PAGE,

E AÍ O CÓDIGO JS NÃO É MAIS EXECUTADO,

AGORA É RENDERIZADO 
APENAS COMO TEXT...













--> ALGUNS PODEM PERGUNTAR:




''WHY DON'T WE JUST
  SANTIIZE THE DATA BEFORE SAVING IT IN THE DATABASE?

  THAT WAY WE DON'T NEED TO WORRY ABOUT DISPLAYING THAT DATA...''







--> POR EXEMPLO, QUANDO REGISTRANDO O USER,


    NÃO SERIA MAIS SIMPLES SÓ STRIP ALL OF THE SPECIAL CHARACTERS,
    E ENTÃO 


    ARMAZENAR ISSO NA DATABASE?





--> E ESSA É UMA BOA IDEIA PARA ALGUMAS COISAS, COMO O FIELD DE NAME...
    PQ VC SEMPRE QUER TER VALID NAMES NO SEU APP...







--> MAS FAZER SANITIZE E STRIP  AWAY DE 
1 MONTE DE TIPOS DE SÍMBOLOS, DE VÁRIOS TIPOS DE TEXT,

TALVEZ N SEJA UMA IDEIA TAO BOA... --> PQ VC TALVEZ PRECISE 
                                        SALVAR A RAW DATA 

                                        NA DATABASE,

                                        PARA ENTÃO, MAIS TARDE,
                                        VOLTAR AO CONTENT, 

                                        PARA 'SEE WHAT WAS THE RAW TEXT THAT WAS SAVED'...






--> OUTRA:


''WHAT IF THE TEXT IS A COMMENT IN YOUR APP, IN SOME THREAD?''




--> ''AND, THEN, THE COMMENT MAY INCLUDE '>=' or '>' or '&', etc...''





_> SE VC SANITIZAR TUDO ISSO AÍ,

    PODE ACABAR MESSING UP 



    O USER TEXT,

    E AÍ OS USERS PODEM ACABAR FRUSTRADOS,

    PQ NÃO FOI ISSO QUE 

    ELES INPUTTARAM...

    (
        assim, vc deixa o app seguro,
        mas machuca a user experience...
    )








-> É POR ISSO QUE 
    SEMPRE É MAIS RECOMENDADO 


    ''SAVE THE DATA, THE WAY IT IS, IN THE DATABASE,
    UNLESS, OF COURSE, YOU NEED TO STRIP AWAY 
    SPECIAL CHARACTERS, ON SPECIAL CASES...


    BUT __ YOU __ SHOULD ALWAYs_  ESCAPE 

    __ THE CONTENT, IN THE MOMENTS YOU ARE DISPLAYING 

    THAT CONTENT/OUTPUT...''










CONFORME O PROFESSOR MENCIONOU,


'XSS'
PODE SER USADO DE DIFERENTES MANEIRAS...









EX:




''WE ARE DISPLAYING SOME USER INPUT IN HTML ATTRIBUTES...

MAYBE AS PART OF THE 'title' attribute of an html tag....''







EX:






<div class="dropdown user-dropdown-menu" title={{ auth.name }} />







--> O PROFESSOR DESABILITA O 'autoescape = true',





E 
AÍ 



ELE EXPLICA QUE O '<script>alert</script>'


REALMENTE SERÁ INJETADO DENTRO DAQUELE 'title=""' 

attribute..












-> PARA CONSEGUIR EXECUTAR 1 SCRIPT NESSE SLOT,


BASTA O ATTACKER 


ESCREVER 1 " adicional,

para aí fechar o title attribute 
e actually executar aquele script,
tipo assim:


<div class="dropdown user-dropdown-menu" title="" <script>alert</script> />













O PROFESSOR FAZ O REGISTER DE 1 NOVO USER,
USANDO AQUELE NAME COM SCRIPT...










E AÍ REALMENTE, O SCRIPT É DISPARADO....








QUER DIZED QUE O ESCAPE É REALMENTE SUPER IMPORTANTE..











--> O TWIG PROVIDENCIA, POR DEFAULT,


ESCAPING PARA BODY TAGS E 


ATTRIBUTES...




-> MAS HÁ ALGUMAS OPTIONS BEM ESPECÍFICAS,



COMO a de 


escape('html_attr'),



QUE PODE SER ESCRITA ASSIM:






                <div class="dropdown user-dropdown-menu" title="{{ auth.name | e('html_attr')}}">









->  'e()' é a mesma coisa que 'escape()'....






