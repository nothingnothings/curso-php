






AGORA VAMOS COMEÇAR A BUILDAR 


A USER AUTH BÁSICA,



USANDO SESSIONS...














--> O PROFESSOR PENSOU BASTANTE SOBRE ESSA PARTE,

    PQ O USER AUTH NÃO É TÃO FÁCIL DE FAZER, 


    QUANDO CONSTRUÍDA FROM SCRATCH...













--> O PROFESSOR PREFERE E RECOMENDA LIBRARIES E FRAMEWORKS 
    QUE JÁ OFERECEM 
    USER AUTH  OUT OF THE BOX,

    TIPO SYMFONY E LARAVEL...









-> ISSO PQ ELES SÃO BATTLE-TESTED E WELL-MAINTAINED...










-> MAS, PARA ESSE PROJECT,

VAMOS CONSTRUIR 



1 AUTHENTICATION BEM SIMPLES E SESSION-BASED..









-> FAREMOS ISSO PARA APRENDER E COMPREENDER COMO 
    AUTH SYSTEMS FUNCIONAM 

    POR TRÁS DAS SCENES, 

    QUANDO VC TIRA TODAS AS ABSTRACTIONS..












-> NOSSA IMPLEMENTAÇAÕ 
    NÃO TERÁ FANCY FEATURES 


    E DIFERENTES OPÇÕES DE SESSION STORAGE
    (
        com redis, databases ou memcached...
    )








--> POR ENQUANTO, USAREMOS AS NATIVE PHP SESSIONS,
    E O DEFAULT SESSION STORAGE DO PHP..











-> JÁ COBRIMOS BREVEMENTE SESSIONS E COOKIES 
    NA 2a session dessa série...










OK...










-> AGORA DEVEMOS COMEÇAR...



















PRIMEIRAMENTE,



''WE WANT TO DECIDE ON _ _ WHAT ROUTES WE WANT TO PROTECT''...











-> OU SEJA,

AS ROUTE GUARDS, AUTH GUARDS....









-> ISSO PQ NÓS QUEREMOS REDIRECIONAR O USER À LOGIN PAGE,
    SE ELE TENTA ACESSAR PAGES QUE 

    DEMANDAM AUTHENTICATION...









--> LÁ EM 'web.php',



A FILE DE 'ROUTES',

basicamente,


TEMOS ISTO:






<?php declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\HomeController;
use Slim\App;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index']);

    $app->get('/login', [AuthController::class, 'loginView']);
    $app->get('/register', [AuthController::class, 'registerView']);
    $app->post('/login', [AuthController::class, 'login']);
    $app->post('/register', [AuthController::class, 'register']);
    $app->post('/logout', [AuthController::class, 'logOut']);
};











essencialmente,



as routes que queremos proteger 


é 


 a PAGE DE 


 'dashboard' (


    esta route:

'''
        $app->get('/', [HomeController::class, 'index']);
'''
 )









 E 


 A PAGE DE LOGOUT:





    $app->post('/logout', [AuthController::class, 'logOut']);
















-> PQ ESSAS SÃO AS 2 PAGES QUE DEMANDAM QUE O USER ESTEJA AUTH....







-> AS PAGES DE LOGIN E REGISTER NÃO 

PEDEM QUE O USER ESTEJA AUTHENTICATED...


ACTUALLY, ELAS DEMANDAM QUE _ ELE ___ NÃO ESTEJA AUTHENTICATED,

PARA FUNCIONAREM...










 
-> PRECISAMOS ADICIONAR, PORTANTO,

ALGUM TIPO DE PROTECTION NESSAS 2 ROUTES...












-> O PROFESSOR CRIOU ESSAS ROUTES DE 'logIn' 

e 'logOut'
 
 por trás das cenas,

 TIPO ASSIM:











 <?php

declare(strict_types=1);

namespace App\Controllers;

use App\Entity\User;
use App\Exception\ValidationException;
use DateTime;
use Doctrine\ORM\EntityManager;
use Psr\Http\Message\ResponseInterface as Response;
use Slim\Psr7\Request as Request;
use Slim\Views\Twig;
use Valitron\Validator;

class AuthController
{

    public function __construct(private readonly Twig $twig, private readonly User $user, private readonly EntityManager $entityManager) {}

    public function loginView(Request $request, Response $response): Response
    {


        return $this->twig->render($response, 'auth/login.twig');
    }



    public function registerView(Request $request, Response $response): Response
    {

        return $this->twig->render($response, 'auth/register.twig');
    }


    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;


       $v = new Validator($data);

       $v->rule('required', ['name', 'email', 'password', 'confirmPassword']);
       $v->rule('email', 'email');
       $v->rule('equals', 'confirmPassword', 'password')->label('Confirm Password');

       $v->rule(
            function($field, $value, $params, $fields) use ($email) {
      
                $numberOfUsers = $this->entityManager->getRepository(User::class)->count(['email' => $value]);

                return !$numberOfUsers; // will return 'true' if the number is 0 (no users found), and 'false' if the number is 1 (fail-case, when a user already exists with the email).
            }, 'email'
        )->message("User with the given email address already exists.");


       if($v->validate()) {
           echo 'Yay! We are all good!';
       } else {
           throw new ValidationException($v->errors());
       }
       
       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);

       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;
    }


    public function logIn(Request $request, Response $response): Response
    {
        return $response->withHeader('Location', '/')->withStatus(302); 
    }


    public function logOut(Request $request, Response $response): Response
    {
        return $response->withHeader('Location', '/')->withStatus(302);
    }
}














PRECISAMOS PREENCHER ESSES METHODS COM LÓGICA...



-> NESSA AULA,

PREENCHEREMOS O METHOD DE 'login()'...

















-> OK...








A MANEIRA PELA QUAL PODEMOS PROTEGER NOSSAS ROUTES 
É POR MEIO 


DO __ INTRODUCE_ DE 1 MIDDLEWARE,


QUE VAI 



'''INTERCEPT THE REQUEST'''




E _ CHECAR SE O USER ESTÁ LOGGED IN...










-> SE O USER 
    NÃO ESTÁ LOGGED IN,


    ELE VAI REDIRECIONAR O USER À LOGIN PAGE,

    OU à OUTRO LOCAL..











-> CERTO...










-> O PROFESSOR EXPLICA QUE PODEMOS 

__REGISTRAR_ _ MIDDLEWARES


PARA _ ROUTES ESPECÍFICAS...









-> PARA FAZER ISSO,


BASTA 




ESCREVER '->add()'


DEPOIS DE 1 ROUTE,




COMO, POR EXEMPLO,

A ROUTE DE '/' (o dashboard):





    $app->get('/', [HomeController::class, 'index'])->add();













-> NESSA ROUTE, PODEMOS REGISTRAR O MIDDLEWARE 

PARA ELA, ESPECIFICAMENTE..








-> PARA ISSO, PODEMOS REGISTRAR 1 MIDDLEWARE 

COMO 'AuthMiddleware::class'...






-> OU, ENTÃO, ALGUM OUTRO MIDDLEWARE..








-> É POR ISSO QUE ESCREVEMOS ASSIM:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class AuthMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response {}
}

















OK... AÍ, DENTRO DO METHOD DE 'process()',

PRECISAMOS




___ CHECAr__ SE O USER ESTÁ LOGGED IN...











-> PARA FAZER ISSO, PODEMOS CHECAR 

ALGUM TIPO DE FLAG,

DENTRO DA SESSION,

QUE INDICARÁ
 
 SE O USER ESTÁ LOGGED IN OU NÃO...











'''WE CAN STORE SOMETHING LIKE THE USERID,
WHEN THE USER LOGS IN,

AND THEN CHECK IF THAT USER IS LOGGED IN,


IF THE SESSION CONTAINS THE USER ID'''...








-> É POR ISSO QUE PODEMOS ESCREVER ASSIM:





    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (empty($_SESSION['user'])) {
            return $this->responseFactory->createResponse()->withHeader('Location', '/login')->withStatus(302);
        }

        return $handler->handle($request);
    }













OU SEJA,


SE A SESSION NÃO CONTER ESSA KEY DE 'user',


PODEMOS CRIAR 1 NOVA RESPONSE,


E AÍ REDIRECIONAR O USER...









-> CASO CONTRÁRIO, VAMOS SIMPLESMENTE CONTINUAR HANDLANDO O REQUEST ($handler->handle)..












-> É CLARO QUE, PARA ISSO, PRECISAMOS DA 'ResponseFactoryInterface',

POR ISSO ESCREVEMOS ASSIM:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class AuthMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactoryInterface $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (empty($_SESSION['user'])) {
            return $this->responseFactory->createResponse()->withHeader('Location', '/login')->withStatus(302);
        }

        return $handler->handle($request);
    }
}



