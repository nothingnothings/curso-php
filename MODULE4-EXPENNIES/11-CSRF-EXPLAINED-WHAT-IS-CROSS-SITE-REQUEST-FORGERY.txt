







O QUE É CSRF/CRFX?








-> A DEFINIÇÃO FORMAL É 


''CSRF IS AN ATTACK THAT __FORCES__ AN 
END USER TO EXECUTE __ UNWANTED ACTIONS ON A 

WEB APPLICATION IN WHICH THEY ARE __CURRENTLY AUTHENTICATED...''




''WITH A LITTLE HELP OF SOCIAL ENGINEERING,
SUCH AS SENDING A __ LINK__ VIA EMAIL OR CHAT,
AN ATTACKER MAY __TRICK__ THE USERS 
OF A WEB APPLICATION INTO EXECUTING ACTIONS 
OF THE ATTACKER'S CHOOSING. IF THE VICTIM IS 
A NORMAL USER,
A SUCCESSFUL CSRF ATTACK CAN __fORCE__ THE USER 
TO PERFORM STATE CHANGING REQUESTS,
LIKE TRANSFERRING FUNDS, CHANGING THEIR EMAIL ADDRESS 
AND ETC... IF THE VICTIM IS AN ADMINISTRATIVE ACCOUNT,
CSRF CAN COMPROMISE THE ENTIRE APPLICATION''...



 







 -> RESUMINDO: CSRF ATTACK ENVOLVE 


 1 REQUEST QUE É FEITO 'IN THE USER'S BEHALF'...






 -> É UM 
 FORGE DO REQUEST,

 EM QUE O USER É 'TRICKED INTO MAKING THAT REQUEST'....





-> E 1 REQUEST PODE SER FORJADO DE MÚLTIPLAS MANEIRAS...









1a MANEIRA --> ''MAN IN THE MIDDLE (MITM) attack''...

                --> COM ESSE TIPO DE ATAQUE,

                1 CÓDIGO JAVASCRIPT É 

                INJETADO E ENTÃO EXECUTADO, DENTRO
                 
                 DO SITE, POR MEIO DE XSS VULNERABILITIES 
                 (1 request é feito de OUTRO SITE,
                 em que o request envia 1 request ao target 
                 website e etc... ) 










OK... MAS DEVEMOS FALAR SOBRE:



1) HOW EXACTLY IS A CSRF ATTACK 
    CONSTRUCTED 






2) HOW IT WORKS....














--> EXPLICAÇÃO:




''WHEN WE MAKE REQUESTS,
THE COOKIES ARE AUTOMATICALLY 
TRANSMITTED BY THE HEADER...''






''THE HEADER CAN ALSO INCLUDE THE SESSION COOKIES,
    WHICH COULD BE USED FOR AUTHENTICATION''...






-> ''IF THE USER IS ALREADY AUTHENTICATED 
AND THE FORGED REQUEST IS MADE, EVEN IF IT'S FROM 
ANOTHER WEBSITE, IT CAN __ CARRY OVER THE SAME SESSION 
COOKIE... WHICH LETS THE SERVER KNOW THAT THE 
REQUEST IS LEGIT, AND THAT THE USER IS AUTHENTICATED''....

















AGORA VEJA ESTE EXEMPLO:






1) USER LOGS INTO A WEBAPP... DOESN'T MATTER WHICH ONE....






2) ATTACK TRIES TO TRICK THE USER INTO CLICKING 
    A LINK THAT CONTAINS THE MALICIOUS SCRIPT 



(THEY DO THIS BY _ MAYBE SENDING AN EMAIL,
LIKE

'CLICK THIS AWESOME PICTURE', OU 'VC GANHOU 1 NOVO PLANETA')....

(attacker creates and sends an email with malicious link to the user)



3) User opens the email in the same browser as the target app



-> AÍ QUANDO VC CLICA NAQUELA COISA,

O SCRIPT MALICIOSO É EXECUTADO...









-> AÍ, QUANDO A PAGE É ABERTA,


O SCRIPT MALICIOSO É EXECUTADO....





--> E O HACKER NÃO PRECISA FORÇAR O USER A REALIZAR 
ACTION ALGUMA PARA EXECUTAR O SCRIPT... 
O QUE DISPARA O SCRIPT PODE SER ''A SIMPLE AJAX REQUEST'',
QUE É TRIGGADO NO MOMENTO EM QUE O USER ABRE A PÁGINA
 ESPECIFICADA, POR EXEMPLO....















-> certo...







MAS O QUE PODEMOS FAZER, PARA PREVENIR

 ESSES CSRF ATTACKS?











-> UMA MANEIRA USADA, BEM CLÁSSICA,


É 


USAR UMA


'Synchronizer Token Pattern'...













-> ESTUDAREMOS ESSE 
SYSTEM, NESTA AULA...











--> MAS COMO PODEMOS FAZER ISSO?










-> basicamente, 


''WE GENERATE A TOKEN,
 


ON THE SERVER.... WE GENERATE IT EITHER PER EACH REQUEST, OR 

PER PAGE LOAD''....








-> E 'PARA CADA REQUEST''
PODE SER


MEIO OVERKILL,


e pode ser annoying quando fazemos ajax requests (sistema de comments do stackoverflow, por exemplo),


pq aí sempre 

teremos/teríamos que primeiramente 'fetch the token from the server',


antes de fazer o request....




--> EM VEZ DISSO, O MELHOR É FAZER A TOKEN SER GENERATED 
    TODA VEZ QUE A PAGE 'INITIALLY LOADS'...


    aí, com isso, armazenamos/armazenaríamos essa token em 1 session,
    e então usar essa token em todos os subsequente requests, até o momento 
    em que a page é recarregada novamente, ou a token/session expira, ou algo do gênero...







---> CSRF TOKENS SEMPRE DEVEM SER:



A) Unique per user session 


B) Secret 


C) Unpredictable (large random value generated by a SECURE METHOD)...






md5 não é apropriado para isso, para o generate de essas tokens...










-> AÍ, COM ISSO, QUANDO FAZEMOS REQUESTS AO SERVER,


PRECISAMOS FAZER ATTACH DO GENERATED TOKEN,

COMO PARTE DO REQUEST BODY...







-> PARA ISSO, DEIXAMOS 1 INPUT FIELD COMO type=hidden,

nas nossas forms,


com 

algo como 



<input type="hidden" name="_token" value="asdasaihvjczxhjhajshkhad12329hdik">













-> OUTRA MANEIRA DE USAR CSRF TOKENS,

TRANSMITIR CSRF TOKENS,





É POR MEIO DO USO DE 


'CUSTOM HTTP REQUEST HEADERS',



SEMPRE QUE FAZEMOS AJAX CALLS...












-> FALAREMOS SOBRE ESSES REQUESTS, QUANDO ENTRARMOS NO ASSUNTO DO JAVASCRIPT...













-> OK... MAS QUANDO ESSE TOKEN É ENVIADO,


O SERVER PRECISA CHECAR E GARANTIR QUE ESSE TOKEN 

É ACTUALLY 1 VALID TOKEN,


POR MEIO DE VALIDATION... E PRECISAMOS FAZER ISSO EM REQUESTS 


QUE FAZEM CHANGES...

(

    OU SEJA,

    POST, PUT, DELETE E PATCH REQUESTS...
)














-> AGORA VC DEVE ESTAR SE PERGUNTANDO:




''MAS E QUANTO àS COOKIE OPTIONS DE 

samesite, secure e httponly? elas não protegem contra CSRF attacks?''













-> A RESPOSTA É:


SIM, ELAS AJUDAM MUITO...












-> ASSIM COM DISCUTIMOS NAS ÚLTIMAS AULAS,

    SOBRE SESSION HIJACKING E FIXATION,



    SESSION COOKIE OPTIONS COMO 'SAMESITE',

    'HTTPONLY' E 'SECURE' 


    ACTUALLY  

    ___ IMPEDEM ___ COOKIES DE SEREM ENVIADOS 

    'CROSS-SITE'...











--> SECURE --> FAZ COM QUE OS COOKIE SEJAM ENVIADOS APENAS SE A CONNECTION FOR SECURE...









-> HTTPONLY -> É DEFINIDO PARA FAZER COM QUE NÃO EXISTA NENHUM JAVASCRIPT ACCESS AOS COOKIE..








--> SAMESITE --> EXISTE PARA AJUDAR CONTRA CROSS-SITE PROTECTION...
















-> AINDA ASSIM, AS CSRF TOKENS DEVEM SER USADAS COMO 1 LAYER ADICIONAL 
    DE SEGURANÇA,
    JUNTO COM AS OPTIONS DE 'SAMESITE', HTTPONLY E 'SAMESITE',


    QUE AJUDAM CONTRA OUTROS TIPOS DE ATTACK...









-> PODEM EXISTIR EDGE CASES,

E É POR ISSO QUE 


TER AMBOS LAYERS É BEM RECOMENDADO...











-> A MAIOR PARTE DOS FRAMEWORKS 
    JÁ VÊM COM PROTEÇÃO CSRF....


    E, SE NÃO VÊM COM ISSO, 

    HÁ CENTENAS DE OPEN SOURCE LIBRARIES 

    QUE TE AJUDAM COM ISSO.... QUER DIZER QUE 
    VC NAO PRECISA FAZER ISSO FROM SCRATCH..










--> O SLIM FRAMEWORK, POR EXEMPLO,
    TEM 1 FIRST-PARTY PACKAGE 

    QUE TE AJUDA COM O GENERATE DE CSRF TOKENS 


    E COM O HANDLE DA PROTEÇÃO CSRF, COM APENAS 1 POUCO DE SETUP...










--> VEREMOS O SOURCE CODE, PARA ENTENDER COMO FUNCIONA...












-> PARA INSTALAR, BASTA RODAR ASSIM:







composer require slim/csrf










ok...







-> O PROFESSOR DIZ QUE DEVEMOS 



'REGISTER THE CSRF KEY ON OUR CONTAINER'',



isso para que consigamos referencia-la em qualquer outro lugar 


do código.... 











--> PARA ISSO, DEVEMOS IR ATÉ O CONTAINER...







-> VAMOS ATÉ 'container_bindings.php':







<?php declare(strict_types=1);

use App\Contracts\AuthInterface;
use App\Contracts\RequestServiceInterface;
use App\Contracts\RequestValidatorFactoryInterface;
use App\Contracts\SessionInterface;
use App\Contracts\UserProviderServiceInterface;
use App\DTOs\SessionConfig;
use App\Enum\AppEnvironment;
use App\Enum\SameSite;
use App\Factories\ValidatorFactory;
use App\Services\RequestService;
use App\Services\UserProviderService;
use App\Auth;
use App\Config;
use App\Session;
use DI\Container as DIContainer;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\ORMSetup;
use GuzzleHttp\Psr7\Request;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ServerRequestInterface;
use Slim\Factory\AppFactory;
use Slim\Views\Twig;
use Slim\App;
use Symfony\Bridge\Twig\Extension\AssetExtension;
use Symfony\Component\Asset\VersionStrategy\JsonManifestVersionStrategy;
use Symfony\Component\Asset\Package;
use Symfony\Component\Asset\Packages;
use Symfony\WebpackEncoreBundle\Asset\EntrypointLookup;
use Symfony\WebpackEncoreBundle\Asset\TagRenderer;
use Symfony\WebpackEncoreBundle\Twig\EntryFilesTwigExtension;
use Twig\Extra\Intl\IntlExtension;

use function DI\create;

return [
    // A little bit hacky...
    App::class => function (DIContainer $container) {
        AppFactory::setContainer($container);

        // Import router and middlewares
        $router = require CONFIG_PATH . '/routes/web.php';
        $addMiddlewares = require CONFIG_PATH . '/middleware.php';

        // Create app instance
        $app = AppFactory::create();

        // Register routes and middlewares to app
        $router($app);
        $addMiddlewares($app);

        // Return app itself
        return $app;
    },
    AuthInterface::class => fn(ContainerInterface $container) => $container->get(Auth::class),
    UserProviderServiceInterface::class => fn(ContainerInterface $container) => $container->get(UserProviderService::class),
    SessionInterface::class => fn(Config $config) => new Session(
        new SessionConfig(
            $config->get('session.name', ''),
            $config->get('session.secure', true),
            $config->get('session.httponly', true),
            SameSite::from($config->get('session.samesite', 'lax')),
            $config->get('session.flash_name', 'flash'),
        )
    ),
    RequestValidatorFactoryInterface::class => fn(ContainerInterface $container) => $container->get(ValidatorFactory::class),
    Config::class => create(Config::class)->constructor(require CONFIG_PATH . '/app.php'),
    EntityManager::class => fn(Config $config) => EntityManager::create(
        $config->get('doctrine.connection'),
        ORMSetup::createAttributeMetadataConfiguration(
            $config->get('doctrine.entity_dir'),
            $config->get('doctrine.dev_mode')
        )
    ),
    Twig::class => function (Config $config, ContainerInterface $container) {
        $twig = Twig::create(VIEW_PATH, [
            'cache' => STORAGE_PATH . '/cache/templates',
            'auto_reload' => AppEnvironment::isDevelopment($config->get('app_environment')),
        ]);

        $twig->addExtension(new IntlExtension());
        $twig->addExtension(new EntryFilesTwigExtension($container));
        $twig->addExtension(new AssetExtension($container->get('webpack_encore.packages')));

        return $twig;
    },
    ServerRequestInterface::class => function () {
        return (new \Slim\Psr7\Factory\ServerRequestFactory())->createServerRequest('GET', '/');
    },
    ResponseFactoryInterface::class => fn(App $app) => $app->getResponseFactory(),
    /** The following two bindings are needed for EntryFilesTwigExtension & AssetExtension to work for Twig */
    'webpack_encore.packages' => fn() => new Packages(
        new Package(new JsonManifestVersionStrategy(BUILD_PATH . '/manifest.json'))
    ),
    'webpack_encore.tag_renderer' => fn(ContainerInterface $container) => new TagRenderer(
        new EntrypointLookup(BUILD_PATH . '/entrypoints.json'),
        $container->get('webpack_encore.packages')
    ),
];


















-> DENTRO DAQUI, O PROFESSOR 



cria 1 nova section para o csrf,

com este código:










    // CSRF Protection:
    'csrf' => fn() => new \Slim\Csrf\Guard(),













DEPOIS DISSO,


PRECISAMOS PASSAR ALGUNS PARAMETERS DENTRO DE ESSE 'Guard()'...








O primeiro argument será uma 


'ResponseFactoryInterface'...









-> TEMOS ALGUNS OUTROS ARGUMENTS, TAMBÉM....










-> A ResponseFactoryInterface

JÁ TEMOS, LOGO ACIMA...







É POR ISSO QUE PODEMOS DEFINIR ISSO NA CLOSURE,

PARA AÍ  

UTILIZAR NO ARGUMENTO DA FUNCTION,


TIPO ASSIM:








    'csrf' => fn(ResponseFactoryInterface $responseFactory) => new \Slim\Csrf\Guard($responseFactory),














ok...









isso feito,


DEVEMOS INSPECIONAR A CLASS DE 'GUARD',

EXAMINAR QUAIS ARGUMENTS QUE DEVEM SER PASSADOS AO CONSTRUCTOR..








SÃO ELES:







    public function __construct(
        ResponseFactoryInterface $responseFactory,
        string $prefix = 'csrf',
        &$storage = null,
        ?callable $failureHandler = null,
        int $storageLimit = 200,
        int $strength = 16,
        bool $persistentTokenMode = false
    ) {












    
    OK... 


    O SEGUNDO ARGUMENT É 1 PREFIX... --> O PROFESSOR VAI DEIXAR COMO O DEFAULT...










-> 'Storage' -> TAMBÉM VAMOS DEIXAR COMO O DEFAULT, 'null'...   

                PODERÍAMOS DEFINIR 1 STORAGE CUSTOM, SE QUISÉSSEMOS...




-> A 'STORAGE' DEFAULT __ SERÁ A SESSION EM SI... E ISSO FUNCIONA,
PARA NÓS, PQ JÁ ESTAMOS USANDO 'SESSION-BASED AUTHENTICATION'...








O TERCEIRO PARAMETER É UM 'failureHandler',
que pode ser usado para ter 1 CUSTOM FAILURE HANDLER,

mas NÓS NÃO VAMOS FAZER ISSO POR ENQUANTO... 





POR ENQUANTO, VAMOS DEIXAR ISSO COMO O DEFAULT VALUE, 'null'..






--> STORAGE LIMIT --> 200 




-> STRENGTH -> 16 








storagelimit --> BASICAMENTE EXISTE PARA REMOVER TOKENS VELHAS 
                DA STORAGE, E É ÚTIL SE AS TOKENS SÃO GENERATED 

                'FOR EACH REQUEST' (pq aí é bom vc ter 1 limite para isso)...





strength --> é usada para 'TOKEN GENERATION LOGIC',
            que veremos logo...








'persistentTokenMode' -> É ALGO QUE DEVEMOS DEIXAR COMO 
                        'true',
                         em vez de manter como o default,
                         que é 'false'...



                         --> ISSO PQ, POR DEFAULT,
                         1 NOVA TOKEN É GERADA _ PARA CADA REQUEST...


                         E ESSA É UMA BOA MEDIDA DE SEGURANÇA,
                         MAS PODE SER ANNOYING AT TIMES, 
                         E NÃO É 100% OBRIGATÓRIA,
                         NÃO DEVEMOS TER PARA ABSOLUTAMENTE 
                         TODOS OS USE-CASES...



                        EM VEZ DISSO, TER 1 TOKEN QUE PERSISTA
                        AO LONGO DE TODO O REQUEST, POR USER SESSION,
                        JÁ É ENOUGH...





--> É POR ISSO QUE 
    O PROFESSOR USA 'NAMED ARGUMENT' syntax
    para definir 

    'persistentTokenMode' como sendo 'true',


    TIPO ASSIM:




    'csrf' => fn(ResponseFactoryInterface $responseFactory) => new \Slim\Csrf\Guard($responseFactory, persistentTokenMode: true),

















ok... 







Dentro de 'Guard'


temos 1 method de nome 'generate()',


que vai ACTUALLY criar a token...










--> ELE USA A FUNCTION DE 


'bin2hex()'

E 

A FUNCTION DE 'RANDOM_BYTES',

PARA CRIAR PSEUDO-RANDOM BYTES,


QUE ENTÃO 



SÃO CONVERTIDOS EM HEX,



COM A FUNCTION 'bin2hex()'...


EX:





    protected function createToken(): string
    {
        return bin2hex(random_bytes($this->strength));
    }











-> DEPOIS DISSO, 

TEMOS O METHOD DE 'generateToken()',

QUE BASICAMENTE 

CHAMA AQUELE METHOD DE 'createToken()' para criar a token:






    public function generateToken(): array
    {
        // Generate new CSRF token
        $name = uniqid($this->prefix);
        $value = $this->createToken();
        $this->saveTokenToStorage($name, $value);


        $this->keyPair = [
            $this->getTokenNameKey() => $name,
            $this->getTokenValueKey() => $this->maskToken($value)
        ];
        $this->enforceStorageLimit();
        return $this->keyPair;
    }





AÍ ELE UTILIZA O 'name',


que é usado para armazenar esse value, retornado de 'createToken()',

NA NOSSA STORAGE (que, no nosso caso, é a SESSION, o default)...













--> BASICAMENTE, CADA VEZ QUE 1 NOVA TOKEN É GENERATED,

ELA É ARMAZENADA COMO 1 NOVA KEY, DENTRO DA STORAGE DA SESSION...










-> ISSO FEITO, TEMOS 


ESTA PROPERTY DE 'keyPair',


QUE TEM 2 PROPERTIES:





        $this->keyPair = [
            $this->getTokenNameKey() => $name,
            $this->getTokenValueKey() => $this->maskToken($value)
        ];








    ESSAS PROPERTIES SÃO 


    'tokenNameKey' 

    e 'tokenValueKey'...








--> ESSAS 2 PROPERTIES TERÃO VALUES DE 'name' 



e 


O ACTUAL VALUE DA TOKEN...











-> MAIS PARA BAIXO, TEMOS O METHOD de 'validateToken',


QUE VALIDA AQUELA TOKEN,

USANDO 

A FUNCTION DE 



'hash_equals'...




ex:







    public function validateToken(string $name, string $value): bool
    {
        if (!isset($this->storage[$name])) {
            return false;
        }

        $token = $this->storage[$name];

        return hash_equals($token, $this->unmaskToken($value));
    }









novamente, ELE PROCURA A KEY NA STORAGE, COM 

'storage[$name]',


E AÍ 


RODA ESSA 'hash_equals' em cima de esse value...






-> ISSO QUER DIZER QUE PRECISAMOS ARMAZENAR/COLOCAR 

ESSES VALUES DE 'name' e 'value' em ALGUM LUGAR DE NOSSO FRONTEND,

PARA que eles consigam ser enviados no request que chega ao nosso backend...








-> ok... ISSO SERÁ ARMAZENADO PROVAVELMENTE NA FORM,

    PARA QUE SEJAM ENVIADOS JUNTO COM A POST DATA...








--> temos esses 2 methods, também:





    /**
     * @return string
     */
    public function getTokenNameKey(): string
    {
        return $this->prefix . '_name';
    }

    /**
     * @return string
     */
    public function getTokenValueKey(): string
    {
        return $this->prefix . '_value';
    }







_> OU SEJA,





ESSES VALUES SÃO APENAS OS VALUES PREFIXADOS DE 




'prefix', com então '_value' e '_key'...













CERTO...






MAS ENTAÕ O PROFESSOR NOS MOSTRA O METHOD DE 'process',

QUE É 

O 


MIDDLEWARE QUE 

ACTUALLY 

FAZ O VERIFY DA TOKEN:








  /**
     * @param  ServerRequestInterface  $request
     * @param  RequestHandlerInterface $handler
     *
     * @return ResponseInterface
     *
     * @throws Exception
     */
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $body = $request->getParsedBody();
        $name = null;
        $value = null;

        if (is_array($body)) {
            $name = $body[$this->getTokenNameKey()] ?? null;
            $value = $body[$this->getTokenValueKey()] ?? null;
        }

        if ($name === null && $value === null) {
            // DELETE request may not have a request body. Supply token by headers
            $name = $request->getHeader($this->getTokenNameKey())[0] ?? null;
            $value = $request->getHeader($this->getTokenValueKey())[0] ?? null;
        }

        if (in_array($request->getMethod(), ['POST', 'PUT', 'DELETE', 'PATCH'])) {
            $isValid = $this->validateToken((string) $name, (string) $value);
            if ($isValid && !$this->persistentTokenMode) {
                // successfully validated token, so delete it if not in persistentTokenMode
                $this->removeTokenFromStorage($name);
            }

            if ($name === null || $value === null || !$isValid) {
                $request = $this->appendNewTokenToRequest($request);
                return $this->handleFailure($request, $handler);
            }
        } else {
            // Method is GET/OPTIONS/HEAD/etc, so do not accept the token in the body of this request
            if ($name !== null) {
                $this->enforceStorageLimit();
                return $this->handleFailure($request, $handler);
            }
        }

        if (!$this->persistentTokenMode || !$this->loadLastKeyPair()) {
            $request = $this->appendNewTokenToRequest($request);
        } else {
            $pair = $this->loadLastKeyPair() ? $this->keyPair : $this->generateToken();
            $request = $this->appendTokenToRequest($request, $pair);
        }
        $this->enforceStorageLimit();

        return $handler->handle($request);
    }














ESSE METHOD EXISTE, AQUI,

PQ 





A CLASS DE 'GUARD'


É ACTUALLY 1 MIDDLEWARE...








-> ESTAMOS BINDANDO ISSO NOS BINDINGS DO CONTAINER,

SIM,


MAS 
TAMBÉM VAMOS ADICIONAR 


ESSE 'GUARD' COMO 1 DOS MIDDLEWARES DE NOSSO APP,


em 'middlewares.php'...









-> DENTRO DE PROCESS,

TEMOS:




        if (is_array($body)) {
            $name = $body[$this->getTokenNameKey()] ?? null;
            $value = $body[$this->getTokenValueKey()] ?? null;
        }









OU SEJA,



ELE __ PROCURA PELA TOKEN NAME E VALUE NO BODY DO REQUEST...







--> ISSO FEITO,


ELE CHECA O REQUEST METHOD, PARA GARANTIR QUE ELE

É UM DAQUELES SUPPORTED METHODS 


(

            if (in_array($request->getMethod(), ['POST', 'PUT', 'DELETE', 'PATCH'])) {

)








-> E SE O REQUEST METHOD É UM DESSES 4,



ELE FAZ O VALIDATE DA TOKEN...









ELE 




TEM A LÓGICA TAMBÉM PARA O QUE FAZER SE 'PERSISTENCE'

ESTÁ 

ENABLED OU DISABLED..





-> TAMBÉM HANDLA A REGENERATION DA TOKEN,

QUANDO NECESSÁRIO,

E CHAMA O METHOD DE 'failureHandler',



SE FALHA EM VERIFICAR:




        if (in_array($request->getMethod(), ['POST', 'PUT', 'DELETE', 'PATCH'])) {
            $isValid = $this->validateToken((string) $name, (string) $value);
            if ($isValid && !$this->persistentTokenMode) {
                // successfully validated token, so delete it if not in persistentTokenMode
                $this->removeTokenFromStorage($name);
            }

            if ($name === null || $value === null || !$isValid) {
                $request = $this->appendNewTokenToRequest($request);
                return $this->handleFailure($request, $handler);
            }
        } else {
            // Method is GET/OPTIONS/HEAD/etc, so do not accept the token in the body of this request
            if ($name !== null) {
                $this->enforceStorageLimit();
                return $this->handleFailure($request, $handler);
            }
        }










    -> SE 




TUDO ESTÁ GOOD,

ELE CONTINUA PROCESSANDO O REQUEST,

ENQUANTO 


FAZ COM QUE O TOKEN SEJA APENSO AO REQUEST,



COM ESTAS LINHAS:




        if (!$this->persistentTokenMode || !$this->loadLastKeyPair()) {
            $request = $this->appendNewTokenToRequest($request);
        } else {
            $pair = $this->loadLastKeyPair() ? $this->keyPair : $this->generateToken();
            $request = $this->appendTokenToRequest($request, $pair);
        }
        $this->enforceStorageLimit();














FINALMENTE, ELE PROSSEGUE COM O PASS DO REQUEST adiante,

como todo middleware comum faz:









        return $handler->handle($request);


















-> OK... AGORA PRECISAMOS REGISTRAR ISSO COMO 1 MIDDLEWARE...









-> BASTA ESCREVER ASSIM:







<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // CSRF protection:
    $app->add('csrf');

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Custom Old Form Data Middleware:
    $app->add(\App\Middleware\OldFormDataMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};













COM ISSO, ADICIONAMOS CSRF PROTECTION AO NOSSO APP...







MAS SE TENTAMOS FAZER LOGIN, AGORA,



_FICAREMOS COM 1 FAIL... ISSO É PQ NÃO COLOCAMOS NENHUM 

INPUT FIELD DE TYPE 'HIDDEN', COM O VALUE DA TOKEN, NESSA FORM...











--> se tentamos sign in,


ficamos com 




uma page de 

'Failed CSRF check!'











-> O PROFESSOR NÃO ADICIONOU NENHUM CUSTOM HANDLER,

MAS ISSO É POSSÍVEL...











-->




PARA CONSEGUIR DEFINIR 1 CUSTOM FAILURE HANDLER,


BASTA ESCREVER 



'$guard->setFailureHandler(function() {

})
'














OK.... AGORA PRECISAMOS ADICIONAR OS FIELDS NO FRONTEND,



PARA QUE SEJAM PASSADOS OS KEY-VALUE TOKEN VALUE PAIRS...









-> BASTA ESCREVER ASSIM:





<input type="hidden" name="<?= nameKey ?>" value="<?= valueKey ?>" />













TAMBÉM HÁ, NOS DOCS,




UMA PARTE SOBRE 'HOW TO ACCESS THE TOKEN PAIR IN TEMPLATES (twig, etc)...''

















-> COM ISSO, DEVEMOS COPIAR A ESTRUTURA DO CÓDIGO..












-> MAS O PROFESSOR PREFERE A SOLUTION COM MIDDLEWARES,


EM VEZ DE TER 1 CUSTOM EXTENSION...










-> PARA ISSO, VAMOS CRIAR 1 NOVO MIDDLEWARE, QUE VAI ADICIONAR 
ESSA DATA 

NOS CSRF FIELDS, MANUALMENTE..









-> PARA ISSO, CRIAMOS O MIDDLEWARE DE 'CsrfFieldsMiddleware',

TIPO ASSIM:










<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class CsrfFieldsMiddleware implements MiddlewareInterface
{
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        return $handler->handle($request);
    }
}
















-> aí, antes de 'return $handler',

PODEMOS 


'PASS DOWN THE 

CSRF FIELDS, AS GLOBAL PARAMETERS, TO THE TWIG TEMPLATES'...





-> OU SEJA, EXATAMENTE DA MESMA FORMA QUE FIZEMOS COM O 'ValidationErrorsMiddleware'..






tipo assim:



            $this->twig->getEnvironment()->addGlobal('errors', $errors); 








-> MAS FAREMOS ISSO COM O CSRF, TIPO ASSIM:








<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Views\Twig;

class CsrfFieldsMiddleware implements MiddlewareInterface
{

    public function __construct(private readonly Twig $twig) {}


    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $this->twig->getEnvironment()->addGlobal('csrf', $request->getAttribute('csrf'));

        return $handler->handle($request);
    }
}











certo... mas meu código ainda está meio errado...







-> não vou usar '$request->getAttribute()'...





E SIM USAREI ALGO TIPO ESTE TRECHO:





        // CSRF token name and value
        $csrfNameKey = $this->csrf->getTokenNameKey();
        $csrfValueKey = $this->csrf->getTokenValueKey();
        $csrfName = $this->csrf->getTokenName();
        $csrfValue = $this->csrf->getTokenValue();
        
        return [
            'csrf'   => [
                'keys' => [
                    'name'  => $csrfNameKey,
                    'value' => $csrfValueKey
                ],
                'name'  => $csrfName,
                'value' => $csrfValue
            ]
        ];









NA VERDADE, O PROFESSOR ADAPTA 1 POUCO ISSO,


TIRA O VALUE DE DENTRO DO ARRAY,



E AÍ ELE 

DIZ QUE PRECISAMOS DE 1 MANEIRA DE 'ACCESS THE CSRF INSTANCE' ($csrf)...














VAI FICANDO TIPO ASSIM:











    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {

        $csrfNameKey = $this->csrf->getTokenNameKey();
        $csrfValueKey = $this->csrf->getTokenValueKey();
        $csrfName = $this->csrf->getTokenName();
        $csrfValue = $this->csrf->getTokenValue();

        $csrf = [
                'keys' => [
                    'name'  => $csrfNameKey,
                    'value' => $csrfValueKey
                ],
                'name'  => $csrfName,
                'value' => $csrfValue
               ];


        // This is used to add the CSRF token to the template (to the form input fields)
        $this->twig->getEnvironment()->addGlobal('csrf', $csrf);

        return $handler->handle($request);
    }
















ok... mas SABEMOS QUE ESSE 'csrf' FOI ADICIONADO, COMO ENTRY,


ÀS NOSSAS CONTAINER_BINDINGS,




COMO VISTO AQUI:






    'csrf' => fn(ResponseFactoryInterface $responseFactory) => new \Slim\Csrf\Guard($responseFactory, persistentTokenMode: true),














-> ISSO QUER DIZER, EM OUTRAS PALAVRAS,


QUE PODEMOS ACESSAR ISSO DO CONTAINER....









-> PARA CONSEGUIR ISSO,


BASTA INJETAR A CONTAINER INTERFACE NESSA CLASS,
E AÍ USAR 

'$container->get('csrf')',



e aí 




USAR OS METHODS DE ESSE NEGÓCIO,


COMO 

'getTokenNameKey()'



e etc...








EX:












    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {

        $csrf = $this->container->get('csrf');

        $csrfNameKey = $csrf->getTokenNameKey();
        $csrfValueKey = $csrf->getTokenValueKey();
        $csrfName = $csrf->getTokenName();
        $csrfValue = $csrf->getTokenValue();

        $csrf = [
                'keys' => [
                    'name'  => $csrfNameKey,
                    'value' => $csrfValueKey
                ],
                'name'  => $csrfName,
                'value' => $csrfValue
               ];


        // This is used to add the CSRF token to the template (to the form input fields)
        $this->twig->getEnvironment()->addGlobal('csrf', $csrf);

        return $handler->handle($request);
    }












    OK... E ISSO REALMENTE VAI FUNCIONAR...










-> AGORA SÓ PRECISAMOS REGISTER ESSE MIDDLEWARE,


 E ADICIONAR OS FIELDS ADEQUADOS, NOS TEMPLATES.








TIPO ASSIM:







<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // CSRF protection:
    $app->add('csrf');

    // CSRF fields in templates:
    $app->add(\App\Middleware\CsrfFieldsMiddleware::class);

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Custom Old Form Data Middleware:
    $app->add(\App\Middleware\OldFormDataMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};












NOS TEMPLATES:





                     <form method="post" action="/login">
                                    <input type="hidden" name="{{csrf.keys.name}}" value="{{csrf.name}}">
                                    <input type="hidden" name="{{csrf.keys.value}}" value="{{csrf.value}}">
                                    <div class="form-outline form-white mb-4">
                                        <input type="email" name="email" class="form-control form-control-lg {{ errors.email ? 'is-invalid' : '' }}"
                                               value="{{ old.email }}"
                                               placeholder="Email"
                                               required />
                                        <div class="invalid-feedback">
                                            {{ errors.email | first }}
                                        </div>
                                    </div>
                                    <div class="form-outline form-white mb-1">
                                        <input type="password" name="password" class="form-control form-control-lg {{ errors.password ? 'is-invalid' : '' }}"
                                               placeholder="Password" required />
                                        <div class="invalid-feedback">
                                            {{ errors.password | first }}
                                        </div>
                                    </div>
                                 
                                    <p class="mb-4 text-end"><a class="text-secondary fw-semibold" href="#">Forgot
                                            password?</a></p>
                                    <button class="btn btn-primary bg-gradient text-white btn-lg px-5" type="submit">Log
                                        In
                                    </button>
                                </form>











PRECISAMOS FAZER A MESMA COISA NA PARTE DE 'register.twig':











							<form method="post" action="/register">
									<input type="hidden" name="{{csrf.keys.name}}" value="{{csrf.name}}">
									<input type="hidden" name="{{csrf.keys.value}}" value="{{csrf.value}}">
									<div class="form-outline form-white mb-4">
										<input type="text" name="name" class="form-control form-control-lg {{ errors.name ? 'is-invalid' : ''}}" placeholder="Name" value="{{old.name}}" required/>
										<div class="invalid-feedback">
											{{ errors.name | first }}
										</div>
									</div>

									<div class="form-outline form-white mb-4">
										<input type="email" name="email" class="form-control form-control-lg {{ errors.email ? 'is-invalid' : ''}}" placeholder="Email" value="{{old.email}}" required/>
										<div class="invalid-feedback">
											{{ errors.email | first }}
										</div>
									</div>

									<div class="form-outline form-white mb-4">
										<input type="password" name="password" class="form-control form-control-lg {{ errors.password ? 'is-invalid' : ''}}" placeholder="Password" required/>
										<div class="invalid-feedback">
											{{ errors.password | first }}
										</div>
									</div>

									<div class="form-outline form-white mb-5">
										<input type="password" name="confirmPassword" class="form-control form-control-lg {{ errors.confirmPassword ? 'is-invalid' : ''}}" placeholder="Confirm Password" required/>
										<div class="invalid-feedback">
											{{ errors.confirmPassword | first }}
										</div>
									</div>

									<button class="btn btn-primary bg-gradient text-white btn-lg px-5" type="submit">
										Register
									</button>
								</form>













    





OK... COM ISSO, FICAMOS COM A CSRF PROTECTION HABILITADA NO NOSSO APP...















OK... MAS O CHECK DE CSRF DEU FAIL, POR ALGUM MOTIVO...








-> deu fail pq 'value' não está sendo preenchido...












ISTO ESTÁ ERRADO:





    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {

        $csrf = $this->container->get('csrf');

        $csrfNameKey = $csrf->getTokenNameKey();
        $csrfValueKey = $csrf->getTokenValueKey();
        $csrfName = $csrf->getTokenName();
        $csrfValue = $csrf->getTokenValue();

        

        $csrfData = [
                'keys' => [
                    'name'  => $csrfNameKey,
                    'value' => $csrfValueKey
                ],
                'name'  => $csrfName,
                'value' => $csrfValue
               ];

        var_dump($csrfData);















ESTÁ FICANDO COM 1 PRINT DESSES:





/var/www/app/Middleware/CsrfFieldsMiddleware.php:39:
array (size=3)
  'keys' => 
    array (size=2)
      'name' => string 'csrf_name' (length=9)
      'value' => string 'csrf_value' (length=10)
  'name' => null
  'value' => null











  algo está errado, portanto...











O PROBLEMA ERA A ORDEM DOS MIDDLEWARES...



A ORDEM CORRETA É ESTA:







<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // CSRF fields in templates:
    $app->add(\App\Middleware\CsrfFieldsMiddleware::class);

    // CSRF protection:
    $app->add('csrf');

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Custom Old Form Data Middleware:
    $app->add(\App\Middleware\OldFormDataMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};









consertei 1 monte de errors...



O CSRF NAME E O CSRF VALUE ESTÃO SENDO PASSADOS COM SUCESSO...









-> MAS SE TENTAMOS FAZER LOGOUT,



NÃO CONSEGUIMOS, FICAMOS COM FAIL...









-> ISSO ACONTECEU PQ 
NÃO COLOCAMOS O INPUT DE TYPE HIDDEN COM O CSRF NA PARTE DE 'LOGOUT' DO CÓDIGO...










ok... PRECISAMOS DO FIELD DE 'csrf'...












-> O PROFESSOR DIZ QUE PODERÍAMOS COPIAR E COLAR 

AQUELE MESMO CÓDIGO LÁ....



DE 




''


                                    <input type="hidden" name="{{csrf.keys.name}}" value="{{csrf.name}}">
                                    <input type="hidden" name="{{csrf.keys.value}}" value="{{csrf.value}}">

                                

                                ''




MAS ISSO SERIA REPETIR MT CÓDIGO, AO LONGO DE NOSSO APP...









-> PARA FAZER ISSO FUNCIONAR SEM REPETIR MT COISA,

O PROFESSOR DECIDE USAR AQUELA ESCRITA DINAMICA,

TIPO ASSIM:




                 <form action="/logout" method="post">
                                {{ csrf.fields | raw }}
                                <button class="dropdown-item" href="#">Log Out</button>
                            </form>








--> QUEREMOS INJETAR ISSO AÍ...











-> PODEMOS FAZER ISSO FUNCIONAR,


BASTA EDITAR AQUELE MIDDLEWARE DE 'CsrfFieldsMiddleware',

 
 colocar o return de mais uma key,

 'fields',

 TIPO ASSIM:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Views\Twig;

class CsrfFieldsMiddleware implements MiddlewareInterface
{

    public function __construct(private readonly Twig $twig, private readonly ContainerInterface $container) {}


    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {

        $csrf = $this->container->get('csrf');

        $csrfNameKey = $csrf->getTokenNameKey();
        $csrfValueKey = $csrf->getTokenValueKey();
        $csrfName = $csrf->getTokenName();
        $csrfValue = $csrf->getTokenValue();

        

        $csrfData = [
                'keys' => [
                    'name'  => $csrfNameKey,
                    'value' => $csrfValueKey
                ],
                'name'  => $csrfName,
                'value' => $csrfValue,
                'fields' => <<<HTML
                            <input type="hidden" name="{$csrfNameKey}" value="$csrfName}">
                            <input type="hidden" name="{$csrfValueKey}" value="{$csrfValue}">
                            HTML   
               ];


        // This is used to add the CSRF token to the template (to the form input fields)
        $this->twig->getEnvironment()->addGlobal('csrf', $csrfData);

        return $handler->handle($request);
    }
}






CERTO...







ISSO FEITO,

PODEMOS UTILIZAR ESSA KEY NO NOSSO CÓDIGO, NOS TWIG TEMPLATES...














-> isso é bem conveniente...















-> PRECISAMOS DE ' | raw',



PARA DESABILITAR O ESCAPING DO TWIG...




---> O ESCAPING NOS PROTEGE CONTRA XSS,


MAS 



NÓS PODEMOS IMPEDIR ISSO COM 'raw',



QUE É O FILTER QUE DEIXA O CONTENT SER OUTPUTTADO EXATAMENTE COMO 


QUEREMOS... (que é o que vai fazer com que esses fields de csrf realmente sejam renderizados na page, dinamicamente)...












COM ISSO, NÓS:




1) APRENDEMOS O QUE É 'CSRF', E COMO NOS PROTEGER CONTRA ISSO...

    -> USAMOS O FIRST PARTY PACKAGE DO SLIM PARA IMPLEMENTAR A PROTECTION CONTRA CSRF..










-> NA PRÓXIMA AULA,

VAMOS APRENDER 1 TÓPICO RELACIONADO, QUE É 

'XSS', CROSS-SITE SCRIPTING...