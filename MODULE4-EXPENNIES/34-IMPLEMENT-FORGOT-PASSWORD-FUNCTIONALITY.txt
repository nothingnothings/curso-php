








--> NO ÚLTIMO EPISODIO,
O PROFESSOR DEU 1 TAREFA DE 




'''BUILD A SIMPLE PROFILE PAGE,
TO ALLOW THE USER TO UPDATE THE NAME 
AND THE 2FA FLAG'' 




--> O PROFESSOR IMPLEMENTOU ESSA PROFILE PAGE POR TRÁS DAS CENAS,

E VAI NOS MOSTRAR AS CHANGES DA UI...














--> O PROFESSOR RECOMENDA QUE COMPAREMOS 


OS BRANCHES, ENTRE O DELE E O MEU...










--> ASSIM QUE VC ESTIVER LOGGADO NO APP EXPENNIES,





CLIQUE NO ÍCONE DE 'USER',



PARA ENTÃO ENCONTRAR A OPTION DE 'PROFILE'...






--> NESSE NOVO LINK,


FICAMOS COM 1 NOVA PROFILE PAGE, BEM BÁSICA...











NELA, TEMOS:





1) O NAME DO USER 


2) O EMAIL DO USER (disabled, só para info... não vamos deixar o user updatar o email, pq isso é usado como username)

    COMO ISSO É USADO COMO USERNAME, TERÍAMOS DE TER MAIS USER VALIDATION E AUTHENTICATION, PARA GARANTIR QUE N EXISTAM EMAILS DUPLICADOS, NA DATABASE... MAS QUEREMOS DEIXAR AS COISAS SIMPLES, POR ISSO N MEXEREMOS NESSA PARTE.....




3) UM CHECKBOX DE 'ENABLE 2FA VIA EMAIL' 



4) UM BUTTON DE 'UPDATE PASSWORD',
    QUE PROVAVELMENTE NOS LEVA 

    AO MODAL DE 'RESET PASSWORD' 



5) UM BUTTON DE 'SAVE CHANGES'...















PODEMOS MUDAR O NAME E ENTÃO CLICAR EM 'ENABLE 2FA',

ANTES DE CLICAR NO BUTTON DE 'SAVE CHANGES'...






--> ISSO FAZ COM QUE APAREÇA 1 ALERT,


E AÍ 


OS VALUES SÃO ALTERADOS....









CERTO...











--> AQUELE BUTTON DE 'UPDATE PASSWORD'...



ELE FAZ APARECER 1 MODAL, QUE PEDE O 'CURRENT PASSWORD'

E ENTÃO TE DEIXA CRIAR 1 NOVO PASSWORD...










--> MAS ESSE MODAL/FEATURE AINDA NÃO FUNCIONA,


o professor quer que implementemos isso como próximo exercise...










-> MAS, ANTES DISSO,

DEVEMOS IMPLEMENTAR A FEATURE DE 'FORGOT PASSWORD',


QUE É OUTRA FEATURE...










-> PARA ISSO,
 


 VOLTAMOS à PAGE DE LOGIN...







 -> AGORA, SE CLICAMOS NO LINK DE 'FORGOT PASSWORD?',


 É RENDERIZADO 1 BASIC MODAL,



 COM 



 'FORGOT PASSWORD',


 em que colocamos nosso email address e aí clicamos em 'continue'...












O CÓDIGO É ESTE:








{% extends 'auth/layout.twig' %}

{% block stylesheets %}
    {{ parent() }}
    {{ encore_entry_link_tags('forgot_password') }}
{% endblock %}

{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('forgot_password') }}
{% endblock %}

{% block title %}Forgot Password{% endblock %}

{% block content %}
    <section class="vh-100 bg-primary bg-gradient">
        <div class="container py-5 h-100">
            <div class="row d-flex justify-content-center align-items-center h-100">
                <div class="col-12 col-md-8 col-lg-6 col-xl-5">
                    <div class="card bg-light text-white" style="border-radius: 1rem;">
                        <div class="card-body p-5 text-center">
                            <div class="mb-4">
                                <h2 class="fw-bold mb-4 text-uppercase text-primary d-flex justify-content-center align-items-center">
                                    <img src="{{ asset('build/images/logo.png') }}" width="64" height="64"
                                         alt="Expennies Logo" /> Forgot Password
                                </h2>
                                <div class="forgot-password-form">
                                    <div class="form-outline mb-4">
                                        <input type="email" name="email" class="form-control form-control-lg"
                                               placeholder="Enter your email address" required />
                                    </div>
                                    <button class="btn btn-primary bg-gradient text-white btn-lg px-5 forgot-password-btn"
                                            type="button">
                                        Continue
                                    </button>
                                </div>
                            </div>
                            <div>
                                <p class="mb-0 text-dark">
                                    Back to <a href="/login" class="text-primary fw-bold">Login</a>
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>
{% endblock %}

















CERTO... MAS PRECISAMOS DO CÓDIGO JAVASCRIPT DE ESSA PAGE...







O CÓDIGO JS:






import { post } from './ajax';

window.addEventListener('DOMContentLoaded', function () {
    const forgotPasswordBtn = document.querySelector('.forgot-password-btn')
    const resetPasswordBtn  = document.querySelector('.reset-password-btn')

    if (forgotPasswordBtn) {
        forgotPasswordBtn.addEventListener('click', function () {
            const form  = document.querySelector('.forgot-password-form')
            const email = form.querySelector('input[name="email"]').value

            post('/forgot-password', {email}, form).then(response => {
                if (response.ok) {
                    alert('An email with instructions to reset your password has been sent.');

                    window.location = '/login'
                }
            })
        })
    }





COISA BEM NORMAL...












AGORA FALTA A LÓGICA BACKEND...








explicação:









''WHENEVER USER ENTERS THE EMAIL ADDRESS

AND PRESSES CONTINUE,

WE SHOULD PREPARE AND SEND AN EMAIL 
 
 WITH INSTRUCTIONS ON HOW TO RESET THE PASSWORD''...









 --> O PROFESSOR ADICIONOU 2 ROUTES 



LÁ NO GROUP QUE TEM O MIDDLEWARE DE 'GuestMiddleware',


AS ROUTES DE 


(GET) forgot-password 

e 

(POST) forgot-password...








TIPO ASSIM:






    $app->group('', function (RouteCollectorProxy $guest) {
        $guest->get('/login', [AuthController::class, 'loginView']);
        $guest->get('/register', [AuthController::class, 'registerView']);
        $guest->post('/login', [AuthController::class, 'logIn']);
        $guest->post('/register', [AuthController::class, 'register']);
        $guest->post('/login/two-factor', [AuthController::class, 'twoFactorLogin']);
         $guest->get('/forgot-password', [PasswordResetController::class, 'showForgotPasswordForm']);
         $guest->post('/forgot-password', [PasswordResetController::class, 'handleForgotPasswordRequest']);













OK... MAS AINDA PRECISAMOS ESCREVER ESSE 


'PasswordResetController'...









VAI FICANDO TIPO ASSIM:







<?php declare(strict_types = 1);




namespace App\Controllers;


class PasswordResetController
{
    public function __construct()
    {
    }

    public function showForgotPasswordForm(Request $request, Response $response): Response
    {
        return $response->withStatus(200);
    }

    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
        return $response->withStatus(200);
    }
}   










o PROFESSOR explica 




''showForgotPasswordForm''


É O METHOD QUE ACTUALLY RENDERIZA AQUELA PAGE DE 


'forgot_password.twig',





E A ROUTE DE 'POST' 



É A QUE HANDLA O ACTUAL CREATE E SEND 


DO EMAIL COM INSTRUÇÕES, 



ASSIM QUE O INPUT DO EMAIL É PROVIDENCIADO...








-> NESSE CONTROLLER, TEMOS ESTA LÓGICA:








<?php declare(strict_types = 1);




namespace App\Controllers;

use App\Contracts\RequestValidatorFactoryInterface;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Slim\Views\Twig;

class PasswordResetController
{
    public function __construct(
        private readonly Twig $twig,
        private readonly RequestValidatorFactoryInterface $requestValidatorFactory
    )
    {
    }

    public function showForgotPasswordForm(Request $request, Response $response): Response
    {
        return $this->twig->render($response, 'auth/forgot_password.twig');
    }

    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
       
        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        return $response;
    }
}   










MAS PRECISAMOS DE ESSE REQUEST VALIDATOR,

QUE TERÁ APENAS 1 ÚNICO FIELD ('email')...







ELE FICA TIPO ASSIM:;







<?php declare(strict_types = 1);

namespace App\RequestValidators;

use App\Contracts\RequestValidatorInterface;
use App\Exception\ValidationException;
use Valitron\Validator;

class ForgotPasswordRequestValidator implements RequestValidatorInterface
{
    public function validate(array $data): array
    {
        $v = new Validator($data);

        $v->rule('required', ['email']);
        $v->rule('email', 'email');

        if (! $v->validate()) {
            throw new ValidationException($v->errors());
        }

        // Check if the email exists in the database
        if (! $this->userExists($data['email'])) {
            throw new ValidationException(['email' => ['The email does not exist in our records.']]);
        }

        return $data;
    }

    private function userExists(string $email): bool
    {
        // TODO
    }

}














OK... MAS A PRIMEIRA COISA QUE TEMOS QUE FAZER, DEPOIS DISSO,





É OBTER O USER, LÁ DO 'userProviderService' 


service,


com o method 'getByCredentials',

tipo ASSIM:









    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
       
        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByEmail($data['email']);

        return $response;
    }









EX:








    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
       
        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);

        return $response;
    }











no caso, passamos 'data' 

como argument justamente pq 'data' contém o EMAIL,



E O EMAIL JÁ BASTA PARA OBTER O USER, COM ESSE METHOD...









ISSO FEITO, PRECISAMOS CHECAR SE O USER FOI FOUND OU NÃO....








--> OK... MAS ESTA É A PARTE IMPORTANTE:




''IF THE USER REALLY CANNOT BE FOUND WITH THE GIVEN 
EMAIL, WE __ MUST _ NOT __ RESPOND TO THE REQUEST/USER 
SAYING THAT 

NO USER COULD BE FOUND WITH THE GIVEN EMAIL...



'''




NÃO PODEMOS FAZER ISSO PQ 




ISSO DEIXARIA NOSSO APP VULNERÁVEL 


A ATAQUES 




DE 

''USER ENUMERATION VULNERABILITY'' --> COM ISSO,
                                        O ATTACKER 
                                        PODE 

                                        'FIGURE OUT'

                                        QUAIS EMAILS 
                                        SÃO VALID E QUAIS 
                                        NÃO SÃO....





                            --> BASICMAENET,
                             ELES PODEM USAR ISSO PARA 

                             ''DETERMINE IF THE USER WHICH 
                             THEY ARE TRYING TO HACK INTO 
                             TRULY EXISTS WITHIN THE SYSTEM''....




-> E É JUSTAMEMNTE POR ISSO QUE DEVEMOS TENTAR 

ENVIAR MESSAGES GENÉRICAS,

COMO 

''WE-VE SENT THE PASSWORD RESET INSTRUCTIONS TO THE 
PROVIDED EMAIL'' (mesmo que isso seja 1 mentira)...








-> se o user for REALMENTE FOUND,

VAMOS ENVIAR 1 EMAIL...








caso contrário, ele não for found,

vamos apenas 'RETURN AN EMPTY RESPONSE'...







---> COM ISSO,

MESMO SE 1 USER COM ESSE EMAIL NÃO EXISITR,


VAMOS MOSTRAR A MESMA MENSAGEM/TELA GENÉRICA DE 


'THE PASSWORD RESET EMAIL WAS SENT',


AINDA QUE ISSO SEJA UMA MENTIRA...













-> 



if ($user) {
    //send email 
}









--> PARA MANDAR ESSE EMAIL,
O PROFESSOR VAI DUPLICAR O CÓDIGO DE 


'TwoFactorAuthEmail'...





ELE DUPLICA ESSE CÓDIGO,
E ENTÃO O ADAPTA 1 POUCO, TIPO ASSIM:






    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {

        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);

        if ($user) {
            //send email 
            $this->forgotPasswordEmail->send();
        }

        return $response;
    }















OK... 







MAS O PROFESSOR DIZ QUE DEVEMOS 
ADAPTAR ESSE METHOD DE SEND...






--> DE FORMA SIMILAR AO 2FA CODE,

    NÓS PRECISAMOS DE UM TOKEN,


    UMA TOKEN COM EXPIRATION TIME....



    ''THIS WAY, WE CAN GENERATE AND SIGN 
    A SIGNED URL,
    AND THEN INCLUDE THE TOKEN WITHIN IT''...










--> PARA ISSO, O PROFESSOR PREFERE 1 
TABLE SEPARADA PARA OS 'PASSWORD RESET',


TUDO PARA TER MELHOR AUDITING E FLEXIBILITY (mesma 
razão da table separada de 2FA codes.... aquela table,
de 'UserLoginCodes')











--> NO METHOD DE 'send()',




O PROFESSOR QUER PASSAR, COMO PARAMETER,


A ENTITY DE 'PasswordReset'...






TIPO ASSIM:











<?php

declare(strict_types=1);

namespace App\Mail;

use App\Config;
use App\Entity\ForgotPassword;
use App\Entity\UserLoginCode;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\BodyRendererInterface;

class ForgotPasswordEmail
{
    public function __construct(
        private readonly Config $config,
        private readonly MailerInterface $mailer,
        private readonly BodyRendererInterface $renderer
    ) {}

    public function send(ForgotPassword $forgotPassword): void
    {

        $from = $this->config->get('mailer.from');
        $to = $forgotPassword->getEmail();
        $subject = 'Your Expennies Password Reset Code';

        // * Send email to user.
        $message = (new TemplatedEmail())
            ->from($from)
            ->to($to)
            ->subject($subject)
            ->htmlTemplate('/emails/forgot_password.html.twig')
            ->context([
                'code' => $forgotPassword->getCode(),
            ]);


        $this->renderer->render($message);

        $this->mailer->send($message);
    }
}












OU SEJA, 

VAMOS OBTER O VALUE DE 'EMAIL',

de essa entity 'PasswordReset'...










-> FAREMOS ISSO PARA CONSEGUIRMOS RELACIONAR 
    O PASSWORDRESET COM QUALQUER EMAIL...









--> FAZEMOS ISSO SEM USARMOS A RELATION DE '->getUser()',


    PQ NÃO QUEREMOS ASSOCIAR OS PASSWORD RESETS COM 

    QUAISQUER USERS, E SIM QUEREMOS APENAS ASSOCIAR COM 
    OS EMAILS...








-->  CERTO... DEPOIS DISSO, PRECISAMOS GERAR UMA 

'SIGNED URL'...










--> PODEMOS COPIAR O CÓDIGO 


    DE GERAÇÃO DO ACTIVATIONLINK,


    DO 'SignupEmail',


    E COLAR NESSE NOVO METHOD DE 'send()',

    TIPO ASSIM:








   public function __construct(
        private readonly Config $config,
        private readonly MailerInterface $mailer,
        private readonly BodyRendererInterface $renderer,
        private readonly SignedUrl $signedUrl
    ) {}

    public function send(PasswordReset $passwordReset): void
    {

        // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $from = $this->config->get('mailer.from');
        $to = $passwordReset->getEmail();
        $subject = 'Your Expennies Password Reset Instructions';
        $expirationDate = $passwordReset->getExpiration();
        $routeParams = ['token' => $passwordReset->getToken()];
        $resetLink = $this->signedUrl->fromRoute('password-reset', $routeParams, $expirationDate);


        // * Send email to user.
        $message = (new TemplatedEmail())
            ->from($from)
            ->to($to)
            ->subject($subject)
            ->htmlTemplate('/emails/password_reset.html.twig')
            ->context([
                'code' => $passwordReset->getCode(),
            ]);


        $this->renderer->render($message);

        $this->mailer->send($message);
    }











    O TEMPLATE DE PASSWORD-RESET SERÁ ESTE;





Hello,
<br/>
<br/>
You recently requested to reset your password for your Expennies account. To do so, please click the link below:
<br/>
<a href="{{ resetLink }}" target="_blank">Reset Password</a>
<br/>
This link will expire in 30 minutes, for your security. If you did not request a password reset, please ignore this email.
<br/>
<br/>
Thank you,
<br/>
Expennies Team













-> E PASSAREMOS ESSE 'resetLink' como placeholder



do method de 'send',

tipo assim:








    public function send(PasswordReset $passwordReset): void
    {

        // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $from = $this->config->get('mailer.from');
        $to = $passwordReset->getEmail();
        $subject = 'Your Expennies Password Reset Instructions';
        $expirationDate = $passwordReset->getExpiration();
        $routeParams = ['token' => $passwordReset->getToken()];
        $resetLink = $this->signedUrl->fromRoute('password-reset', $routeParams, $expirationDate);


        // * Send email to user.
        $message = (new TemplatedEmail())
            ->from($from)
            ->to($to)
            ->subject($subject)
            ->htmlTemplate('/emails/password_reset.html.twig')
            ->context([
                'resetLink' => $resetLink,
            ]);


        $this->renderer->render($message);

        $this->mailer->send($message);
    }













MAS PARA FAZER ISSO, PRECISAMOS IMPLEMENTAR 


A ENTIDADE DE 'PasswordReset'...






TIPO ASSIM:





<?php

declare(strict_types=1);

namespace App\Entity;

use DateTime;
use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\Entity;
use Doctrine\ORM\Mapping\GeneratedValue;
use Doctrine\ORM\Mapping\Id;
use Doctrine\ORM\Mapping\Table;

#[Entity, Table(name: 'password_resets')]
class PasswordReset
{
    #[Id, Column(options: ['unsigned' => true]), GeneratedValue]
    private int $id;

    #[Column(type: 'string', length: 255)]
    private string $email;

    #[Column(type: 'string', length: 255)]
    private string $token;

    #[Column(type: 'datetime')]
    private DateTime $expiration;

    public function getEmail(): string
    {
        return $this->email;
    }

    public function getToken(): string
    {
        return $this->token;
    }
}









CERTO... MAS PRECISAMOS DE MAIS METHODS...







FICOU TIPO ASSIM:







<?php

declare(strict_types=1);

namespace App\Entity;

use App\Entity\Traits\HasTimestamps;
use DateTime;
use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\Entity;
use Doctrine\ORM\Mapping\GeneratedValue;
use Doctrine\ORM\Mapping\HasLifecycleCallbacks;
use Doctrine\ORM\Mapping\Id;
use Doctrine\ORM\Mapping\Table;

#[HasLifecycleCallbacks]
#[Entity, Table(name: 'password_resets')]
class PasswordReset
{
    use HasTimestamps;


    #[Id, Column(options: ['unsigned' => true]), GeneratedValue]
    private int $id;

    #[Column(type: 'string', length: 255)]
    private string $email;

    #[Column(name: 'is_active', options: ['default' => true])]
    private bool $isActive;

    #[Column(type: 'datetime')]
    private DateTime $expiration;

    #[Column(type: 'string', length: 255, unique: true)]
    private string $token;


    public function __construct()
    {
        $this->isActive = true;
    }

    public function getId(): int
    {
        return $this->id;
    }

    public function getEmail(): string
    {
        return $this->email;
    }

    public function setEmail(): string
    {
        return $this->email;
    }

    public function getIsActive(): bool
    {
        return $this->isActive;
    }

    public function setIsActive(bool $isActive): PasswordReset
    {
        $this->isActive = $isActive;

        return $this;
    }

    public function getExpiration(): DateTime
    {
        return $this->expiration;
    }

    public function setExpiration(DateTime $expiration): PasswordReset
    {
        $this->expiration = $expiration;

        return $this;
    }

    public function getToken(): string
    {
        return $this->token;
    }

    public function setToken(string $token): PasswordReset
    {
        $this->token = $token;

        return $this;
    }
}
 





 VAI FICANDO TIPO ASSIM:









     public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {

        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);

        $passwordReset = new PasswordReset();

        $passwordReset->setEmail($data['email']);
        $passwordReset->setExpiration(new DateTime('+30 minutes'));
        $passwordReset->setToken(sha1(random_bytes(10)));

        

        if ($user) {
            //send email 
            $this->forgotPasswordEmail->send();
        }

        return $response;
    }










    MAS VAMOS PROVAVELMENTE PRECISAR 



    DE 1 SERVICE CLASS,

    ALGO COMO 'PasswordResetService.php'...











--> FICARÁ TIPO ASSIM:


<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\EntityManagerServiceInterface;
use App\Entity\PasswordReset;
use App\Entity\User;
use Doctrine\ORM\EntityManagerInterface;

class PasswordResetService extends EntityManagerService
{



    public function __construct(private readonly EntityManagerServiceInterface $entityManagerService) {}



    // * Generates the 2FA code for the user
    public function generate(User $user): PasswordReset
    {

        $passwordReset = new PasswordReset();


        $passwordReset->setEmail($user->getEmail());
        $passwordReset->setExpiration(new \DateTime('+30 minutes'));
        $passwordReset->setToken(sha1(random_bytes(10)));

        $this->entityManagerService->sync($passwordReset);

        return $passwordReset;
    }
}









MAS FAZEMOS ALGUNS AJUSTES...


O ÚNICO PARAMETER A SER ACEITO SERÁ 'EMAIL',

E NÃO A USER ENTITY... ter a user entity inteira 

é overkill...







EX:






    // * Generates the 2FA code for the user
    public function generate(string $email): PasswordReset
    {

        $passwordReset = new PasswordReset();


        $passwordReset->setEmail($email);
        $passwordReset->setExpiration(new \DateTime('+30 minutes'));
        $passwordReset->setToken(sha1(random_bytes(10)));

        $this->entityManagerService->sync($passwordReset);

        return $passwordReset;
    }











CERTO... 







MAS TEMOS QUE FAZER O GENERATE DE 1 TOKEN...









''TO GENERATE THE TOKEN,    
    WE ARE GONNA USE random_bytes(),
    of 32... and then we are going to apply 
    'bin2hex'...





EX:



ISTO:




  // * Generates the 2FA code for the user
    public function generate(string $email): PasswordReset
    {

        $passwordReset = new PasswordReset();
        $token = bin2hex(random_bytes(32));


        $passwordReset->setEmail($email);
        $passwordReset->setExpiration(new \DateTime('+30 minutes'));
        $passwordReset->setToken($token);

        $this->entityManagerService->sync($passwordReset);

        return $passwordReset;
    }





E ISTO:





    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {

        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);
        $email = $data['email'];

        $resetPassword = $this->passwordResetService->generate($email);

        if ($user) {
            //send email 
            $this->forgotPasswordEmail->send($resetPassword);
        }

        return $response;
    }










MAS O PROFESSOR ESCREVE MELHOR, DESSA FORMA:












    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {

        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);
        $email = $data['email'];

        if ($user) {
            
            $resetPassword = $this->passwordResetService->generate($email);

            //send email 
            $this->forgotPasswordEmail->send($resetPassword);
        }

        return $response;
    }












    CERTO...







FINALMENTE,



PRECISAMOS DE ESSA ROUTE DE 'password-reset',

TUDO PARA CONSEGUIRMOS 

FAZER GENERATE DA SIGNED URL...






-> PARA ISSO,

CRIAMOS UMA ROUTE DE 'reset-password'...


E ELA TERÁ UM QUERY PARAM DE '{token}'...




ESSA ROUTE VAI FAZER O RENDER DA FORM DE 


'Reset Password',




COM ISTO:






        $guest->get('/reset-password/{token}', [PasswordResetController::class, 'showResetPasswordForm']);










-> DEPOIS DISSO, O PROFESSOR COLOCA 1 NAME NESSA ROUTE,



COM 


'->setName('password-reset)'...









DEPOIS DISSO, O PROFESSOR ADICIONA O 


MIDDLEWARE DE VALIDATION DA SIGNATURE,

COM 'VAlidateSignatureMiddleware'...




TIPO ASSIM:






        $guest->get('/reset-password/{token}', [PasswordResetController::class, 'showResetPasswordForm'])
            ->setName('password-reset')
            ->add(ValidateSignatureMiddleware::class);










    



O PROFESSOR ENTÃO CRIA ESSE METHOD,


DE 'showResetPasswordForm',


LÁ NO CONTROLLER DE 'PasswordResetController':







    public function showResetPasswordForm(Request $request, Response $response): Response
    {
        return $this->twig->render($response, 'auth/reset_password.twig');
    }








ok... mas só isso não basta...








'''HERE, WE NEED TO FIND 
    THE PASSWORD RESET RECORD,

    USING THE TOKEN THAT IS PASSED INTO THE ROUTE''...






-> É POR ISSO QUE VAMOS PRECISAR DE 

'array $args',



e aí 


VAMOS PEGAR A TOKEN,

COM '$args['token']'...







EX:





    public function showResetPasswordForm(Request $request, Response $response, array $args): Response
    {   
        $token = $args['token'];


        return $this->twig->render($response, 'auth/reset_password.twig');
    }











CERTO....








ISSO FEITO, VAMOS PROCURAR ESSE RESET PASSWORD RECORD,


COM ESSE TOKEN...








--> O PROFESSOR ADICIONA 1 NOVO METHOD 


LÁ NO SERVICE DE 'PasswordResetService',




PARA ENCONTRAR O RECORD BY TOKEN...







--> TIPO ALGO ASSIM:





$passwordReset = $this->passwordResetService->findByToken($token);













ASSIM:






    public function showResetPasswordForm(Request $request, Response $response, array $args): Response
    {
        $token = $args['token'];

        $passwordReset = $this->passwordResetService->findByToken($token);

        if (! $passwordReset) {
            return $response->withHeader('Location', '/login')->withStatus(302);
        }

        return $this->twig->render($response, 'auth/reset_password.twig');
    }








OU SEJA,

SE ESSE PASSWORDRESET RECORD N FOR ENCONTRADO,

VAMOS REDIRECT O USER À HOME PAGE, de login..









--> CASO CONTRÁRIO,



VAMOS 'SHOW THE MODAL TO THE USER,
WHERE HE WILL BE ABLE TO UPDATE THE PASSWORD''..







--> fazemos isso com ESTE CÓDIGO:





    public function showResetPasswordForm(Request $request, Response $response, array $args): Response
    {
        $token = $args['token'];

        $passwordReset = $this->passwordResetService->findByToken($token);

        if (! $passwordReset) {
            return $response->withHeader('Location', '/login')->withStatus(302);
        }

        return $this->twig->render($response, 'auth/reset_password.twig');
    }








    ESSE TEMPLATE NO CASO,

    TEM ESTE FORMATO:






    {% extends 'auth/layout.twig' %}

{% block stylesheets %}
	{{ parent() }}
	{{ encore_entry_link_tags('forgot_password') }}
{% endblock %}

{% block javascripts %}
	{{ parent() }}
	{{ encore_entry_script_tags('forgot_password') }}
{% endblock %}

{% block title %}Reset Password
{% endblock %}

{% block content %}
	<section class="vh-100 bg-primary bg-gradient">
		<div class="container py-5 h-100">
			<div class="row d-flex justify-content-center align-items-center h-100">
				<div class="col-12 col-md-8 col-lg-6 col-xl-5">
					<div class="card bg-light text-white" style="border-radius: 1rem;">
						<div class="card-body p-5 text-center">
							<div class="mb-4">
								<h2 class="fw-bold mb-5 text-uppercase text-primary d-flex justify-content-center align-items-center">
									<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
									Reset Password
								</h2>
								<form class="reset-password-form" method="post" action="/reset-password/{{ token }}">
									<div class="form-outline form-white mb-4">
										<input type="password" name="password" required class="form-control form-control-lg" placeholder="Enter New Password"/>
									</div>
									<div class="form-outline form-white mb-5">
										<input type="password" name="confirmPassword" required class="form-control form-control-lg" placeholder="Confirm New Password"/>
									</div>
									<button class="btn btn-primary bg-gradient text-white btn-lg px-5 reset-password-btn" type="button">
										Update
									</button>
								</form>
							</div>
							<div>
								<p class="mb-0 text-dark">
									Back to
									<a href="/login" class="text-primary fw-bold">Login</a>
								</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>
{% endblock %}











É 1 BASIC TEMPLATE COM 1 FORM COM 2 INPUT FIELDS...








FIELDS:


'OLD PASSWORD' 



'NEW PASSWORD'...











O FINDBYTOKEN EU ESCREVI ASSIM:





    public function findByToken(string $token): PasswordReset
    {
        return $this->entityManagerService->getRepository(PasswordReset::class)->findOneBy([
            'token' => $token,
        ]);
    }











--> mas PARA IMPLEMENTAR O METHOD DE 'findByToken',

O PROFESSOR ESCREVEU ASSIM:






    public function findByToken(string $token): PasswordReset
    {
        return $this->entityManagerService->getRepository(PasswordReset::class)
            ->createQueryBuilder('pr')
            ->select('pr')
            ->where('pr.token = :token')
            ->andWhere('pr.isActive = :active')
            ->andWhere('pr.expiration > :now')
            ->setParameter(
                [
                    'token' => $token,
                    'active' => 1,
                    'now' => new \DateTime(),
                ]
            )
            ->getQuery()
            ->getOneOrNullResult();
    }




SE ESSE METHOD RETORNA NADA,


ELE RETORNA 'NULL'...






--> POR ISSO DEIXAMOS O TYPE DESSE METHOD COMO 'Null'....



EX:





    public function findByToken(string $token): ?PasswordReset
    {
        return $this->entityManagerService->getRepository(PasswordReset::class)
            ->createQueryBuilder('pr')
            ->select('pr')
            ->where('pr.token = :token')
            ->andWhere('pr.isActive = :active')
            ->andWhere('pr.expiration > :now')
            ->setParameters(
                [
                    'token' => $token,
                    'active' => 1,
                    'now' => new \DateTime(),
                ]
            )
            ->getQuery()
            ->getOneOrNullResult();
    }










O PROFESSOR RESSALTA 1 DETALHE:





'''NOTICE THAT I'M DOING ALL THE COMPARISONS FROM WITHIN THE 
QUERY BUILDER, HERE... while, for the 2FA codes,
we had 

the 'verify' method, 

AND WE WERE 




 NOT DOING EVERYTHING FROM WITHIN THE QUERY''...






-> TÍNHAMOS FEITO ASSIM, QUER DIZER:



    // * Verifies the 2FA code for the user
    public function verify(User $user, string $code): bool
    {
        $userLoginCode = $this->entityManager->getRepository(UserLoginCode::class)->findOneBy([
            'user' => $user,
            'code' => $code,
            'isActive' => 1,
        ]);

         if (! $userLoginCode) {
             return false;
         }

        if ($userLoginCode->getExpiration() <= new \DateTime()) {
            return false;
        }

        return true;
    }








PODERÍAMOS TER FEITO A MESMA COISA 


NESSE METHOD DE AGORA,



OU FEITO O INVERSO NESSA OUTRO METHOD...



--> O PROFESSOR FEZ DAS 2 MANEIRAS 

PQ AMBAS MANEIRAS SÃO VÁLIDAS....





TUOD DEPENDE DAS NECESSIDADES DO SEU APP...








TALVEZ VC PRECISE DE ALGUM HANDLING ESPECIAL 

PARA A EXPIRATION DO LOGIN CODE,



AÍ VC USARIA O APPROACH 


DE ANTES,

AQUELE QUE TEM ISTO:


     if ($userLoginCode->getExpiration() <= new \DateTime()) {
            return false;
        }









se vc n precisa de 1 handling especial como esse, 

vc pode 

rodar as coisas diretamente no query builder,


como vimos nesse approach mais recente...








--> O PROFESSOR COPIA O CÓDIGO DE 'deactivateAllActiveCodes'

para então criar 

o method 'deactivateAllPasswordResets'






ENTÃO, VAMOS ESCREVENDO ASSIM:



    public function deactivateAllPasswordResets(string $email): void {

        $this->entityManagerService
        ->getRepository(PasswordReset::class)
        ->createQueryBuilder('pr')
        ->update()
        ->set('pr.isActive', 0)
        ->where('pr.email = :email', )
        ->andWhere('ulc.isActive = 1')
        ->setParameter('email', $email) 
        ->getQuery()
        ->execute();
    }









EX:








<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\EntityManagerServiceInterface;
use App\Entity\PasswordReset;
use App\Entity\User;
use Doctrine\ORM\EntityManagerInterface;

class PasswordResetService extends EntityManagerService
{



    public function __construct(private readonly EntityManagerServiceInterface $entityManagerService) {}



    // * Generates the 2FA code for the user
    public function generate(string $email): PasswordReset
    {

        $passwordReset = new PasswordReset();
        $token = bin2hex(random_bytes(32));

        $passwordReset->setEmail($email);
        $passwordReset->setExpiration(new \DateTime('+30 minutes'));
        $passwordReset->setToken($token);

        $this->entityManagerService->sync($passwordReset);

        return $passwordReset;
    }

    public function findByToken(string $token): ?PasswordReset
    {
        return $this->entityManagerService->getRepository(PasswordReset::class)
            ->createQueryBuilder('pr')
            ->select('pr')
            ->where('pr.token = :token')
            ->andWhere('pr.isActive = :active')
            ->andWhere('pr.expiration > :now')
            ->setParameters(
                [
                    'token' => $token,
                    'active' => 1,
                    'now' => new \DateTime(),
                ]
            )
            ->getQuery()
            ->getOneOrNullResult();
    }



    public function deactivateAllPasswordResets(string $email): void {

        $this->entityManagerService
        ->getRepository(PasswordReset::class)
        ->createQueryBuilder('pr')
        ->update()
        ->set('pr.isActive', 0)
        ->where('pr.email = :email', )
        ->andWhere('ulc.isActive = 1')
        ->setParameter('email', $email) 
        ->getQuery()
        ->execute();
    }
}














E VAMOS CHAMAR ESSE METHOD LOGO ANTES 

DE 

CHAMAR A PARTE QUE FAZ O GENERATE DE 1 NOVO PASSWORDRESET,

TIPO ASSIM:








    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {

        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);
        $email = $data['email'];

        if ($user) {

            $this->passwordResetService->deactivateAllPasswordResets($email);

            $resetPassword = $this->passwordResetService->generate($email);

            //send email 
            $this->forgotPasswordEmail->send($resetPassword);
        }

        return $response;
    }










O PROFESSOR ACHA QUE PODEMOS TESTAR ISSO AÍ...









--> A PARTE DE 'UPDATE EMAIL' AINDA NÃO FUNCIONA,

    MAS DEVEMOS TESTAR A PARTE DO SEND DO EMAIL,



    E TESTAR SE O RECORD DE 'PasswordReset'





REALMENTE É CRIADO...










--> ANTES DISSO, RODAMOS 'php expennies diff'

PARA CRIAR A MIGRATION QUE VAI CRIAR ESSA 

TABLE DE 'password_reset'...





AÍ RODAMOS ESSA MIGRATION,


COM 'Php expennies migrate'...












certo...








--> CONSEGUIMOS O SEND DO EMAIL...







CLICAMOS NO EMAIL,

E AÍ 


FICAMOS COM A FORM 

DE 'ENTER NEW PASSWORD'


'CONFIRM NEW PASSWORD'...








--> A ÚLTIMA COISA A SE FAZER 



É IMPLEMENTAR ESSA ROUTE DE 'POST' 


DE 'RESET-PASSWORD',

SEMPRE QUE ESSA FORM FOR ENVIADA...










-->




PARA ISSO, ESCREVEMOS A ROUTE ASSIM:





        $guest->post('/reset-password/{token}', [PasswordResetController::class, 'resetPassword']);









AÍ ADICIONAMOS ESSE METHOD NO CONTROLLER DE 

'PasswordResetController',


TIPO ASSIM:






    public function resetPassword(Request $request, Response $response, array $args): Response
    {
        $token = $args['token'];

        $passwordReset = $this->passwordResetService->findByToken($token);

        if (! $passwordReset) {
            throw new ValidationException(['confirmPassword' => ['The token is invalid or has expired.']]);
        }

        $data = $this->requestValidatorFactory->make(ResetPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials(['email' => $passwordReset->getEmail()]);

        if (! $user) {
            throw new ValidationException(['confirmPassword' => ['The email does not exist in our records.']]);
        }

       return $response->withHeader('Location', '/login')->withStatus(302);
    }









FINALMENTE, ANTES DO REDIRECT,

DEVEMOS RODAR ALGUM METHOD DENTRO DO PasswordResetService,

PARA ATUALIZAR O PASSWORD DO USER PARA ALGUM OUTRO VALUE....
















Ok.. mas como ficará?








--> tipo assim:






$this->passwordResetService->updatePassword($user, $data['password']);


















MAS QUEREMOS HASHEAR ESSE PASSWORD,


POR ISSO CRIAMOS UM 'HASHSERVICE'...



Ex:






<?php declare(strict_types=1);

namespace App\Services;




class HashService
{
    public function __construct() {}

    public function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }

    public function verify(string $password, string $hash): bool
    {
        return password_verify($password, $hash);
    }
}












EX:




    public function updatePassword(User $user, string $password): void
    {

        $user->setPassword($this->hashService->hashPassword($password));
        $this->entityManagerService->sync($user);
    }










MAS, COMO PARTE DESSE METHOD 'updatePassword',

DEVEMOS DEACTIVATE TODOS OS OUTROS 

RESET PASSWORD RECORDS DESSE USER....









O PROFESSOR VAI NOS MOSTRAR 1 EXEMPLO 


DE COMO PODEMOS WRAPPAR 



NOSSA OPERATION TODA COM 1 DATABASE TRANSACTION,

O QUE DEIXA 

TUDO MELHOR....








--> PARA ISSO, O PROFESSOR ESCREVE ASSIM:



    public function updatePassword(User $user, string $password): void
    {   
        $this->entityManagerService->wrapInTransaction(
            function() use ($user, $password) {
            $this->deactivateAllPasswordResets($user->getEmail());
            $user->setPassword($this->hashService->hashPassword($password));
            $this->entityManagerService->sync($user);

                
            }
        )

    }












EX:








    public function updatePassword(User $user, string $password): void
    {
        $this->entityManagerService->wrapInTransaction(function () use ($user, $password) {
            $this->deactivateAllPasswordResets($user->getEmail());
            $user->setPassword($this->hashService->hashPassword($password));
            $this->entityManagerService->sync($user);
        });
    }







certo.... e isso funciona,


depois de ajustar assim:




    public function showResetPasswordForm(Request $request, Response $response, array $args): Response
    {
        $token = $args['token'];

        $passwordReset = $this->passwordResetService->findByToken($token);

        if (! $passwordReset) {
            return $response->withHeader('Location', '/login')->withStatus(302);
        }

        return $this->twig->render($response, 'auth/reset_password.twig', ['token' => $token]);
    }







O PROFESSOR QUER QUE IMPLEMENTEMOS O METHOD DE 'UPDATE PASSWORD'

TAMBÉM, POR CONTA PRÓPRIA...