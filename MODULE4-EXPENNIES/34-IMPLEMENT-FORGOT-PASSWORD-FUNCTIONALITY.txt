








--> NO ÚLTIMO EPISODIO,
O PROFESSOR DEU 1 TAREFA DE 




'''BUILD A SIMPLE PROFILE PAGE,
TO ALLOW THE USER TO UPDATE THE NAME 
AND THE 2FA FLAG'' 




--> O PROFESSOR IMPLEMENTOU ESSA PROFILE PAGE POR TRÁS DAS CENAS,

E VAI NOS MOSTRAR AS CHANGES DA UI...














--> O PROFESSOR RECOMENDA QUE COMPAREMOS 


OS BRANCHES, ENTRE O DELE E O MEU...










--> ASSIM QUE VC ESTIVER LOGGADO NO APP EXPENNIES,





CLIQUE NO ÍCONE DE 'USER',



PARA ENTÃO ENCONTRAR A OPTION DE 'PROFILE'...






--> NESSE NOVO LINK,


FICAMOS COM 1 NOVA PROFILE PAGE, BEM BÁSICA...











NELA, TEMOS:





1) O NAME DO USER 


2) O EMAIL DO USER (disabled, só para info... não vamos deixar o user updatar o email, pq isso é usado como username)

    COMO ISSO É USADO COMO USERNAME, TERÍAMOS DE TER MAIS USER VALIDATION E AUTHENTICATION, PARA GARANTIR QUE N EXISTAM EMAILS DUPLICADOS, NA DATABASE... MAS QUEREMOS DEIXAR AS COISAS SIMPLES, POR ISSO N MEXEREMOS NESSA PARTE.....




3) UM CHECKBOX DE 'ENABLE 2FA VIA EMAIL' 



4) UM BUTTON DE 'UPDATE PASSWORD',
    QUE PROVAVELMENTE NOS LEVA 

    AO MODAL DE 'RESET PASSWORD' 



5) UM BUTTON DE 'SAVE CHANGES'...















PODEMOS MUDAR O NAME E ENTÃO CLICAR EM 'ENABLE 2FA',

ANTES DE CLICAR NO BUTTON DE 'SAVE CHANGES'...






--> ISSO FAZ COM QUE APAREÇA 1 ALERT,


E AÍ 


OS VALUES SÃO ALTERADOS....









CERTO...











--> AQUELE BUTTON DE 'UPDATE PASSWORD'...



ELE FAZ APARECER 1 MODAL, QUE PEDE O 'CURRENT PASSWORD'

E ENTÃO TE DEIXA CRIAR 1 NOVO PASSWORD...










--> MAS ESSE MODAL/FEATURE AINDA NÃO FUNCIONA,


o professor quer que implementemos isso como próximo exercise...










-> MAS, ANTES DISSO,

DEVEMOS IMPLEMENTAR A FEATURE DE 'FORGOT PASSWORD',


QUE É OUTRA FEATURE...










-> PARA ISSO,
 


 VOLTAMOS à PAGE DE LOGIN...







 -> AGORA, SE CLICAMOS NO LINK DE 'FORGOT PASSWORD?',


 É RENDERIZADO 1 BASIC MODAL,



 COM 



 'FORGOT PASSWORD',


 em que colocamos nosso email address e aí clicamos em 'continue'...












O CÓDIGO É ESTE:








{% extends 'auth/layout.twig' %}

{% block stylesheets %}
    {{ parent() }}
    {{ encore_entry_link_tags('forgot_password') }}
{% endblock %}

{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('forgot_password') }}
{% endblock %}

{% block title %}Forgot Password{% endblock %}

{% block content %}
    <section class="vh-100 bg-primary bg-gradient">
        <div class="container py-5 h-100">
            <div class="row d-flex justify-content-center align-items-center h-100">
                <div class="col-12 col-md-8 col-lg-6 col-xl-5">
                    <div class="card bg-light text-white" style="border-radius: 1rem;">
                        <div class="card-body p-5 text-center">
                            <div class="mb-4">
                                <h2 class="fw-bold mb-4 text-uppercase text-primary d-flex justify-content-center align-items-center">
                                    <img src="{{ asset('build/images/logo.png') }}" width="64" height="64"
                                         alt="Expennies Logo" /> Forgot Password
                                </h2>
                                <div class="forgot-password-form">
                                    <div class="form-outline mb-4">
                                        <input type="email" name="email" class="form-control form-control-lg"
                                               placeholder="Enter your email address" required />
                                    </div>
                                    <button class="btn btn-primary bg-gradient text-white btn-lg px-5 forgot-password-btn"
                                            type="button">
                                        Continue
                                    </button>
                                </div>
                            </div>
                            <div>
                                <p class="mb-0 text-dark">
                                    Back to <a href="/login" class="text-primary fw-bold">Login</a>
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>
{% endblock %}

















CERTO... MAS PRECISAMOS DO CÓDIGO JAVASCRIPT DE ESSA PAGE...







O CÓDIGO JS:






import { post } from './ajax';

window.addEventListener('DOMContentLoaded', function () {
    const forgotPasswordBtn = document.querySelector('.forgot-password-btn')
    const resetPasswordBtn  = document.querySelector('.reset-password-btn')

    if (forgotPasswordBtn) {
        forgotPasswordBtn.addEventListener('click', function () {
            const form  = document.querySelector('.forgot-password-form')
            const email = form.querySelector('input[name="email"]').value

            post('/forgot-password', {email}, form).then(response => {
                if (response.ok) {
                    alert('An email with instructions to reset your password has been sent.');

                    window.location = '/login'
                }
            })
        })
    }





COISA BEM NORMAL...












AGORA FALTA A LÓGICA BACKEND...








explicação:









''WHENEVER USER ENTERS THE EMAIL ADDRESS

AND PRESSES CONTINUE,

WE SHOULD PREPARE AND SEND AN EMAIL 
 
 WITH INSTRUCTIONS ON HOW TO RESET THE PASSWORD''...









 --> O PROFESSOR ADICIONOU 2 ROUTES 



LÁ NO GROUP QUE TEM O MIDDLEWARE DE 'GuestMiddleware',


AS ROUTES DE 


(GET) forgot-password 

e 

(POST) forgot-password...








TIPO ASSIM:






    $app->group('', function (RouteCollectorProxy $guest) {
        $guest->get('/login', [AuthController::class, 'loginView']);
        $guest->get('/register', [AuthController::class, 'registerView']);
        $guest->post('/login', [AuthController::class, 'logIn']);
        $guest->post('/register', [AuthController::class, 'register']);
        $guest->post('/login/two-factor', [AuthController::class, 'twoFactorLogin']);
         $guest->get('/forgot-password', [PasswordResetController::class, 'showForgotPasswordForm']);
         $guest->post('/forgot-password', [PasswordResetController::class, 'handleForgotPasswordRequest']);













OK... MAS AINDA PRECISAMOS ESCREVER ESSE 


'PasswordResetController'...









VAI FICANDO TIPO ASSIM:







<?php declare(strict_types = 1);




namespace App\Controllers;


class PasswordResetController
{
    public function __construct()
    {
    }

    public function showForgotPasswordForm(Request $request, Response $response): Response
    {
        return $response->withStatus(200);
    }

    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
        return $response->withStatus(200);
    }
}   










o PROFESSOR explica 




''showForgotPasswordForm''


É O METHOD QUE ACTUALLY RENDERIZA AQUELA PAGE DE 


'forgot_password.twig',





E A ROUTE DE 'POST' 



É A QUE HANDLA O ACTUAL CREATE E SEND 


DO EMAIL COM INSTRUÇÕES, 



ASSIM QUE O INPUT DO EMAIL É PROVIDENCIADO...








-> NESSE CONTROLLER, TEMOS ESTA LÓGICA:








<?php declare(strict_types = 1);




namespace App\Controllers;

use App\Contracts\RequestValidatorFactoryInterface;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Slim\Views\Twig;

class PasswordResetController
{
    public function __construct(
        private readonly Twig $twig,
        private readonly RequestValidatorFactoryInterface $requestValidatorFactory
    )
    {
    }

    public function showForgotPasswordForm(Request $request, Response $response): Response
    {
        return $this->twig->render($response, 'auth/forgot_password.twig');
    }

    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
       
        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        return $response;
    }
}   










MAS PRECISAMOS DE ESSE REQUEST VALIDATOR,

QUE TERÁ APENAS 1 ÚNICO FIELD ('email')...







ELE FICA TIPO ASSIM:;







<?php declare(strict_types = 1);

namespace App\RequestValidators;

use App\Contracts\RequestValidatorInterface;
use App\Exception\ValidationException;
use Valitron\Validator;

class ForgotPasswordRequestValidator implements RequestValidatorInterface
{
    public function validate(array $data): array
    {
        $v = new Validator($data);

        $v->rule('required', ['email']);
        $v->rule('email', 'email');

        if (! $v->validate()) {
            throw new ValidationException($v->errors());
        }

        // Check if the email exists in the database
        if (! $this->userExists($data['email'])) {
            throw new ValidationException(['email' => ['The email does not exist in our records.']]);
        }

        return $data;
    }

    private function userExists(string $email): bool
    {
        // TODO
    }

}














OK... MAS A PRIMEIRA COISA QUE TEMOS QUE FAZER, DEPOIS DISSO,





É OBTER O USER, LÁ DO 'userProviderService' 


service,


com o method 'getByCredentials',

tipo ASSIM:









    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
       
        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByEmail($data['email']);

        return $response;
    }









EX:








    public function handleForgotPasswordRequest(Request $request, Response $response): Response
    {
       
        $data = $this->requestValidatorFactory->make(ForgotPasswordRequestValidator::class)->validate(
            $request->getParsedBody()
        );

        $user = $this->userProviderService->getByCredentials($data);

        return $response;
    }











no caso, passamos 'data' 

como argument justamente pq 'data' contém o EMAIL,



E O EMAIL JÁ BASTA PARA OBTER O USER, COM ESSE METHOD...









ISSO FEITO, PRECISAMOS CHECAR SE O USER FOI FOUND OU NÃO....








--> OK... MAS ESTA É A PARTE IMPORTANTE:




''IF THE USER REALLY CANNOT BE FOUND WITH THE GIVEN 
EMAIL, WE __ MUST _ NOT __ RESPOND TO THE REQUEST/USER 
SAYING THAT 

NO USER COULD BE FOUND WITH THE GIVEN EMAIL...



'''




NÃO PODEMOS FAZER ISSO PQ 




ISSO DEIXARIA NOSSO APP VULNERÁVEL 


A ATAQUES 




DE 

''USER ENUMERATION VULNERABILITY'' --> COM ISSO,
                                        O ATTACKER 
                                        PODE 

                                        'FIGURE OUT'

                                        QUAIS EMAILS 
                                        SÃO VALID E QUAIS 
                                        NÃO SÃO....





                            --> BASICMAENET,
                             ELES PODEM USAR ISSO PARA 

                             ''DETERMINE IF THE USER WHICH 
                             THEY ARE TRYING TO HACK INTO 
                             TRULY EXISTS WITHIN THE SYSTEM''....




-> E É JUSTAMEMNTE POR ISSO QUE DEVEMOS TENTAR 

ENVIAR MESSAGES GENÉRICAS,

COMO 

''WE-VE SENT THE PASSWORD RESET INSTRUCTIONS TO THE 
PROVIDED EMAIL'' (mesmo que isso seja 1 mentira)...








-> se o user for REALMENTE FOUND,

VAMOS ENVIAR 1 EMAIL...








caso contrário, ele não for found,

vamos apenas 'RETURN AN EMPTY RESPONSE'...







---> COM ISSO,

MESMO SE 1 USER COM ESSE EMAIL NÃO EXISITR,


VAMOS MOSTRAR A MESMA MENSAGEM/TELA GENÉRICA DE 


'THE PASSWORD RESET EMAIL WAS SENT',


AINDA QUE ISSO SEJA UMA MENTIRA...