









--> VAMOS IMPLEMENTAR A LÓGICA DE EMAIL VERIFICATION...






--> NÓS VAMOS 'GENERATE SIGNED VERIFICATION URLs'...





--> UMA 'SIGNED URL'

    É ESSENCIALMENTE UMA URL COMUM,

    MAS COM 'ADDED SECURITY MEASURES'...









''ADDED SECURITY MEASURES'' ---> SIGNED URLS CONTÊM:




1) EXPIRATION TIMESTAMP 


2) SIGNATURE (''a secure seal of authenticity'')











-> ESSA SIGNATURE NOS PERMITE VALIDAR A INTEGRIDADE DA URL
E __GARANTIR__ 



QUE NENHUMA PARTE DELA FOI MANIPULADA/TAMPERED DURANTE 

O TRANSIT...








''SIGNATURE'' --> ''IT'S ESSENTIALLY 
                        A _ HASH__ OF THE URL'S CONTENTS,
                        ALONG WITH A SECRET KEY THAT 
                        IS __ ONLY KNOWN BY THE SERVER''...






--> QUANDO O SERVER RECEBE O REQUEST,
    ELE PODE USAR ESSA MESMA 'SECRET KEY'
    PARA 


    ''GENERATE A NEW HASH, FROM THE URL'S CONTENTS'',


    PARA ENTÃO 


    ''CHECK IF THE NEW HASH __ MATCHES THE PROVIDED SIGNATURE'''... --> DESSA MANEIRA,
                                                                        TEMOS CERTEZA 
                                                                        DE QUE 



                                                                        A URL NÃO 
                                                                        FOI 'TAMPERED WITH',

                                                                        PQ, CASO CONTRÁRIO,


                                                                        OS HASHES NÃO 
                                                                        MATCHEARIAM...



FRAMEWORKS COMO O __ LARAVEL__




_ PROVIDENCIAM ESSA FUNCIONLIDADE 'OUT OF THE BOX',



E 'MAKE IT EASY' 

O IMPLEMENT 


DE SIGNED URLS, AUTOMATICAMENTE...









--> A NOSSA IMPLEMENTATION VAI SER BEM PARECIDA COM A DO LARAVEL,
NA VERDADE...










--> NA CLASS DE 'SIGNUPEMAIL',


EM QUE FAZEMOS O SEND DO EMAIL,





COM ESTE CÓDIGO:









<?php declare(strict_types=1);

namespace App\Mail;

use App\Config;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\BodyRendererInterface;

class SignupEmail
{
    public function __construct(
        private readonly Config $config,
        private readonly MailerInterface $mailer,
        private readonly BodyRendererInterface $renderer
    ) {}


    public function send(string $email): void
    {
        $from = $this->config->get('mailer.from');
        $to = $email;
        $subject = 'Welcome to ' . $this->config->get('app_name');


        // * Send email to user.
        $message = (new TemplatedEmail())
                    ->from($from)
                    ->to($to)
                    ->subject($subject)
                    ->htmlTemplate('/emails/signup.html.twig')
                    ->context([
                        'activationLink' => '#',
                        'expirationDate' => new \DateTime('+30 minutes'),
                    ]);

                
        $this->renderer->render($message);

        $this->mailer->send($message);
    }
}


















-> NESSE CÓDIGO AÍ,

NÓS PRECISAMOS DO VALUE DO 'activationLink',

precisamos FAZER GENERATE DE ESSE LINK... 













-> PARA ISSO, CRIAMOS 1 VARIABLE,

DE NOME '$activationLink'...












-> NO VALUE DE ESSA VARIABLE,


CHAMAMOS 



'$this->generateSignedLink()'..







EX:









    public function send(string $email): void
    {   
        $activationLink = $this->generateSignedUrl();
        $from = $this->config->get('mailer.from');
        $to = $email;
        $subject = 'Welcome to ' . $this->config->get('app_name');


        // * Send email to user.
        $message = (new TemplatedEmail())
                    ->from($from)
                    ->to($to)
                    ->subject($subject)
                    ->htmlTemplate('/emails/signup.html.twig')
                    ->context([
                        'activationLink' => $activationLink,
                        'expirationDate' => new \DateTime('+30 minutes'),
                    ]);

                
        $this->renderer->render($message);

        $this->mailer->send($message);
    }












 







--> Certo, mas que pedaços de info são necessárias,
    para construir essa signed url?











''FIRST, WE MUST DECIDE ON WHAT OUR URL SHOULD LOOK LIKE,
 AND THEN WE CAN BUILD IT UP, STEP BY STEP''...










A ESTRUTURA VAI SER BASICAMENTE:








baseUrl 


https://domain.com 









CERTO...







--> TIPO ASSIM:





{BASE_URL}/











DEPOIS DISSO,


PRECISAMOS DE ALGUM TIPO DE ROUTE...











--> NO NOSSO CASO,

JÁ TEMOS A 

ROUTE DE 


'get('/verify')'...







--> O PROFESSOR DIZ QUE PODEMOS CRIAR UMA OUTRA 


ROUTE,



COMO 



''get('/verify/some-additional-info') ''













CERTO...



QUER DIZER QUE A URL VAI FICANDO ASSIM:





{BASE_URL}/verify














-> DENTRO DESSA URL, PRECISAMOS 

'IDENTIFY THE USER, SOMEHOW',



pq precisamos 



'IDENTIFY WHO IS MAKING THAT REQUEST/CLICKING THAT LINK''...





--> É POR ISSO QUE VAI FICANDO ASSIM:






{BASE_URL}/verify/{USER_ID}














--> É CLARO QUE O PROFESSOR __ SABE__ 

QUE O EXPOSE DO USER_ID 


NO EMAIL _ NÃO É UMA BOA PRACTICE,



PQ _ ISSO PODE EXPOR ALGUMAS INFOS EXTERNAS 

(como ''how many users are there in the system'', por exemplo)...










-> MAS COMO ESTE É UM APP 
    PEQUENO, N TEM PROBLEMA...










--> SE VC N QUER DEIXAR O ID EXPOSTO,

VC PODE USAR ALGO COMO 'uuid'



E ENTÃO ADICIONAR ESSA COLUMN à TABLE DE USERS,

E ENTÃO USAR ESSE VALUE DE 'uuid'


para verificar/matchear essa signedUrl...








-> MAS O PROFESSOR N QUER GASTAR MAIS TEMPO COM ISSO,

    POR ISSO ELE VAI USAR O 'USER_ID' MESMO...







-> certo...


    MAS PARA TER MAIS SEGURANÇA,


    O PROFESSOR DIZ QUE PODEMOS 'INCLUDE THE EMAIL HASH,
     IN THE URL'...


    





--> O FORMATO VAI FICANDO ASSIM:





{BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}















--> DEPOIS DISSO, PRECISAMOS 



DA 




'EXPIRATION TIMESTAMP'...










-> E PODEMOS INCLUIR ISSO COMO PARTE DA QUERY STRING,

TIPO ASSIM:






{BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}
















A PARTE FINAL DE ESSA URL SERÁ A 'SIGNATURE' em si...










-> A SIGNATURE PODERÁ FAZER PARTE DA QUERY STRING,


    TIPO ASSIM:


    
{BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}













CERTO...






SERÁ ESSA A APARÊNCIA/ESTRUTURA DA URL FINAL...



EX:




    // * Returns the activationLink
    private function generateSignedUrl(): string
    {
    // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}


        return $url;
    }








MAS COMO PODEMOS OBTER TODAS ESSAS INFOS?











1) user_id, email e expiration_timestamp --> PODEM SER ACEITOS COMO _ ARGUMENTS DO METHOD 'generateSignedUrl'...







EX:






    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationTimestamp): string
    {
    // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}


        return $url;
    }










CERTO... A PRIMEIRA COISA QUE FAREMOS,
AQUI,

É 

CONVERTER 




'$expirationDate'

em 1 TIMESTAMP...










-> FAREMOS ISSO JUSTAMENTE PQ __ PRECISAMOS 
DE 1 TIMESTAMP, PARA A URL...







-> PODEMOS FAZER ISSO TIPO ASSIM:





    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();

        return $url;
    }














CERTO....








A PRÓXIMA COISA QUE PRECISAMOS FAZER É 


''CONSTRUCT THE ROUTE AND QUERY PARAMETERS''..









--> OU SEJA,



ESTA PARTE:



/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE} 













--> MAS ANTES DE FAZERMOS ISSO,



DEVEMOS CRIAR ESSA ROUTE NO WEB.PHP,


NO ARQUIVO DE ROUTES...








--> ESCREVEMOS TIPO ASSIM:









    $app->group('', function (RouteCollectorProxy $group) {
        $group->post('/logout', [AuthController::class, 'logOut']);
        $group->get('/verify', [VerifyController::class, 'index']);
        $group->get('/verify/{id}/{hash}', [VerifyController::class, 'verify']);
    })->add(AuthMiddleware::class);















OU SEJA,

TEREMOS 1 METHOD CHAMADO DE 'verify',


dentro do 'VerifyController'...











criamos esse method, com este formato:











<?php declare(strict_types=1);

namespace App\Controllers;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Slim\Views\Twig;

class VerifyController
{
    public function __construct(private readonly Twig $twig) {}

    public function index(ResponseInterface $response): ResponseInterface
    {
        return $this->twig->render($response, 'auth/verify.twig');
    }

    public function verify(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface
    {
        
        return $response;
    }
}  













MAIS TARDE IMPLEMENTAREMOS ESSE FORMAT ADEQUADAMENTE... 













-> VOLTAMOS AO 'SignupEmail'...








-> VAMOS PEGAR OS ROUTEPARAMS,

COM ESTE CÓDIGO:










    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];


        return $url;
    }













CERTO...









SÓ FALTA A SIGNATURE, MAS VAMOS ADICIONÁ-LA MAIS TARDE...



ISSO É PQ 

AINDA NÃO SABEMOS COMO FAZER O GENERATE DA SIGNATURE...










--> TEMOS TODOS OS COMPONENTS DA URL,

    EXCETO A 'BASE_URL'



    E 



    A SIGNATURE...






-> PARA OBTER A 'BASE_URL',
    PODERÍAMOS PARSEAR A 'REQUEST_URI'

    E OBTER A 'BASE_URL' DE LÁ... MAS 


    A COISA MAIS FÁCIL A SE FAZER 


    É SIMPLESMENTE 

    ARMAZENAR A URL NO CONFIG,

    E AÍ 

    OBTER ESSA URL DE LÁ...









--> O PROFESSOR JÁ FEZ ISSO POR TRÁS DAS CENAS...










-> LÁ NA CONFIG FILE,
    TEMOS ESTA PARTE:





return [
    'app_name' => $_ENV['APP_NAME'],
    'app_version' => $_ENV['APP_VERSION'] ?? '1.0',
    'app_url' => $_ENV['APP_URL'] ?? 'http://localhost:8000',
    'app_environment' => $appEnv,
    'display_error_details' => (bool) ($_ENV['APP_DEBUG'] ?? 0),
    'log_errors' => true,
    'log_error_details' => true,
    'doctrine' => [









e isso já basta...










no .env,



temos isto:






MAILER_DSN=smtp://mailhog:1025
MAILER_FROM=support@expennies.com
APP_URL=http://localhost:8000









OU SEJA, JÁ ESTÁ TUDO CONFIGURADO...











-. NO 'SignupEmail',

escrevemos assim:










    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];
    $baseUrl = trim($this->config->get('app_url'), '/');


        return $url;
    }
















CERTO... MAS PARA GERARMOS A SIGNATURE,



NÓS PRECISAMOS TER A URL COMPLETA....










-> PRECISAMOS DA URL COMPLETA


JUSTAMENTE PQ 

A SIGNATURE 

É 

'BASICALLY A HASH 
    OF THE URL'S contents''...











NESSE CASO,
PRECISAMOS TER ESSA URL INTEIRA,


ESTE TRECHO INTEIRO:



{BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}




para então HASHEAR ESSA STRING,


QUE ENTAÕ SERÁ A SIGNATURE...










-> PARA ISSO,

    O 'RouteParser'

    TEM 1 METHOD CHAMADO DE 'urlFor()',


    QUE FAZ GENERATE DA URL COM BASE 

    NA 'NAMED ROUTE'...






-> esse method exige:



1) ROUTE PARAMS 


2) QUERY PARAMS...









-> COM ISSO, COM ESSE METHOD,

NÃO PRECISAMOS BUILDAR A URL MANUALMENTE,

O QUE É BEM ÚTIL...








-> mas para que esse method funcione,
    a primeira coisa que precisamos fazer é 


'''NAME OUR ROUTE'',

dar 1 nome a nossa route...







ISSO PQ, ATUALMENTE,


ELA NAO TEM NOME:





        $group->get('/verify/{id}/{hash}', [VerifyController::class, 'verify']);
















-> PARA DAR 1 NOME A ESSA ROUTE,

BASTA USAR O METHOD 'setName()',

TIPO ASSIM:










    $app->group('', function (RouteCollectorProxy $group) {
        $group->post('/logout', [AuthController::class, 'logOut']);
        $group->get('/verify', [VerifyController::class, 'index']);
        $group->get('/verify/{id}/{hash}', [VerifyController::class, 'verify'])->setName('verify');
    })->add(AuthMiddleware::class);









EX:




        $group->get('/verify/{id}/{hash}', [VerifyController::class, 'verify'])->setName('verify');












com isso, o nome de essa route vira 'verify'...














-> LÁ EM 'SignupEmail',


PODEMOS INJETAR 



A INTERFACE 


'RouteParserInterface',



TIPO ASSIM:







<?php declare(strict_types=1);

namespace App\Mail;

use App\Config;
use DateTime;
use Slim\Interfaces\RouteParserInterface;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\BodyRendererInterface;

class SignupEmail
{
    public function __construct(
        private readonly Config $config,
        private readonly MailerInterface $mailer,
        private readonly BodyRendererInterface $renderer,
        private readonly RouteParserInterface $routeParser
    ) {}


















--> PARA USAR ISSO NO METHOD,


BASTA 


ESCREVER ASSIM:









    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];
    $baseUrl = trim($this->config->get('app_url'), '/');
    $url = $this->routeParser->urlFor('verify', $routeParams, $queryParams);


        return $url;
    }













OS ARGUMENTS SÃO:



1) THE ROUTE NAME( verify) 


2) routeparameters 


3) query parameters...










NÓS FAZEMOS PREPEND 


DA BASEURL AO INÍCIO,



pq precisamos dela...






FICA TIPO ASSIM:




   private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];
    $baseUrl = trim($this->config->get('app_url'), '/');
    $url = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams);


        return $url;
    }















-> QUER DIZER QUE ESSA URL TODA FICOU TIPO ASSIM:


{BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}













agora só faltou a parte da SIGNATURE, ao final...









-> VAMOS GERAR A SIGNATURE...








--> ANTES DE GERAR A SIGNATURE,

    PRECISAMOS ACTUALLY CRIAR 1 ENTRY,
    NO 

    CONTAINER_BINDINGS.PHP,


    para a 

    'RouteParserInterface'...











FICA TIPO ASSIM:







    RouteParserInterface::class => fn(App $app) => $app->getRouteCollector()->getRouteParser(),













CERTO...













COM ISSO, 



TEMOS UMA URL COM TODAS AS PARTES, MENOS A SIGNATURE...








A ÚLTIMA ETAPA É GERAR 1 SIGNATURE PARA A NOSSA URL



E FAZER APPEND, COMO QUERY PARAMETER,


à url inteira...








-> PODEMOS FAZER ISSO 


COM A FUNCTION 'hash_hmac()'







-> TIPO ASSIM:






    $signature = hash_hmac('sha256', $url, $this->config->get('app_secret'));











Generate a keyed hash value using the HMAC method...












-> PARA O ALGORITMO, USAREMOS 



'sha256'...






--> PARA O SEGUNDO ARGUMENT,

USAREMOS A DATA/STRING QUE QUEREMOS  HASHEAR...


PASSAMOS A URL... 









-> O TERCEIRO PARAMETER É A 'SECRET KEY'












EX:






    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];
    $baseUrl = trim($this->config->get('app_url'), '/');

    // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
    $url = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams);

    // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
    $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

    $activationLink = $url . '&signature=' . $signature;

    return $activationLink;
    }











-> quer dizer que hash_hmac()

BASICAMENTE CRIA 1 'HASH OF THE DATA STRING',



USANDO 



O ALGORITMO 'SHA256' E UMA SECRET KEY...











--> A SECRET KEY, NO CASO,


É 

SIMPLESMENTE UMA RANDOM KEY QUE É/SERÁ 

ARMAZENADA NO CONFIG DE NOSSO APP...






--> PENSE NA SECRET KEY 


''AS A SECRET PASSWORD, THAT MUST NOT BE SHARED''...



















-> NO CASO, 

    O PROFESSOR CRIOU 1 COMANDO DOCTRINE,
    POR TRÁS DAS CENAS,

    QUE TE PERMITE 

    'GENERATE A SECRET KEY'...













--> PARA ISSO, PRIMEIRAMENTE ABRIMOS 

'app.php'...








-> LÁ DENTRO,

O PROFESSOR ADICIONOU UMA NOVA ENTRY,

CHAMADA DE 'app_key'...



EX:






return [
    'app_key' => $_ENV['APP_KEY'] ?? '',
    'app_name' => $_ENV['APP_NAME'],
    'app_version' => $_ENV['APP_VERSION'] ?? '1.0',
    'app_url' => $_ENV['APP_URL'] ?? 'http://localhost:8000',
    'app_environment' => $appEnv,
    'display_error_details' => (bool) ($_ENV['APP_DEBUG'] ?? 0),
    'log_errors' => true,
    'log_error_details' => true,
    'doctrine' => [



















certo...










MAS, EM '.env',

O PROFESSOR AINDA NÃO DEFINIU A KEY DE 'APP_KEY'...













--> PARA TER ESSA SECRET KEY,

VC PODE OU:


1) DEFINIR ELA MANUALMENTE (pode ser qualquer string)








2) USAR O COMANDO QUE O PROFESSOR PROVIDENCIOU,
    QUE VAI GERAR ESSA SECRET KEY, AUTOMATICAMENTE...














--> O CÓDIGO DO COMANDO/ARQUIVO É ESTE:






<?php

declare(strict_types = 1);

namespace App\Command;

namespace App\Command;

use App\Config;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\ConfirmationQuestion;

class GenerateAppKeyCommand extends Command
{
    protected static $defaultName        = 'app:generate-key';
    protected static $defaultDescription = 'Generates a new APP_KEY';

    public function __construct(private readonly Config $config)
    {
        parent::__construct();
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $hasKey = $this->config->get('app_key');

        if ($hasKey) {
            $helper = $this->getHelper('question');

            $question = new ConfirmationQuestion(
                'Generating a new APP_KEY will invalidate any signatures associated with the old key. Are you sure you want to proceed? (y/n)',
                false
            );

            if (! $helper->ask($input, $output, $question)) {
                return Command::SUCCESS;
            }
        }

        $key = base64_encode(random_bytes(32));

        $envFilePath = __DIR__ . '/../../.env';

        if (! file_exists($envFilePath)) {
            throw new \RuntimeException('.env file not found');
        }

        $envFileContent = file_get_contents($envFilePath);

        $pattern = '/^APP_KEY=.*/m';

        if (preg_match($pattern, $envFileContent)) {
            $envFileContent = preg_replace($pattern, 'APP_KEY=' . $key, $envFileContent);
        } else {
            $envFileContent .= PHP_EOL . 'APP_KEY=' . $key;
        }

        file_put_contents($envFilePath, $envFileContent);

        $output->writeln('New APP_KEY has been generated & saved');

        return Command::SUCCESS;
    }
}

















OK....











E, PARA RODAR ESSE COMANDO,



BASTA 



rodar 



'php expennies app:generate-key'..















ok, mas... não consegui usar esse command...








acho que tenho que ADICIONAR ESSE COMMAND,

lá em 'expennies' (arquivo base em que temos os commands)









CONSEGUI, FICOU TIPO ASSIM:








<?php declare(strict_types=1);

use App\Commands\GenerateAppKeyCommand;

return [
    GenerateAppKeyCommand::class,
];













    E ISSO REALMENTE GEROU 1 NOVA APP_KEY, TIPO ASSIM:









APP_NAME=Expennies
APP_VERSION=1.0
APP_DEBUG=1
APP_ENV=development
DB_HOST=db
DB_USER=root
DB_PASS=root
DB_NAME=expennies
MAILER_DSN=smtp://mailhog:1025
MAILER_FROM=support@expennies.com
APP_URL=http://localhost:8000
APP_KEY=zm2L98wnlLfEIyPP1onjj9lzyQslEgRTLKgVopbSDAQ=























OK... FECHAMOS TUDO ISSO AÍ,
E AÍ 



DEFINIMOS 


O NEGÓCIO ASSIM:






    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];
    $baseUrl = trim($this->config->get('app_url'), '/');

    // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
    $url = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams);

    // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
    $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

    /// {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
    $activationLink = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams) . '&signature=' . $signature;

    return $activationLink;
    }




















mas o professor quer MODIFICAR ISSO,



QUER ABSTRAIR ESSA GENERATION,

E AÍ 

QUER 




''ALLOW SIGNED URL GENERATION FOR EVERY SINGLE ROUTE,
    NOT ONLY FOR THE VERIFY ROUTE''...








-> ISSO PQ, ATUALMENTE, ESSE METHOD ESTÁ HARCODADO PARA A 

ROUTE DE 'verify',


por conta desta linha:




    // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
    $url = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams);













PODE SER QUE, NO FUTURO,




NÓS QUEIRAMOS FAZER O GENERATE DE 1 SIGNED URL PARA OUTRAS ROUTES...




É POR ISSO QUE O PROFESSOR QUER MODIFICAR ESSA LÓGICA, DEIXAR MAIS DINÂMICA...













-> O QUE VAMOS FAZER, AQUI,
É COPIAR TODA ESTA LÓGICA:








    // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}

    $expirationTimestamp = $expirationDate->getTimestamp();
    $routeParams = [ 'id' => $userId, 'hash' => sha1($email) ];
    $queryParams = [ 'expiration' => $expirationTimestamp ];
    $baseUrl = trim($this->config->get('app_url'), '/');

    // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
    $url = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams);

    // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
    $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

    /// {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
    $activationLink = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams) . '&signature=' . $signature;

    return $activationLink;













    E CRIAR 1 NOVA CLASS...














--> ESSA CLASS SERÁ 'SignedUrl'...




















ELA VAI BASICAMENTE 

'GENERATE A SIGNED URL, FROM A GIVEN ROUTE'...












--> PARA ISSO, TEREMOS 1 ÚNICO METHOD DENTRO DELA,

CHAMADO DE 'fromRoute()'...






fica tipo assim:






<?php declare(strict_types=1);

namespace App;

class SignedUrl
{
    public function fromRoute()
    {
        // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $expirationTimestamp = $expirationDate->getTimestamp();
        $routeParams = ['id' => $userId, 'hash' => sha1($email)];
        $queryParams = ['expiration' => $expirationTimestamp];
        $baseUrl = trim($this->config->get('app_url'), '/');

        // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
        $url = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams);

        // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        // / {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $activationLink = $baseUrl . $this->routeParser->urlFor('verify', $routeParams, $queryParams) . '&signature=' . $signature;

        return $activationLink;
    }
}












-> AÍ, PRECISAMOS ADAPTAR ESSE CÓDIGO...





TIPO ASSIM:











<?php declare(strict_types=1);

namespace App\Mail;

use App\Config;
use App\Entity\User;
use App\SignedUrl;
use DateTime;
use Slim\Interfaces\RouteParserInterface;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\BodyRendererInterface;

class SignupEmail
{
    public function __construct(
        private readonly Config $config,
        private readonly MailerInterface $mailer,
        private readonly BodyRendererInterface $renderer,
        private readonly SignedUrl $signedUrl
    ) {}


    public function send(User $user): void
    {   
        // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $userId = $user->getId();
        $from = $this->config->get('mailer.from');
        $to = $user->getEmail();
        $subject = 'Welcome to ' . $this->config->get('app_name');
        $expirationDate =  new \DateTime('+30 minutes');
        $activationLink = $this->generateSignedUrl($userId, $to, $expirationDate);


        // * Send email to user.
        $message = (new TemplatedEmail())
                    ->from($from)
                    ->to($to)
                    ->subject($subject)
                    ->htmlTemplate('/emails/signup.html.twig')
                    ->context([
                        'activationLink' => $activationLink,
                        'expirationDate' => $expirationDate,
                    ]);

                
        $this->renderer->render($message);

        $this->mailer->send($message);
    }

    // * Returns the activationLink
    private function generateSignedUrl(int $userId, string $email, DateTime $expirationDate): string
    {
    $activationLink = $this->signedUrl->fromRoute($userId, $email, $expirationDate);

    return $activationLink;
    }
}












CERTO... MAS O PROFESSOR ADAPTOU MAIS DO QUE ISSO....






--> ELE QUER SE LIVRAR DE 'verify' como um argument,

por isso ele adaptou assim:






    public function fromRoute(string $routeName, int $userId, string $email, DateTime $expirationDate): string
    {
        // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $expirationTimestamp = $expirationDate->getTimestamp();
        $routeParams = ['id' => $userId, 'hash' => sha1($email)];
        $queryParams = ['expiration' => $expirationTimestamp];
        $baseUrl = trim($this->config->get('app_url'), '/');

        // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
        $url = $baseUrl . $this->routeParser->urlFor($routeName, $routeParams, $queryParams);

        // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        // / {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $activationLink = $baseUrl . $this->routeParser->urlFor($routeName, $routeParams, $queryParams) . '&signature=' . $signature;

        return $activationLink;
    }


















--> DEPOIS DISSO,



O PROFESSOR DIZ QUE DEVEMOS 'ACCEPT ROUTEPARAMS, AS AN ARGUMENT' 


(pq esses parameters são específicos À route de 'verify', mas queremos que 
eles sejam reusable e flexible...)







TIPO ASSIM:



 




     public function fromRoute(string $routeName, array $routeParams, DateTime $expirationDate): string
    {
        // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $expirationTimestamp = $expirationDate->getTimestamp();
        $routeParams = ['id' => $userId, 'hash' => sha1($email)];
        $queryParams = ['expiration' => $expirationTimestamp];
        $baseUrl = trim($this->config->get('app_url'), '/');

        // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
        $url = $baseUrl . $this->routeParser->urlFor($routeName, $routeParams, $queryParams);

        // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        // / {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $activationLink = $baseUrl . $this->routeParser->urlFor($routeName, $routeParams, $queryParams) . '&signature=' . $signature;

        return $activationLink;
    }















DEIXAMOS A EXPIRATION DATE, POR FIM...











--> AÍ PRECISAMOS ADAPTAR AS OUTRAS PARTES,


QUE AINDA USAM 


'email' e  etc..











FICOU TIPO ASSIM:










<?php declare(strict_types=1);

namespace App;

use DateTime;
use Slim\Interfaces\RouteParserInterface;

class SignedUrl
{

    public function __construct(
        private readonly Config $config,
        private readonly RouteParserInterface $routeParser
    ) {

    }
    public function fromRoute(string $routeName, array $routeParams, DateTime $expirationDate): string
    {
        // activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $expirationTimestamp = $expirationDate->getTimestamp();
        $queryParams = ['expiration' => $expirationTimestamp];
        $baseUrl = trim($this->config->get('app_url'), '/');

        // {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP} - THIS WILL BE USED TO GENERATE THE SIGNATURE.
        $url = $baseUrl . $this->routeParser->urlFor($routeName, $routeParams, $queryParams);

        // Arguments: 1) hashing algorithm, 2) url, 3) secret key.
        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        // / {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $activationLink = $baseUrl . $this->routeParser->urlFor($routeName, $routeParams, $queryParams) . '&signature=' . $signature;

        return $activationLink;
    }
}






















-> AÍ, LÁ EM 'SignupEmail',



podemos escrever assim:







    public function __construct(
        private readonly Config $config,
        private readonly MailerInterface $mailer,
        private readonly BodyRendererInterface $renderer,
        private readonly SignedUrl $signedUrl
    ) {}


    public function send(User $user): void
    {   
        // ? activationLink format: {BASE_URL}/verify/{USER_ID}/{EMAIL_HASH}?expiration={EXPIRATION_TIMESTAMP}&signature={SIGNATURE}
        $userId = $user->getId();
        $from = $this->config->get('mailer.from');
        $to = $user->getEmail();
        $subject = 'Welcome to ' . $this->config->get('app_name');
        $expirationDate =  new \DateTime('+30 minutes');
        $routeParams = ['id' => $userId, 'hash' => sha1($user->getEmail())];
        $activationLink = $this->signedUrl->fromRoute('verify',$routeParams, $expirationDate);


        // * Send email to user.
        $message = (new TemplatedEmail())
                    ->from($from)
                    ->to($to)
                    ->subject($subject)
                    ->htmlTemplate('/emails/signup.html.twig')
                    ->context([
                        'activationLink' => $activationLink,
                        'expirationDate' => $expirationDate,
                    ]);

                
        $this->renderer->render($message);

        $this->mailer->send($message);
    }











CERTO...





COM ISSO, CONSEGUIMOS SIMPLIFICAR BASTANTE O CÓDIGO...














O USERID é obtido da entity de 'User', sem problemas...










POR FIM, LÁ EM REGISTER, ESCREVEMOS ASSIM:














    public function register(RegisterUserData $data): UserInterface
    {
        $user = $this->userProvider->createUser($data);

        $emailAddress = $user->getEmail();

        $this->logIn($user);

        // Send verification email to user:
        $this->signupEmail->send($user);

        return $user;
    }  

















OK... AÍ TESTAMOS...









--> VAMOS ATÉ O MAILHOG,




E AÍ ENCONTRAMOS O LINK NO EMAIL..




AGORA O EMAIL CONTÉM O LINK E A EXPIRAITON TIMESTAMP...












 


-> CLICAMOS NO LINK,
MAS FICAMOS COM UMA PAGE EM BRANCO...



ISSO FAZ SENTIDO, É PQ AINDA _ NÃO IMPLEMENTAMOS A PAGE DE VERIFICATION...













-> A PRÓXIMA ETAPA 


É ''BUILD THE VERIFICATION PART''...













--> O PROFESSOR EXPLICA QUE 

''YOU SHOULD PROBABLY SPLIT THE VERIFICATION INTO TWO PARTS:''





1a PARTE ---> ''WE SHOULD VERIFY THE 
                VALIDITY OF THE SIGNATURE, IN THE URL...''
            





2a PARTE --> ''WE SHOULD VERIFY THE ACTUAL USER''..










 

--> A RAZÃO PARA ISSO, NO CASO, É PARA TER 


            ''REUSABLE SIGNATURE VERIFICATION'', 

        

        TUDO PARA QUE CONSIGAMOS FAZER O VERIFY DE SIGNATURES 
        DE OUTRAS URLS QUE TALVEZ TENHAMOS NO FUTURO,


        URLS ALÉM DE ''USER VERIFICATION EMAILS''...












-> PARA ISSO, O PROFESSOR DIZ QUE 

''WE CAN CREATE A NEW MIDDLEWARE, 
    THAT WE CAN USE TO ___ VALIDATE THE SIGNATURE...''








VAMOS CHAMAR ESSE MIDDLEWARE DE 





''ValidateSignatureMiddleware''...












começamos assim:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {


        return $handler->handle($request);
    }
}















-> MAS PRECISAMOS PEGAR:








1) A URI 




2) OS QUERY PARAMETERS, FROM THE REQUEST...











-> VAMOS PEGAR ESSAS 2 COISAS LÁ DO REQUEST, E AÍ VAMOS 

ARMAZENAR ESSES VALUES EM VARIABLES...







TIPO ASSIM:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();


        return $handler->handle($request);
    }
}















OK...








ISSO FEITO,



PRECISAMOS PEGAR A 'SIGNATURE'


E 

'EXPIRATION',





de dentro dos params,

e aí 

ARMAZENAR ESSES VALUES EM VARIABLES, TAMBÉM...











--> TIPO ASSIM:







<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();
        $signature = $queryParams['signature'] ?? null;
        $expiration = $queryParams['expiration'] ?? null;

        return $handler->handle($request);
    }
}













CERTO...









EX:







<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();
        $originalSignature = $queryParams['signature'] ?? '';
        $expiration = $queryParams['expiration'] ?? 0;

        return $handler->handle($request);
    }
}















ISSO FEITO,

DEVEMOS 'GENERATE A NEW SIGNATURE',

usando A 



__ URL... ISSO FEITO,


VAMOS COMPARE ESSA NEW SIGNATURE COM A ORIGINAL SIGNATURE,


PARA VER SE ESSA ORIGINAL SIGNATURE É VALID....







SE AS DUAS NÃO MATCHEIAM,


ISSO QUER DIZER QUE A ORIGINAL URL FOI MODIFICADA/TAMPERED...











--> PARA FAZER O GENERATE DA NOVA SIGNATURE,


PRECISAMOS USAR NOVAMENTE A FUNCTION DE 


'hash_hmac()',




como fizemos na class de 'SignedUrl'...





--> BASTA ESCREVER ASSIM:





       $signature = hash_hmac('sha256',  (string) $uri, $this->config->get('app_key'));










é importante fazer o cast de '$uri',


pq 



isto:


        $uri = $request->getUri();


retorna um 'uri object',




e esse tipo de object possui o magic method de '__toString()'...


-> quando castamos esse object como STRING,

com '(string)',



ele automaticamente é convertido na string completa, que queremos utilizar...













-> CERTO... MAS, AQUI, TEMOS OUTRO DETALHE:






'''IT'S IMPORTANT TO NOTE THAT WHEN THE ORIGINAL 
    SIGNED URL WAS GENERATED, 
    THE SIGNATURE PART WAS __ NOT INCLUDED __ IN THE URL THAT WAS BEING HASHED...

    ''''





este trecho aqui:



        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));







este trecho não continha a signature em si, dentro da '$url' variable...













ENTRETANTO, NA PARTE DO 'ValidateSignatureMiddleware',



nessa parte em que estamos GENERATING  the signature,


com isto:






        $signature = hash_hmac('sha256', (string) $uri, $this->config->get('app_key'));






essa uri aí vai ser 


''THE FULL URL OF THE REQUEST'', OU SEJA, 

VAI CONTER A SIGNATURE NA URL completa, como parte da query string...








--> ISSO QUER DIZER QUE HASHEAR A URL INTEIRA, INCLUINDO A PARTE DA SIGNATURE,
    VAI FAZER COM QUE ESSE HASH NÃO MATCHEIE COM A SIGNATURE ORIGINAL... O QUE VAI 
    CAUSAR UM ERRO...







-> PARA CONSERTAR ISSO, PRECISAMOS  __ EXCLUIR _ A PARTE DA 'ORIGINAL SIGNATURE',   
    DA URL,


    ANTES DE GERARMOS 1 NOVA SIGNATURE COM aquele hash_hmac()







-> para fazer isso, basta 

rodarmos algo como 


'unset($queryParams['signature'])',



PQ ISSO VAI DESTRUIR ESSA SIGNATURE, DOS QUERY PARAMS,


E NOS DEIXAR COM APENAS A 'EXPIRATION'... COM ISSO,

EFETIVAMENTE CONSEGUIMOS 

'MIRROR' OS ORIGINAL QUERY PARAMS DAQUELA variable $url em 'SignedUrl',

que usamos PARA GENERATE A ORIGINAL SIGNATURE...






FICA TIPO ASSIM:







    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();
        $originalSignature = $queryParams['signature'] ?? '';
        $expiration = (int) $queryParams['expiration'] ?? 0;

        unset($queryParams['signature']); // we do this so that the original signature and the newly created signature can match.

        // Reconstruct the url, without the signature in the query params.
        $url = (string) $uri->withQuery($queryParams);

        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        return $handler->handle($request);
    }





CERTO... MAS ESSE 'queryParams' está errado..





está errado pq ESTAMOS DANDO 1  ARRAY,

QUANDO DEVERÍAMOS DAR 1 QUERY STRING  ao method de 'withQuery'...



-> PARA CONSERTAR ISSO, BASTA 

PASSAR ESSE VALUE AO METHOD  DE 'http_build_query()'...





EX:





<?php declare(strict_types=1);

namespace App\Middleware;

use App\Config;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory,
        private readonly Config $config
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();
        $originalSignature = $queryParams['signature'] ?? '';
        $expiration = (int) $queryParams['expiration'] ?? 0;

        unset($queryParams['signature']); // we do this so that the original signature and the newly created signature can match.

        // Reconstruct the url, without the signature in the query params.
        $url = (string) $uri->withQuery(http_build_query($queryParams));

        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        return $handler->handle($request);
    }
}














AGORA QUE TEMOS A OLD SIGNATURE E A NEW SIGNATURE (RECÉM CRIADA),


PODEMOS COMPARAR AS 2, 

USANDO A FUNCTION 'hash_equals()',

TIPO ASSIM:





<?php declare(strict_types=1);

namespace App\Middleware;

use App\Config;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use RuntimeException;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory,
        private readonly Config $config
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();
        $originalSignature = $queryParams['signature'] ?? '';
        $expiration = (int) $queryParams['expiration'] ?? 0;

        unset($queryParams['signature']); // we do this so that the original signature and the newly created signature can match.

        // Reconstruct the url, without the signature in the query params.
        $url = (string) $uri->withQuery(http_build_query($queryParams));

        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        if (! hash_equals($signature, $originalSignature)) {
         throw new RuntimeException('Failed to verify signature.');
        }

        return $handler->handle($request);
    }
}












TAMBÉM PODEMOS CHECAR SE A EXPIRATION JÁ EXPIROU,

COM ISTO:






<?php declare(strict_types=1);

namespace App\Middleware;

use App\Config;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use RuntimeException;

class ValidateSignatureMiddleware implements MiddlewareInterface {

    public function __construct(
        private readonly ResponseFactoryInterface $responseFactory,
        private readonly Config $config
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {   
        $uri = $request->getUri();
        $queryParams = $request->getQueryParams();
        $originalSignature = $queryParams['signature'] ?? '';
        $expiration = (int) $queryParams['expiration'] ?? 0;

        unset($queryParams['signature']); // we do this so that the original signature and the newly created signature can match.

        // Reconstruct the url, without the signature in the query params.
        $url = (string) $uri->withQuery(http_build_query($queryParams));

        $signature = hash_hmac('sha256', $url, $this->config->get('app_key'));

        if ($expiration <= time() || ! hash_equals($signature, $originalSignature)) {
         throw new RuntimeException('Failed to verify signature.');
        }

        return $handler->handle($request);
    }
}














CERTO...


PODERÍAMOS HANDLAR ISSO MAIS GRACEFULLY,

COM O FRONTEND...

MAS NÃO VAMOS FAZER ISSO, POR ENQUANTO...






SE TUDO MATCHEIA,



NÓS VAMOS 'MOVE ON ' COM O REQUEST,


COM return $handler->handle($request);













-> POR FIM,


ADICIONAMOS ESSE MIDDLEWARE

A NOSSAS ROUTES,

COM ISTO:








    $app->group('', function (RouteCollectorProxy $group) {
        $group->post('/logout', [AuthController::class, 'logOut']);
        $group->get('/verify', [VerifyController::class, 'index']);
        $group->get('/verify/{id}/{hash}', [VerifyController::class, 'verify'])->setName('verify')->add(ValidateSignatureMiddleware::class);
    })->add(AuthMiddleware::class);















COM ESSA SIGNATURE VERIFICATION FORA DO CAMINHO,


DEVEMOS VER A PARTE DO CONTROLLER METHOD,

PARA ACTUALLY VERIFICAR O USER..









-> neste trecho aqui:










<?php declare(strict_types=1);

namespace App\Controllers;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Slim\Views\Twig;

class VerifyController
{
    public function __construct(private readonly Twig $twig) {}

    public function index(ResponseInterface $response): ResponseInterface
    {
        return $this->twig->render($response, 'auth/verify.twig');
    }

    public function verify(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface
    {
        
        return $response;
    }
}  

















--> PRECISAMOS IMPLEMENTAR ESSA LÓGICA...











''FIRST, WE NEED TO RETRIEVE THE LOGGED-IN USER OBJECT FROM THE REQUEST'':











<?php declare(strict_types=1);

namespace App\Controllers;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Slim\Views\Twig;

class VerifyController
{
    public function __construct(private readonly Twig $twig) {}

    public function index(ResponseInterface $response): ResponseInterface
    {
        return $this->twig->render($response, 'auth/verify.twig');
    }

    public function verify(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface
    {

        $user = $request->getAttribute('user');
        
        return $response;
    }
}  
















DEPOIS, QUEREMOS VERFIICAR SE O LOGGED-IN USER ID 


MATCHEIA COM O USERID QUE É 

PROVIDED NA URL...





-> NÓS TAMBÉM QUEREMOS VERIFICAR 

O EMAIL HASH QUE É FORNECIDO NA URL...







--> FAZEMOS ISSO COM O ARGUMENTO DE '$args',


QUE SERÁ UM ARRAY CONTENDO OS ROUTE ARGUMENTS 




(que serão o userId e o email hash )


EX:



    public function verify(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {

        $user = $request->getAttribute('user');


        
        return $response;
    }







-> VAMOS USAR A FUNCTION DE 'hash_equals()' 

PARA FAZER A COMPARISON,



PQ QUEREMOS EVITAR 'TIMING ATTACKS'... 








--> QUANDO ALGUÉM TENTA 'FIGURE OUT' 1 PEDAÇO DE INFO SAFE 
    POR MEIO DO MEASURE DE 'QUANTO TEMPO O SISTEMA DEMORA 
        PARA CHECAR SE SEU GUESS FOI CERTO OU ERRADO''...







---> É POR ISSO QUE USAMOS HASH_EQUALS PARA 
    FIELDS QUE SÃO SENSITIVE,

    MESMO QUE ISSO SEJA OVERKILL, EM CERTOS CASES...








VAMOS CHECAR ASSIM:









    public function verify(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {

        $user = $request->getAttribute('user');

        if (! hash_equals((string) $user->getId(), $args['id']) || ! hash_equals(sha1($user->getEmail()), $args['hash'])) {
           throw new \RuntimeException('Verification failed.');
        }
        
        return $response;
    }













OK... AGORA QUE VERIFICAMOS A SIGNATURE NO MIDDLEWARE E NO USER,

PRECISAMOS SETTAR A 'verifiedAt' date do user,

PARA QUE ELES CONSIGAM UTILIZAR O SITE...







--> PARA ISSO, CHECAMOS SE O USER NÃO 


TEM 1 value 

de 

'verifiedAt'...





-> SE ELE N TIVER,


NÓS SETTAMOS O VALUE,



COM O METHOD DE 'verifyUser',

que 

ESCREVEMOS DENTRO DO SERVICE DE 'userProviderService'...




TIPO ASSIM:










    public function verify(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {

        $user = $request->getAttribute('user');

        if (! hash_equals((string) $user->getId(), $args['id']) || ! hash_equals(sha1($user->getEmail()), $args['hash'])) {
           throw new \RuntimeException('Verification failed.');
        }

        if (! $user->getVerifiedAt()) {
           $this->userProviderService->verifyUser($user);
        }
        
        return $response;
    }








    CERTO..








    E ESSE METHOD:






    public function verifyUser(UserInterface $user): void
    {
        $user->setVerifiedAt(new \DateTime());

        $this->entityManager->sync($user);
    }












OK...









FINALMENTE,



PODEMOS BASICAMENTE REDIRECIONAR O USER à HOMEPAGE,




PQ ELE ESTARÁ VERIFICADO...





-> PODEMOS SÓ RODAR ASSIM:











<?php declare(strict_types=1);

namespace App\Controllers;

use App\Contracts\UserProviderServiceInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Slim\Views\Twig;

class VerifyController
{
    public function __construct(private readonly Twig $twig, 
                                private readonly ResponseFactoryInterface $responseFactory,
                                private readonly UserProviderServiceInterface $userProviderService) {}

    public function index(ResponseInterface $response): ResponseInterface
    {
        return $this->twig->render($response, 'auth/verify.twig');
    }

    public function verify(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {

        $user = $request->getAttribute('user');

        if (! hash_equals((string) $user->getId(), $args['id']) || ! hash_equals(sha1($user->getEmail()), $args['hash'])) {
           throw new \RuntimeException('Verification failed.');
        }

        if (! $user->getVerifiedAt()) {
           $this->userProviderService->verifyUser($user);
        }
        
        return $response->withHeader('Location', '/')->withStatus(302);
    }
}  














CERTO...





FINALMENTE, COM ISSO, ESTAREMOS VERIFICADOS,

DEPOIS DE ACESSAR ESSA SIGNED URL...












o professor modifica a url, para mostrar o que acontece quando 

tentamos avacalhar com a signed url...







-> COM ISSO, FICAMOS COM 1 EXCEPTION:


''FAILED TO VERIFY SIGNATURE'' --> O QUE QUER DIZER QUE NOSSOS 
                                    BLOCKS FUNCIONARAM...
















COMO 1 EXERCISE,

O PROFESSOR QUER QUE FAÇAMOS UMA COISA...













'''WE NEED TO HAVE SOME KIND OF BUTTONS THAT BASICALLY RE-SENDS 
    THE VERIFICATION EMAIL, 
    WITH A NEW VERIFICATION URL''..






-> O PROFESSOR QUER QUE FAÇAMOS ISSO, COMO 1 EXERCISE...








--> YOU NEED TO ADD A BUTTON,
AND THEN MAKE IT SEND AN EMAIL, WHEN IT IS CLICKED...