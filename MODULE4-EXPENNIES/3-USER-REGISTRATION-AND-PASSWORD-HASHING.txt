











-> OK... 








NO ÚLTIMO VIDEO, FIZEMOS 

1 POUCO DE DATA MODELING,


EM QUE CRIAMOS 


ENTITIES,


E TAMBÉM SUAS RELATIONSHIPS...












JÁ NESTA AULA VEREMOS 

A FEATURE DE USER AUTHENTICATION..





-> O PROFESSOR JÁ CRIOU A UI 


PARA O USER REGISTRATION E LOGIN...










-> MAS É SÓ A UI,

ELA AINDA NÃO FUNCIONA...







O PROFESSOR TAMBÉM JÁ CRIOU 


O CONTROLLER 'AUTHCONTROLLER',

COM ALGUMAS ROUTES...






O CÓDIGO DE AUTHCONTROLLER É ESTE:








<?php

declare(strict_types=1);

use Psr\Http\Message\RequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;


class AuthController
{

    public function __construct(private readonly Twig $twig) {}

    public function loginView(Request $request, Response $response): Response
    {


        return $this->twig->render($response, 'auth/login.twig');
    }



    public function registerView(Request $request, Response $response): Response
    {


        return $this->twig->render($response, 'auth/register.twig');
    }



    public function register(Request $request, Response $response): Response
    {

        // TODO: Implement user registration 

        return $response;
    }
}









E


O CÓDIGO DE 'web.php',

encontrado dentro 

de 'configs->routes->web.php',


é este: 







<?php

declare(strict_types=1);

use App\Controllers\HomeController;
use Slim\App;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index']);


    $app->get('/login', [AuthController::class, 'loginView']);
    $app->get('/register', [AuthController::class, 'registerView']);
    $app->post('/login', [AuthController::class, 'login']);
    $app->post('/register', [AuthController::class, 'register']);
};










BASICAMENTE,


SÃO 2 METHODS QUE RETORNAM VIEWS,


E 1 METHOD QUE FAZ O REGISTER/CREATE DO USER,










COM A ROUTE DE POST...










-> MAS ANTES DE PROSSEGUIRMOS,
  O PROFESSOR 



  RECOMENDA QUE RODEMO 

  'docker-compose up -d --build',

  PARA REBUILDAR OS CONTAINERS,

  POIS ELE FEZ ALGUNS AJUSTES..









  -> ELE AJUSTOU O ARQUIVO YML,



  PQ DEIXOU 

  'ports:
    - 9003:9003',


para fazer o xdebug funcionar apropriadamente..
















ELE TAMBÉM 




ADICIONOU A LINHA DE 


''
      - ./local.ini:/usr/local/etc/php/conf.d/local.ini



''







ele fez isso para que consigamos ter 

nosso arquivo php.ini customizado,



em que podemos 



modificar algumas das configuration


options,




como 


'fastcgi.logging = Off'....













---> O PROFESSOR DEFINIU ESSA OPTION COMO 'Off'

PARA EVITAR 




O ERRO 502, GATEWAY ERRORS,

COM O NGINX...










-> SE VC ESTIVER USANDO DOCKER E NGINX,
    COM PHP-FPM,


    VC 

    TEM QUE SEMPRE SEGUIR ESTES PASSOS:









1) REBUILDAR OS CONTAINERS 


2) RODAR NPM RUN DEV PARA BUILDAR OS ASSETS..




3) RODAR COMPOSER INSTALL PARA INSTALAR TODAS AS DEPENDENCIES 
    DO BACKEND...













CERTO... AGORA VAMOS COMEÇAR..










PRIMEIRAMENTE ABRIMOS O AUTHCONTROLLER...









-> A PRIMEIRA COISA QUE O PROFESSOR QUER FAZER É 

O 

'DUMP' 
dE TODOS OS POST PARAMETERS,

DENTRO 

DE NOSSOS METHODS DE 'AuthController',

PARA USO POSTERIOR..




--> PODEMOS ACESSAR OS POST PARAMETERS POR MEIO DO CALL 





de '$request->getParsedBody()',



nesse object de '$request'...











-> PODEMOS ESCREVER TIPO ASSIM:





    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       var_dump($data, 'THE DATA');

        return $response;
    }




















DEI 1 CORRIGIDA NO CÓDIGO, FICOU ASSIM:









<?php

declare(strict_types=1);

use Psr\Http\Message\ResponseInterface as Response;
use Slim\Psr7\Request as Request;
use Slim\Views\Twig;

class AuthController
{

    public function __construct(private readonly Twig $twig) {}

    public function loginView(Request $request, Response $response): Response
    {


        return $this->twig->render($response, 'auth/login.twig');
    }



    public function registerView(Request $request, Response $response): Response
    {


        return $this->twig->render($response, 'auth/register.twig');
    }



    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       var_dump($data, 'THE DATA');

        return $response;
    }
}













-> AÍ CHECAMOS SE ISSO FUNCIONA, NA PÁGINA DE ACCOUNT...









-> MAS GANHEI ESTE ERROR:









The application could not run because of the following error:

Details
Type: Twig\Error\RuntimeError
Code: 0
Message: An exception has been thrown during the rendering of a template ("Could not find the entrypoints file from Webpack: the file "/var/www/configs/../public/build/entrypoints.json" does not exist.").
File: /var/www/resources/views/layout.twig
Line: 10













-> É PQ ESQUECI DE EXECUTAR 'npm run build'...

















-> ok... depois de debuggar e resolver mais uns 3 problemas,

consegui fazer o app funcionar...









fiquei com este print, 


ao enviar 1 post request para a route de 

'/register':







/var/www/app/Controllers/AuthController.php:40:
array (size=4)
  'name' => string 'arthur' (length=6)
  'email' => string 'exemplo@exemplo.com' (length=19)
  'password' => string 'aaaaaa' (length=6)
  'confirmPassword' => string 'aaaaaa' (length=6)
/var/www/app/Controllers/AuthController.php:40:string 'THE DATA' (length=8)








CERTO...













-> NOSSO OBJETIVO, AGORA, É CRIAR A ENTITY DE 'USER',

E ENTÃO FAZER 'PERSIST' DE ELA 



NA NOSSA DATABASE...









-> OU SEJA, CRIAR ESSA ENTITY NO CÓDIGO, COMO UM OBJECT,

E ENTÃO SALVÁ-LA NA DATABASE...












-> PARA ISSO, EM 'public function register()',



VAMOS ESCREVER ASSIM:







    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [$name, $email, $password, $confirmPassword] = $data;


       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setPassword($password);


       $this->user->save($user);

       var_dump($data, 'THE DATA');

        return $response;
    }














Esse é um bom começo...






mas ainda temos alguns problemas..





primeiramente, o method de 'save()' não está funcionando...










-> também não estamos checando se os 2 password são os mesmos..







-> também não estamos checando se o user já existe no db...




-> e também não estamos hashando o password, antes de inseri-lo 

no db...












--> CORRIGI O CÓDIGO..








-> ESSA VERSÃO DO CÓDIGO USA 'entity manager',

por isso 

eu tive de reescrever para esta versão:









    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [$name, $email, $password, $confirmPassword] = $data;


       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setPassword($password);

       
       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;
    }








--> ISSO VAI ACTUALLY CRIAR O USER, FAZER ELE PERSISTIR NO NOSSO CÓDIGO,


E AÍ, COM 'FLUSH()', vai faze com que ele seja criado no db...







-> MAS É CLARO QUE AINDA NÃO TEMOS METHOD DE 'setPassword()'...



--> PRECISAMOS HASHEAR NOSSA SENHA, ANTES DE INSERI-LA NO DB...








-> FAZEMOS ISSO COM ESTE CÓDIGO:




        $this->password = password_hash($password, PASSWORD_BCRYPT);









ISSO VAI TENTAR HASHEAR ESSE PASSWORD...


















OK... FUNCIONOU... COM ESTE CÓDIGO, FUNCIONOU:









    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       ['name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword] = $data;

    //    var_dump($name, $email, $password, $confirmPassword);

       if ($password !== $confirmPassword) {
           return $this->twig->render($response, 'auth/register.twig');
       }

       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);
       $user->setCreatedAt(new \DateTime());
       $user->setUpdatedAt(new \DateTime());

       
       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;
    }















O PROFESSOR VAI FAZENDO A MESMA COISA,

ELE CRIA O USER E VAI USANDO OS SETTER METHODS 
PARA DEFINIR A DATA,

TIPO ASSIM:




    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       ['name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword] = $data;

    //    var_dump($name, $email, $password, $confirmPassword);

       if ($password !== $confirmPassword) {
           return $this->twig->render($response, 'auth/register.twig');
       }

       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);
       $user->setCreatedAt(new \DateTime());
       $user->setUpdatedAt(new \DateTime());













-> MAS ELE EXPLICA O QUE EU JÁ SABIA,


QUE 

TEMOS QUE 


HASHEAR O PASSWORD, ANTES DE ARMAZENAR O PASSWORD...




















-> CERTO...







ENTÃO O PROFESSOR EXPLICA 1 NEGÓCIO:














'''HASHING IS NOT THE SAME AS ENCRYPTION'''...













HASHING !== ENCRYPTION...
















--> ENCRYPTION:



''IT IS TWO-WAY'' --> ISSO QUER DIZER QUE 
                    __ TUDO_ QUE FOI ENCRIPTADO__ PODE 
                    SER __ DECRIPTADO, COM A KEY CORRETA...











--> HASHING:





''ONE-WAY ONLY'' --> HASHING, POR OUTRO LADO,
                    É __ ONE-WAY... O QUE QUER DIZER QUE,

                    UJMA VEZ QUE ALGO FOI HASHEADO,

                    É __ IMPOSSÍVEL__ fAZER UNHASH 

                    DESSA COISA...













EXEMPLO:










aaaaa  ---> HASH FUNCTION (#) --->  b21dcasdhzxkhcvjk@saha@>as1ihaZ



aaaaa ---> ENCRYPTION FUNCTION (with a secret key) --> 10101101000000100








1101101101010 --> can be DECRYPTED, with the key 



b21dcasdhzxkhcvjk@saha@>as1ihaZ ----> cannot be transformed, ever...


















MESMO ASSIM, ISSO NÃO QUER DIZER QUE 


O HASHING POR SI SÓ,
 
 JÁ 

 DEIXA SEUS APP MAIS SEGUROS...











--> HÁ VÁRIAS COISAS QUE VC DEVE TER EM MENTE,
    COMO:






1) 'FAST_HASH' FUNCTIONS --> FAST GENERATIONAL-PURPOSE HASH FUNCTIONS...






2) 'SLOW HASH' FUNCTIONS











E TEMOS OUTRAS COISAS,

COMO 



'RAINBOW TABLE ATTACK'' 





''BRUTE FORCE'' 



E 


''DICTIONARY ATTACKS''...












--> É AÍ QUE 


    HASHING ALGORITHMS,
    SALTING 

    E OUTRAS 

    ESTRATÉGIAS 

    ENTRAM EM JOGO....













--> SALTING -> É BASICAMENTE UMA RANDOM STRING/TEXT 
                QUE É USADA, JUNTO COM O PASSWORD,
                DURANTE O HASHING....


                --> ESSAS STRINGS AJUDAM A PREVENIR CERTOS ATAQUES,
                    E ATRAPALHAM O ATTACKER,
                    PROTEGEM O PASSWORD...


                






-> DIFERENTES HASHING ALGORITHMS E FUNCTIONS 
    HANDLAM O HASH DO PASSWORD DE FORMA DIFERENTE...








-> ALGUNS ''HANDLE THE SALT GENERATION AND INCLUDE IT ALONG WITH THE HASH'',


    ENQUANTO QUE OUTRAS PEDEM QUE OS PRÓPRIOS DEVELOPERS CUIDEM 

    DO SALT, programem o salt...














--> DIGAMOS QUE VC TENHA ALGUMA DAS 'GENERAL-PURPOSE' FUNCTIONS
    PARA HASHEAR PASSWORDS,



    COMO 

    'md5', 'sha1' e 'sha2'...













-> PARA ATACAR 'md5', 'sha1' e 'sha2',

    PODERÃO/PODEM EXISTIR RAINBOW TABLES
     
     OU DICTIONARIES,

     QUE CONTENHAM LISTAS DE PASSWORDS

     HASHEADOS DA MESMA FORMA que os passwords originais daquele sistema...





--> ENTÃO, COM ESSAS RAINBOW TABLES/DICTIONARIES,

    HACKERS PODEM USAR O PODER DE PCS MODERNOS E SERVERS 

    PARA TESTAR 


    TODO TIPO DE COMBINAÇÃO POSSÍVEL PARA,

    EVENTUALMENTE, CRACKEAR SEU PASSWORD...












--> GENERAL-PURPOSE HASHING FUNCTIONS,

COMO SHA1, SHA2 E ETC,




SÃO ÓTIMAS PARA CERTAS COISAS,


E POSSUEM CERTOS USE-CASES, SIM,




MAS SÃO 


__TERRÍVEIS__ 

PARA ARMAZENAR PASSWORDS...
















--> POR EXEMPLO,


UM BOM SERVER PODE CRACKEAR 



hashes de tipo 'md5'



EM _ _seGUNDOS__...
















-> O PROFESSOR PODE DEMONSTRAR ISSO, AGORA MESMO...









-> BASTA ENTRAR NESTE SITE:





https://crackstation.net/
















--> COLOCAMOS 1 HASHED PASSWORD,

COMO ESTE:








$2y$10$MfbPjvEq7a.mldi85995seyR/Zyl17pVk4frYUcJ0QflknEpGbq0u
















-> ISSO FUNCIONOU...













--> É POR ISSO QUE GENERAL-PURPOSE HASHING FUNCTIONS NÃO DEVEM 
SER USADAS PARA O HASHING DE PASSWORDS...












-> EM VEZ DISSO, PRECISAMOS DE UMA 'SLOW-HASHING FUNCTION'...







-> O BCRYPT PROVAVELMENTE É ISSO...





--> O PROFESSOR FALA PRECISAMENTE SOBRE ISSO,


SOBRE O METHOD DE 



''''


password_hash()


''''



do php,


que pode ser usado para HASHEAR SEUS PASSWORDS....








ESSA FUNCTION USA O ALGORITMO 'bcrypt' 

por default,





QUE É JUSTAMENTE 1 DOS ALGORITMOS 

MAIS FORTES ATUALMENTE SUPORTADOS PELO PHP....









-> E ELE SE ENCARREGA DO SALTING PARA NÓS,
    E ADICIONA O SALTING AO HASH QUE ACABA RETORNADO PELA FUNCTION..












-> É POR ISSO QUE DEVEMOS 

USAR 

'password_hash()'

PARA HASHEAR FUNCTIONS,

E ENTÃO USAR 


'password_verify()'


PARA 


COMPARAR E CHECAR SE 1 USER INPUTTOU 

O PASSWORD CORRETO...















-> BEM, VAMOS TESTAR ISSO, VAMOS GENERATE 1 PASSWORD, E ENTÃO DUMP IT OUT..

















-> PROFESSOR ESCREVE ASSIM:







    public function setHashedPassword($password): void
    {
        $this->password = password_hash($password, PASSWORD_BCRYPT);
    }
















'PASSWORD_DEFAULT' é a mesma coisa que 'PASSWORD_BCRYPT',

mas esse 'PASSWORD_DEFAULT'

PODE MUDAR,


NO FUTURO...













--> certo...





MAS TEMOS TAMBÉM ALGUMAS OPTIONS...








-> UMA DAS OPTIONS QUE DEVEMOS PASSAR, NO CASO,

    É O 'cost'...






-> O 'COST', na verdade, é BASICAMENTE 


OS ROUNDS DE SALTING...



12 é um bom número...











O DEFAULT COST É '10'...





é mais inseguro..







É POR ISSO QUE ESCREVEMOS ASSIM:



    public function setHashedPassword($password): void
    {
        // 'cost' is the salting rounds (12 is a good amount).
        $this->password = password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }














CERTO...







E ISSO FAZ TOTAL SENTIDO...







o algoritmo do bcrypt sempre 



retorna strings com este formato, os hashed passwords:




$2y$10$MfbPjvEq7a.mldi85995seyR/Zyl17pVk4frYUcJ0QflknEpGbq0u












BASICAMENTE,


VC PODE SABER QUANTOS SALTING ROUNDS A FUNCTION APLICOU...



BASTA LER A PARTE INICIAL,

ESTA AQUI:





''''

$2y$10


''''






COMO VC PODE VER, FORAM 10 SALTING ROUNDS...









-> se vc deixa esse parameter de 'options' com 

'cost' como sendo '12',



o resultado fica algo assim:






$2y$12$A6CpDOOCyz9GyzDE66MHQOPDDiHnt0X4d1.8ihTV92drH32qswVNe














CERTO...








EXPLICAÇÃO DO PROFESSOR:






''THE RETURNED STRING 
    CONTAINS THE __ ALGORITHM THAT IT IS USING ($2y),
    THE COST ($12),
    AND THE HASHED PASSWORD ($A6CpDOOCyz9GyzDE66MHQOPDDiHnt0X4d1.8ihTV92drH32qswVNe)''














MAS VC NAO PRECISA ARMAZENAR TODAS ESSAS COISAS EM COLUMNS SEPARADAS...

ELAS PODEM SER, TODAS ELAS,

ARMAZENADAS EM 1 MESMA COLUMN...













MAS VC PODE ESTAR SE PERGUNTANDO:



''O QUE É O COST??''












--> O COST DEFAULT É 10...








-> É BOM VC SETTAR COMO 10 OU HIGHER....




-> ISSO EXISTE BASICAMENTE PARA CONTROLAR O CPU
    TIME E USAGE...









-> 'HIGHER COST' --> SIGNIFICA QUE É NECESSÁRIO MAIS TEMPO PARA CRIAR  
                        1 HASH,
                        MAS DEMORA MAIS TEMPO PARA DECRYPTAR...











--> LOWER COST,
    LESS RESOURCES TO MAKE,

    BUT LESS TIME TO DECRYPT IT...














-> HÁ 1 SNIPPET DE CÓDIGO NOS DOCS DO PHP,


QUE TE AJUDA 


A 

ESTIMAR O PROPER COST PARA O SEU SERVER...






É ESTE SNIPPET AQUI:











<?php
/**
 * This code will benchmark your server to determine how high of a cost you can
 * afford. You want to set the highest cost that you can without slowing down
 * you server too much. 10 is a good baseline, and more is good if your servers
 * are fast enough. The code below aims for ≤ 350 milliseconds stretching time,
 * which is an appropriate delay for systems handling interactive logins.
 */
$timeTarget = 0.350; // 350 milliseconds

$cost = 10;
do {
    $cost++;
    $start = microtime(true);
    password_hash("test", PASSWORD_BCRYPT, ["cost" => $cost]);
    $end = microtime(true);
} while (($end - $start) < $timeTarget);

echo "Appropriate Cost Found: " . $cost;
?>


















CERTO....













-> O PROFESSOR COLOCOU 12 SALTING ROUNDS...


VAMOS AUMENTAR/DIMINUIR ISSO MAIS TARDE,

DURANTE O DEPLOY PROCESS...














OUTRO DETALHE:



''A NEW SALT 
    SHOULD ALWAYS BE GENERATED FOR EACH PASSWORD...''








''THIS MEANS THAT YOU _ SHOULD __ NOT 
    USE THE SAME SALT FOR ALL PASSWORDS...

    EACH PASSWORD THAT YOU STORE
    SHOULD HAVE A DIFFERENT SALT...''






''ALSO, IF YOU GENERATE THE SAME PASSWORD TWICE,
    THEY SHOULD NOT PRODUCE THE SAME HASH/SALT...

    BECAUSE, THEN, WE WOULD BE VULNERABLE TO 
    SOME SORTS OF ATTACKS''...






--> É POR ISSO QUE USAR 'password_hash' 

É A COISA CERTA A SE FAZER,

PQ 

ELE HANDLA TODAS ESSAS COISAS 


COMPLICADAS PARA NÓS...



--> o professor testa, e mostra que 
    o password muda a cada vez que criamos,

    mesmo com o mesmo password sendo inputtado.....










-> CERTO...




-> AGORA PRECISAMOS FAZER PERSIST DE ESSA ENTITY..










-> POR ISSO FAZEMOS INJECT DO ENTITY MANAGER,


PARA AÍ RODAR '->persist()'

e 



'->flush()',


para 


fazer essa entry aparecer na database...










- ainda não temos validation,

mas colocaremos validation mais tarde....









-> também não há redirect nem nada...








-> TAMBÉM NÃO COLOCAMOS O VALUE DE 

'setUpdatedAt'


e 

'setCreatedAt'...










-> PODEMOS USAR ESSES SETTERS, SIM,

OU ENTÃO USAR 'LIFECYCLE EVENTS',



AQUELES QUE JÁ ESTUDAMOS, EM 1 AULA PASSADA,


PARA SEMPRE 


DEFINIR 

ESSAS DATES SEMPRE QUE 




1 NOVO 'USER' FOR CRIADO...












-> PARA ISSO, VAMOS PRECISAR DO EVENT MANAGER do 

doctrine orm...












PARA ISSO, PODEMOS ESCREVER ASSIM, LÁ NA CLASS/ENTITY:










<?php declare(strict_types=1);

namespace App\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Event\LifecycleEventArgs;
use Doctrine\ORM\Mapping\HasLifecycleCallbacks;
use Doctrine\ORM\Mapping\PrePersist;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity, ORM\Table(name: 'users')]
#[HasLifecycleCallbacks]  // Needed to make the 'onPrePersist' method work.
class User
{





    #[PrePersist]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        $this->createdAt = new \DateTime();
        $this->updatedAt = new \DateTime();
    }




}















OU SEJA, ESSES 2 ATTRIBUTES,


1 NA CLASS INTEIRA,


E 1 NESSE METHOD ESPECIAL DE NOME 'onPrePersist'...















COM ISSO, PODEMOS REMOVER OS CALLS DE 




'setUpdatedAt()


e 


'setCreatedAt()':








    public function register(Request $request, Response $response): Response
    {

       $data = $request->getParsedBody();


       [
       'name' => $name, 
       'email' => $email, 
       'password' => $password, 
       'confirmPassword' => $confirmPassword
        ] = $data;

    //    var_dump($name, $email, $password, $confirmPassword);

       if ($password !== $confirmPassword) {
           return $this->twig->render($response, 'auth/register.twig');
       }

       $user = new User();

       $user->setName($name);
       $user->setEmail($email);
       $user->setHashedPassword($password);
    //    $user->setCreatedAt(new \DateTime());
    //    $user->setUpdatedAt(new \DateTime());

       
       $this->entityManager->persist($user);
       $this->entityManager->flush();
       
       var_dump($data, 'THE DATA');

        return $response;
    }

















O PROFESSOR TAMBÉM COLOCOU UM attribute de 

'PreUpdate'...



EX:





    #[PrePersist, PreUpdate]
    public function onPrePersist(LifecycleEventArgs $args)
    {
        if (!isset($this->createdAt)) {
        $this->createdAt = new \DateTime();
        }

        $this->updatedAt = new \DateTime();
    }













OK...









E ISSO FUNCIONA, VAI SEMPRE SER TRIGGADO A PARTIR DE ESSES EVENTS...



('PrePersist' e 'PreUpdate')...










