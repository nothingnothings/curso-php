








HOJE VEREMOS PAGINATION NA TABLE DE CATEGORIES...









-> O PROFESSOR MUDOU 1 POUCO A UI 

DA PAGE DE CATEGORIES...



AGORA TEMOS:




1) SEARCH BOX 





2) SORTING INDICATORS NAS COLUMNS 





3) DROPDOWN (que nos deixa selecionar quantas entries queremos na table)...









4) BEEEEM LÁ PARA BAIXO,

    TEMOS AS PAGINATION PAGES,

    E AÍ 



    OS BUTTONS DE PREVIOUS E NEXT...









--> É CLARO QUE A PAGINATION AINDA NÃO FUNCIONA...









AINDA VAMOS BUILDAR ISSO...








-> SE CLICAMOS NAS PAGES,
A DATA NÃO MUDA,



PQ A PAGE REALMENTE FAZ O DISPLAY DE TODOS OS ROWS QUE 

TEMOS NA TABLE DE 'CATEGORIES'...











->  O NEGÓCIO DIZ QUE SÃO '10 items per view',


MAS ESTAMOS ACTUALLY FAZENDO DISPLAY DE TODOS OS ITEMS...













--> PARA FAZER A PAGINATION FUNCIONAR,


O PROFESSOR DECIDIU USAR A THIRD PARTY LIBRARY 'DATA TABLESa'...















datatables.net...










-> É UMA LIBRARY GRÁTIS..





-> UMA DESVANTAGEM É QUE __ ELA USA __ JQUERY COMO DEPENDENCY...








-> ENTRETANTO,

    A BOA NOTÍCIA É QUE 

    NÃO PRECISAMOS ADICIONAR JQUERY COMO DEPENDENCY 
    DIRETA NO NOSSO APP...










-> QUER DIZER QUE PODEMOS AINDA INICIALIZAR E TRABALHAR 
COM 'DATA TABLES' (pacote) 

NO JAVASCRIPT, MESMO SEM O JQUERY...









-> VC TAMBÉM PODE USAR OUTRA TABLE LIBRARY, SE QUISER... OU CONSTRUIR 
1 FROM SCRATCH...









-> VAMOS CONSTRUIR A PARTE BACKEND,
PARA TER:



1) PAGINATION 


2) SORTING AND FILTERING OPTIONS,





tudo isso dentro de nossas queries....










-> TAMBÉM VEREMOS COMO ESTRUTURAR 

A RESPONSE DE UMA MANEIRA UNDERSTANDABLE,


TUDO PARA QUE SEJA 


ENTENDIDA PELA TABLE LIBRARY ESPECÍFICA QUE ESTAMOS UTILIZANDO...
















-> O PROFESSOR MOSTRA UM POUCO DO SETUP QUE ELE FEZ,

POR TRÁS DAS CENAS..










-> O PROFESSOR ADICIONOU 2 DEPENDENCIES:




1) datatables.net 



2) datatables.net.dt 







-> O SEGUNDO PACKAGE É APENAS SOBRE O STYLING DAS DATA TABLES...









-> O CORE PACKAGE É REALMENTE 'datatables.net'....






-> EM 'app.scss',




É POSSÍVEL VISUALIZAR OS IMPORTS DE DATA TABLES,


QUE SÃO ASSIM:











@import "./variables.scss";
@import "~bootstrap/scss/bootstrap";
@import "~bootstrap-icons/font/bootstrap-icons";
@import "~datatables.net/css/jquery.dataTables.css";


* {
  font-family: 'Roboto', sans-serif !important;
}

body {
  background-color: #e7ebee;
}

svg.icon {
  width: 25px;
  height: 25px;
}

.nav-link {
  color: #9aa0a9;

  &.active {
    background-color: inherit !important;
    color: #57585A !important;
  }

  &:hover, &:focus {
    color: #57585A !important;
  }
}












OK... É BASICAMENTE OS STYLES DAQUELE OUTRO PACOTE...









--> LÁ EM 'index.twig'

das categories,

temos esta parte:















{% extends 'layout.twig' %}

{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('categories') }}
{% endblock %}

{% block title %}Categories{% endblock %}

{% block content %}
    <div class="categories container content-body">
        <div class="text-end">
            <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newCategoryModal">
                <i class="bi bi-plus-circle me-1"></i>
                New Category
            </button>
        </div>
        <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <form action="/categories" method="post">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">New Category</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            {{ csrf.fields | raw }}
                            <div class="form-outline form-white mb-4">
                                <input type="text" name="name" required
                                       class="form-control form-control-lg"
                                       placeholder="Category Name" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle me-1"></i>
                                Close
                            </button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle me-1"></i>
                                Create
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
        {% include 'categories/edit_category_modal.twig' %}
        {% if categories %}
            <div id="categoriesTable">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Created At</th>
                            <th>Updated At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for category in categories %}
                            <tr>
                                <td>{{ category.name }}</td>
                                <td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>
                                <td>
                                    <div class="d-flex flex-">
                                        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>
                                        <button class="ms-2 btn btn-outline-primary edit-category-btn"
                                                data-id="{{ category.id }}">
                                            <i class="bi bi-pencil-fill"></i>
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% endif %}
    </div>
{% endblock %}









MAS ESSE CÓDIGO MUDOU 1 POUCO, AGORA É ASSIM:










            <div>
                <table id="categoriesTable">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Created At</th>
                            <th>Updated At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
















CERTO... ESTAMOS MOSTRANDO APENAS AS COLUMNS,


E AÍ ESTAMOS MOSTRANDO A TABLE...







-> a table fica dentro de '<tbody>'</tbody>',

NESSE CASO...








-> ESSE TBODY, NESSE CASO,


É 'POPULATED, USING DATA FROM THE BACKEND,
 
    IN THE FRONTEND, USING JAVASCRIPT'...






EX:







{% extends 'layout.twig' %}

{% block javascripts %}
	{{ parent() }}
	{{ encore_entry_script_tags('categories') }}
{% endblock %}

{% block title %}Categories
{% endblock %}

{% block content %}
	<div class="categories container content-body">
		<div class="text-end">
			<button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newCategoryModal">
				<i class="bi bi-plus-circle me-1"></i>
				New Category
			</button>
		</div>
		<div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
			<div class="modal-dialog">
				<form action="/categories" method="post">
					<div class="modal-content">
						<div class="modal-header">
							<h5 class="modal-title">New Category</h5>
							<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
						</div>
						<div class="modal-body">
							{{ csrf.fields | raw }}
							<div class="form-outline form-white mb-4">
								<input type="text" name="name" required class="form-control form-control-lg" placeholder="Category Name"/>
							</div>
						</div>
						<div class="modal-footer">
							<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
								<i class="bi bi-x-circle me-1"></i>
								Close
							</button>
							<button type="submit" class="btn btn-success">
								<i class="bi bi-check-circle me-1"></i>
								Create
							</button>
						</div>
					</div>
				</form>
			</div>
		</div>
		{% include 'categories/edit_category_modal.twig' %}
		<div>
			<table id="categoriesTable">
				<thead>
					<tr>
						<th>Name</th>
						<th>Created At</th>
						<th>Updated At</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody></tbody>
			</table>
		</div>
	</div>
{% endblock %}















-> OK, MAS QUAL É O JAVASCRIPT QUE FOI UTILIZADO?





-> PRIMEIRAMENTE, INSTALE OS PACOTES,

COM 

npm install datatables.net datatables.net-dt









E O JAVASCRIPT É TIPO ASSIM:






import Datatable from "datatables.net";









IMPORTAMOS ESSE COMPONENTE AÍ...








-> DEPOIS DISSO,



VAMOS CRIAR 1 NOVO OBJECT 'DataTable',




COM ESTE CÓDIGO:





window.addEventListener('DOMContentLoaded', function () {
  const editCategoryModal = new Modal(
    document.getElementById('editCategoryModal')
  );

  const table = new Datatable('#categoriesTable', {});











  PRECISAMOS PASSAR VÁRIAS OPTIONS A ESSE OBJECT 'DataTable'...






  -> ENTRE ELAS, AS OPTIONS:



  serverSide: true/false 


  ajax: '/categories/load',

  orderMulti: false, 


  columns: [
    {data: 'name'},
    {data: 'createdAt'},
    {data: 'updatedAt'}
  ],

  sortable: false,

  data: row => ...















  VAI FICANDO TIPO ASSIM:




  



  

AS OPTIONS SÃO:







serverSide --> deixamos como TRUE,
            PQ VAMOS QUERER FETCHEAR A DATA 
            LÁ DO SERVERSIDE...






ajax --> '/categories/load' --> 
                            ISSO É USADO 
                            PARA 

                            ESPECIFICAR 

                            A URL 

                            DE ONDE VAMOS 

                            FETCHEAR A DATA...

                            --> NO CASO,

                            SERÁ 'categories/load'...





'orderMulti' --> true/false...



                    vc pode escolher se SERÁ 
                    POSSÍVEL FAZER 'SORT'

                    considerando MULTI COLUMN ou não 




'columns' --> É A DISTRIBUIÇÃO DA SUA DATA,
                EM QUE COLUMNS FICARÁ...





--> CADA COLUMN 




VAI TER INFO PRÓPRIA...






tipo assim:





{data: 'name'},
{data: 'createdAt'},
{data: 'updatedAt'},
{
    sortable: false,
    data: row => `<div class="d-flex flex">
                    <button type="submit" class="btn btn-outline-primary delete-category-btn" data-id="${row.id}">
                        <i class="bi bi-trash3-fill"></i>
                    </button>
                    <button type="submit" class="btn btn-outline-primary edit-category-btn" data-id="${row.id}">
                        <i class="bi bi-pencil-fill"></i>
                    </button>
                </div>
                `
                
}







OU SEJA,



ISSO VAI DEFINIR A DATA DE CADA COLUMN...






NAS COLUMNS 'NORMAIS',


TEMOS AS KEYS DE CADA COLUMN,


QUE É RETORNADA EM CADA RESPONSE...






OU SEJA,


A RESPONSE 

É UM JSON OBJECT COM 

1 ARRAY DE VALUES,


EM QUE CADA VALUE OBJECT 

POSSUI 


SA PROPRIEDADES DE 'name', 'createdAt' 

e 'upadtedAt'...









-> OK... TODAS AS COLUMNS ESTARÃO 
REPRESENTADAS NESSES JSON objects..










--> A ÚNICA EXCEÇÃO É A ÚLTIMA COLUMN,

QUE NÃO SERÁ EXATAMENTE 

ALGO QUE PULLAMOS DA DATABASE, DO SERVER,



E SIM 

FAZEMOS DISPLAY DE CUSTOM HTML (pq 

são os buttons de 'edit' e 'delete'...)






--> NÓS TAMBÉM DESABILITAMOS SORTING NESSA ÚLTIMA COLUMN,
PQ ISSO BUGARIA TUDO....













-> OK... ISSO É TUDO, QUANTO AOS TABLE OBJECTS... 





'''AND THAT IS PRETTY MUCH IT AS FAR AS THE TABLE OBJECTS 
GO... IT TAKES __ CARE__ OF MAKING THE REQUEST TO THE 
SERVER, WHENEVER SOME ACTION HAPPENS ON THE TABLE (
    like user sorts table by a specific column,

    enters text in the search bar, 


    or uses the pagination (forward and previous buttons)
)









-> O PROFESSOR QUER FALAR DE OUTRA PARTE EM QUE FEZ 
AJUSTES....





-> É ESTA PARTE AQUI:






    document.querySelector('#categoriesTable').addEventListener('click', function (event) {
        const editBtn   = event.target.closest('.edit-category-btn')
        const deleteBtn = event.target.closest('.delete-category-btn')

        if (editBtn) {
            const categoryId = editBtn.getAttribute('data-id')

            get(`/categories/${ categoryId }`)
                .then(response => response.json())
                .then(response => openEditCategoryModal(editCategoryModal, response))
        } else {
            const categoryId = deleteBtn.getAttribute('data-id')

            if (confirm('Are you sure you want to delete this category?')) {
                del(`/categories/${ categoryId }`).then(response => {
                    if (response.ok) {
                        table.draw()
                    }
                })
            }
        }
    })









é a parte 

que adiciona o event de 'click' 



a esse elemento '#categoriesTable'

inteiro..





-> ESSES EVENT LISTENERS SÃO ADICIONADOS 

NA TABLE QUE É 
O PARENT 


DAQUELES BUTTONS QUE SÃO ADICIONADOS DINAMICAMENTE...








-> COM O 'IF/ELSE',

checamos se foi o button de EDIT ou o de DELETE 

que foi clicado,



E AÍ REALIZAMOS AS ACTIONS APROPRIADAS PARA AQUELE BUTTON...












-> essa 'selection' do editBtn e deleteBtn acontece 

NO MOMENTO DO CLICK 



pq isso só pode acontecer depois da table ser carregada...







-> IMPORTANTE TAMBÉM É AQUELA FUNCTION DE 'table.draw()',

que aparece no final...








-> ESSA FUNCTION BASICAMENTE FAZ RE-DRAW/RELOAD DA TABLE,

PARA QUE A DATA SEJA ATUALIZADA... ESSA ERA A ISSUE QUE TÍNHAMOS NA 

ÚLTIMA AULA,

EM QUE, QUANDO DELETÁVAMOS 1 CATEGORY OU FAZÍAMOS 1 UPDATE NO NAME DE 1 CATEGORY,


ÉRAMOS FORÇADOS A RECARREGAR A PAGE, PARA VER O UPDATE NA TABLE..








-> AGORA, COM ESSE 'table.draw()',

não precisamos mais fazer isso...












-> FAZEMOS A MESMA COISA MAIS PARA BAIXO, AQUI:






  document
    .querySelector('.save-category-btn')
    .addEventListener('click', function (event) {
      const categoryId = event.currentTarget.getAttribute('data-id');

      post(
        '/categories/' + categoryId,
        {
          name: editCategoryModal._element.querySelector('input[name="name"]')
            .value,
        },
        editCategoryModal._element
      ).then((response) => {
        if (response.ok) {
          table.draw();
          editCategoryModal.hide();
        }
      });
    });












ISSO TAMBÉM VAI FAZER O REDRAW DA TABLE,



ASSIM QUE tiver acontecido o save...














CERTO... DEPOIS DISSO, RODAMOS NPM INSTALL E NPM RUN DEV...
















A PAGINATION, SORTING E FILTERING QUE CONSTRUÍREMOS NO BACKEND 
FUNCIONARÃO 

EM QUALQUER FRONTEND,

DESDE QUE VC:


1) HOOK IT UP PROPERLY 


2) STRUCTURE THE RESPONSE, AS NEEDED...














-> OK, MAS QUAIS FORAM AS CHANGES NO BACKEND SIDE?










-> O PROFESSOR ADICIONOU UMA NOVA ROUTE,




DENTRO DO 'web.php',






A ROUTE DE '/load',



de tipo get,



QUE É A ROUTE A QUE 




AQUELA DATATABLE VAI FAZER AJAX REQUESTS...










-> TIPO ASSIM:



 




 <?php declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\CategoriesController;
use App\Controllers\HomeController;
use App\Middleware\AuthMiddleware;
use App\Middleware\GuestMiddleware;
use Slim\Routing\RouteCollectorProxy;
use Slim\App;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index'])->add(AuthMiddleware::class);

    $app->group('', function (RouteCollectorProxy $guest) {
        $guest->get('/login', [AuthController::class, 'loginView']);
        $guest->get('/register', [AuthController::class, 'registerView']);
        $guest->post('/login', [AuthController::class, 'login']);
        $guest->post('/register', [AuthController::class, 'register']);
    })->add(GuestMiddleware::class);

    $app->post('/logout', [AuthController::class, 'logOut'])->add(AuthMiddleware::class);

    $app->group('/categories', function (RouteCollectorProxy $categories) {
        $categories->get('', [CategoriesController::class, 'index']);
        $categories->post('', [CategoriesController::class, 'store']);
        $categories->get('/load', [CategoriesController::class, 'load']);
        // If the id is not an integer, this route won't be reached, because the route is defined, with a regular expression, as '/{id:[0-9]+}'.
        $categories->delete('/{id:[0-9]+}', [CategoriesController::class, 'delete']);
        $categories->get('/{id:[0-9]+}', [CategoriesController::class, 'get']);
        $categories->post('/{id:[0-9]+}', [CategoriesController::class, 'update']);
    })->add(AuthMiddleware::class);
};


















OK...






O METHOD DE LOAD, NESSE CONTROLLER, POR SUA VEZ,

FICOU ASSIM:











    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = array_map(
            function(Category $category) {
                return [
                    'id' => $category->getId(),
                    'name' => $category->getName(),
                    'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                    'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
                ];
            }, 
            $this->categoryService->getAll()
        );

        return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),
        ]);
    }










--> ESTAMOS FETCHEANDO TODAS AS CATEGORIES, E AÍ 

FORMATANDO-AS NO 


FORMATO SUPORTADO PELO OBJECT 

'DATATABLE',


DO FRONTEND...











--> ANTERIORMENTE,

ESTÁVAMOS PASSANDO 


ESSAS CATEGORIES DENTRO DO 'index()',


MAS AGORA 

ESTAMOS 




FAZENDO ISSO 


POR MEIO 


DE ESSA ROUTE SEPARADA DE 'load'...








-> NÃO ESTAMOS MAIS RENDERIZANDO AS CATEGORIES DIRETAMENTE NO TEMPLATE...







-> EXPLICAÇÃO:



    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = array_map(
            function(Category $category) {
                return [
                    'id' => $category->getId(),
                    'name' => $category->getName(),
                    'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                    'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
                ];
            }, 
            $this->categoryService->getAll()
        );

        return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),
        ]);
    }











-> ESTAMOS:





1) PEGANDO OS QUERY PARAMETERS DO REQUEST 



2) FETCHEANDO TODAS AS CATEGORIES...





3) APLICANDO A FUNCTION DE 'ARRAY_MAP' 

EM CIMA DE ESSE ARRAY,


PARA BASICAMENTE LOOPAR EM CADA CATEGORY OBJECT,


E PARA AÍ TRANSFORMAR CADA ENTIDADE 'CATEGORY'

EM 1 ARRAY 

COMPATÍVEL COM A DATATABLE..






AS KEYS SÃO O QUE É MAPPEADO NA PARTE DO JAVASCRIPT, NO FRONTEND....




(tipo 

"{data: name}",
"{data: createdAt}"


)



SE NÃO PASSAMOS DATA NESSA ESTRUTURA, FICAMOS COM ERRORS...











--> ASSIM QUE AS CATEGORIES SÃO TODAS PROPERLY FORMATTED,
    retornamos 1 json response,


    formatada do jeito que 

    a datatable 
    consegue compreender...






--> TEMOS A OPTION DE 'draw',   também,
    que 

    logo explicaremos...




    ex:



            return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),
        ]);











ISSO É TUDO...









A DIFERENÇA ENTRE 'RECORDS TOTAL'


E 

'RECORDS FILTERED'



É QUE 



'RECORDS TOTAL' É O NÚMERO DE RECORDS ANTES DE APLICAR FILTERS AOS RESULTS...