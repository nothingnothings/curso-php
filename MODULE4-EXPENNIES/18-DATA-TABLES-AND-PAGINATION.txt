








HOJE VEREMOS PAGINATION NA TABLE DE CATEGORIES...









-> O PROFESSOR MUDOU 1 POUCO A UI 

DA PAGE DE CATEGORIES...



AGORA TEMOS:




1) SEARCH BOX 





2) SORTING INDICATORS NAS COLUMNS 





3) DROPDOWN (que nos deixa selecionar quantas entries queremos na table)...









4) BEEEEM LÁ PARA BAIXO,

    TEMOS AS PAGINATION PAGES,

    E AÍ 



    OS BUTTONS DE PREVIOUS E NEXT...









--> É CLARO QUE A PAGINATION AINDA NÃO FUNCIONA...









AINDA VAMOS BUILDAR ISSO...








-> SE CLICAMOS NAS PAGES,
A DATA NÃO MUDA,



PQ A PAGE REALMENTE FAZ O DISPLAY DE TODOS OS ROWS QUE 

TEMOS NA TABLE DE 'CATEGORIES'...











->  O NEGÓCIO DIZ QUE SÃO '10 items per view',


MAS ESTAMOS ACTUALLY FAZENDO DISPLAY DE TODOS OS ITEMS...













--> PARA FAZER A PAGINATION FUNCIONAR,


O PROFESSOR DECIDIU USAR A THIRD PARTY LIBRARY 'DATA TABLESa'...















datatables.net...










-> É UMA LIBRARY GRÁTIS..





-> UMA DESVANTAGEM É QUE __ ELA USA __ JQUERY COMO DEPENDENCY...








-> ENTRETANTO,

    A BOA NOTÍCIA É QUE 

    NÃO PRECISAMOS ADICIONAR JQUERY COMO DEPENDENCY 
    DIRETA NO NOSSO APP...










-> QUER DIZER QUE PODEMOS AINDA INICIALIZAR E TRABALHAR 
COM 'DATA TABLES' (pacote) 

NO JAVASCRIPT, MESMO SEM O JQUERY...









-> VC TAMBÉM PODE USAR OUTRA TABLE LIBRARY, SE QUISER... OU CONSTRUIR 
1 FROM SCRATCH...









-> VAMOS CONSTRUIR A PARTE BACKEND,
PARA TER:



1) PAGINATION 


2) SORTING AND FILTERING OPTIONS,





tudo isso dentro de nossas queries....










-> TAMBÉM VEREMOS COMO ESTRUTURAR 

A RESPONSE DE UMA MANEIRA UNDERSTANDABLE,


TUDO PARA QUE SEJA 


ENTENDIDA PELA TABLE LIBRARY ESPECÍFICA QUE ESTAMOS UTILIZANDO...
















-> O PROFESSOR MOSTRA UM POUCO DO SETUP QUE ELE FEZ,

POR TRÁS DAS CENAS..










-> O PROFESSOR ADICIONOU 2 DEPENDENCIES:




1) datatables.net 



2) datatables.net.dt 







-> O SEGUNDO PACKAGE É APENAS SOBRE O STYLING DAS DATA TABLES...









-> O CORE PACKAGE É REALMENTE 'datatables.net'....






-> EM 'app.scss',




É POSSÍVEL VISUALIZAR OS IMPORTS DE DATA TABLES,


QUE SÃO ASSIM:











@import "./variables.scss";
@import "~bootstrap/scss/bootstrap";
@import "~bootstrap-icons/font/bootstrap-icons";
@import "~datatables.net/css/jquery.dataTables.css";


* {
  font-family: 'Roboto', sans-serif !important;
}

body {
  background-color: #e7ebee;
}

svg.icon {
  width: 25px;
  height: 25px;
}

.nav-link {
  color: #9aa0a9;

  &.active {
    background-color: inherit !important;
    color: #57585A !important;
  }

  &:hover, &:focus {
    color: #57585A !important;
  }
}












OK... É BASICAMENTE OS STYLES DAQUELE OUTRO PACOTE...









--> LÁ EM 'index.twig'

das categories,

temos esta parte:















{% extends 'layout.twig' %}

{% block javascripts %}
    {{ parent() }}
    {{ encore_entry_script_tags('categories') }}
{% endblock %}

{% block title %}Categories{% endblock %}

{% block content %}
    <div class="categories container content-body">
        <div class="text-end">
            <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newCategoryModal">
                <i class="bi bi-plus-circle me-1"></i>
                New Category
            </button>
        </div>
        <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <form action="/categories" method="post">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">New Category</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            {{ csrf.fields | raw }}
                            <div class="form-outline form-white mb-4">
                                <input type="text" name="name" required
                                       class="form-control form-control-lg"
                                       placeholder="Category Name" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle me-1"></i>
                                Close
                            </button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle me-1"></i>
                                Create
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
        {% include 'categories/edit_category_modal.twig' %}
        {% if categories %}
            <div id="categoriesTable">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Created At</th>
                            <th>Updated At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for category in categories %}
                            <tr>
                                <td>{{ category.name }}</td>
                                <td>{{ category.createdAt | date('m/d/Y g:i A') }}</td>
                                <td>{{ category.updatedAt | date('m/d/Y g:i A') }}</td>
                                <td>
                                    <div class="d-flex flex-">
                                        <form action="/categories/{{ category.id }}" method="post">
                                            {{ csrf.fields | raw }}
                                            <input type="hidden" name="_METHOD" value="DELETE" />
                                            <button type="submit" class="btn btn-outline-primary">
                                                <i class="bi bi-trash3-fill"></i>
                                            </button>
                                        </form>
                                        <button class="ms-2 btn btn-outline-primary edit-category-btn"
                                                data-id="{{ category.id }}">
                                            <i class="bi bi-pencil-fill"></i>
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% endif %}
    </div>
{% endblock %}









MAS ESSE CÓDIGO MUDOU 1 POUCO, AGORA É ASSIM:










            <div>
                <table id="categoriesTable">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Created At</th>
                            <th>Updated At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
















CERTO... ESTAMOS MOSTRANDO APENAS AS COLUMNS,


E AÍ ESTAMOS MOSTRANDO A TABLE...







-> a table fica dentro de '<tbody>'</tbody>',

NESSE CASO...








-> ESSE TBODY, NESSE CASO,


É 'POPULATED, USING DATA FROM THE BACKEND,
 
    IN THE FRONTEND, USING JAVASCRIPT'...






EX:







{% extends 'layout.twig' %}

{% block javascripts %}
	{{ parent() }}
	{{ encore_entry_script_tags('categories') }}
{% endblock %}

{% block title %}Categories
{% endblock %}

{% block content %}
	<div class="categories container content-body">
		<div class="text-end">
			<button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newCategoryModal">
				<i class="bi bi-plus-circle me-1"></i>
				New Category
			</button>
		</div>
		<div class="modal fade" id="newCategoryModal" tabindex="-1" aria-hidden="true">
			<div class="modal-dialog">
				<form action="/categories" method="post">
					<div class="modal-content">
						<div class="modal-header">
							<h5 class="modal-title">New Category</h5>
							<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
						</div>
						<div class="modal-body">
							{{ csrf.fields | raw }}
							<div class="form-outline form-white mb-4">
								<input type="text" name="name" required class="form-control form-control-lg" placeholder="Category Name"/>
							</div>
						</div>
						<div class="modal-footer">
							<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
								<i class="bi bi-x-circle me-1"></i>
								Close
							</button>
							<button type="submit" class="btn btn-success">
								<i class="bi bi-check-circle me-1"></i>
								Create
							</button>
						</div>
					</div>
				</form>
			</div>
		</div>
		{% include 'categories/edit_category_modal.twig' %}
		<div>
			<table id="categoriesTable">
				<thead>
					<tr>
						<th>Name</th>
						<th>Created At</th>
						<th>Updated At</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody></tbody>
			</table>
		</div>
	</div>
{% endblock %}















-> OK, MAS QUAL É O JAVASCRIPT QUE FOI UTILIZADO?





-> PRIMEIRAMENTE, INSTALE OS PACOTES,

COM 

npm install datatables.net datatables.net-dt









E O JAVASCRIPT É TIPO ASSIM:






import Datatable from "datatables.net";









IMPORTAMOS ESSE COMPONENTE AÍ...








-> DEPOIS DISSO,



VAMOS CRIAR 1 NOVO OBJECT 'DataTable',




COM ESTE CÓDIGO:





window.addEventListener('DOMContentLoaded', function () {
  const editCategoryModal = new Modal(
    document.getElementById('editCategoryModal')
  );

  const table = new Datatable('#categoriesTable', {});











  PRECISAMOS PASSAR VÁRIAS OPTIONS A ESSE OBJECT 'DataTable'...






  -> ENTRE ELAS, AS OPTIONS:



  serverSide: true/false 


  ajax: '/categories/load',

  orderMulti: false, 


  columns: [
    {data: 'name'},
    {data: 'createdAt'},
    {data: 'updatedAt'}
  ],

  sortable: false,

  data: row => ...















  VAI FICANDO TIPO ASSIM:




  



  

AS OPTIONS SÃO:







serverSide --> deixamos como TRUE,
            PQ VAMOS QUERER FETCHEAR A DATA 
            LÁ DO SERVERSIDE...






ajax --> '/categories/load' --> 
                            ISSO É USADO 
                            PARA 

                            ESPECIFICAR 

                            A URL 

                            DE ONDE VAMOS 

                            FETCHEAR A DATA...

                            --> NO CASO,

                            SERÁ 'categories/load'...





'orderMulti' --> true/false...



                    vc pode escolher se SERÁ 
                    POSSÍVEL FAZER 'SORT'

                    considerando MULTI COLUMN ou não 




'columns' --> É A DISTRIBUIÇÃO DA SUA DATA,
                EM QUE COLUMNS FICARÁ...





--> CADA COLUMN 




VAI TER INFO PRÓPRIA...






tipo assim:





{data: 'name'},
{data: 'createdAt'},
{data: 'updatedAt'},
{
    sortable: false,
    data: row => `<div class="d-flex flex">
                    <button type="submit" class="btn btn-outline-primary delete-category-btn" data-id="${row.id}">
                        <i class="bi bi-trash3-fill"></i>
                    </button>
                    <button type="submit" class="btn btn-outline-primary edit-category-btn" data-id="${row.id}">
                        <i class="bi bi-pencil-fill"></i>
                    </button>
                </div>
                `
                
}







OU SEJA,



ISSO VAI DEFINIR A DATA DE CADA COLUMN...






NAS COLUMNS 'NORMAIS',


TEMOS AS KEYS DE CADA COLUMN,


QUE É RETORNADA EM CADA RESPONSE...






OU SEJA,


A RESPONSE 

É UM JSON OBJECT COM 

1 ARRAY DE VALUES,


EM QUE CADA VALUE OBJECT 

POSSUI 


SA PROPRIEDADES DE 'name', 'createdAt' 

e 'upadtedAt'...









-> OK... TODAS AS COLUMNS ESTARÃO 
REPRESENTADAS NESSES JSON objects..










--> A ÚNICA EXCEÇÃO É A ÚLTIMA COLUMN,

QUE NÃO SERÁ EXATAMENTE 

ALGO QUE PULLAMOS DA DATABASE, DO SERVER,



E SIM 

FAZEMOS DISPLAY DE CUSTOM HTML (pq 

são os buttons de 'edit' e 'delete'...)






--> NÓS TAMBÉM DESABILITAMOS SORTING NESSA ÚLTIMA COLUMN,
PQ ISSO BUGARIA TUDO....













-> OK... ISSO É TUDO, QUANTO AOS TABLE OBJECTS... 





'''AND THAT IS PRETTY MUCH IT AS FAR AS THE TABLE OBJECTS 
GO... IT TAKES __ CARE__ OF MAKING THE REQUEST TO THE 
SERVER, WHENEVER SOME ACTION HAPPENS ON THE TABLE (
    like user sorts table by a specific column,

    enters text in the search bar, 


    or uses the pagination (forward and previous buttons)
)









-> O PROFESSOR QUER FALAR DE OUTRA PARTE EM QUE FEZ 
AJUSTES....





-> É ESTA PARTE AQUI:






    document.querySelector('#categoriesTable').addEventListener('click', function (event) {
        const editBtn   = event.target.closest('.edit-category-btn')
        const deleteBtn = event.target.closest('.delete-category-btn')

        if (editBtn) {
            const categoryId = editBtn.getAttribute('data-id')

            get(`/categories/${ categoryId }`)
                .then(response => response.json())
                .then(response => openEditCategoryModal(editCategoryModal, response))
        } else {
            const categoryId = deleteBtn.getAttribute('data-id')

            if (confirm('Are you sure you want to delete this category?')) {
                del(`/categories/${ categoryId }`).then(response => {
                    if (response.ok) {
                        table.draw()
                    }
                })
            }
        }
    })









é a parte 

que adiciona o event de 'click' 



a esse elemento '#categoriesTable'

inteiro..





-> ESSES EVENT LISTENERS SÃO ADICIONADOS 

NA TABLE QUE É 
O PARENT 


DAQUELES BUTTONS QUE SÃO ADICIONADOS DINAMICAMENTE...








-> COM O 'IF/ELSE',

checamos se foi o button de EDIT ou o de DELETE 

que foi clicado,



E AÍ REALIZAMOS AS ACTIONS APROPRIADAS PARA AQUELE BUTTON...












-> essa 'selection' do editBtn e deleteBtn acontece 

NO MOMENTO DO CLICK 



pq isso só pode acontecer depois da table ser carregada...







-> IMPORTANTE TAMBÉM É AQUELA FUNCTION DE 'table.draw()',

que aparece no final...








-> ESSA FUNCTION BASICAMENTE FAZ RE-DRAW/RELOAD DA TABLE,

PARA QUE A DATA SEJA ATUALIZADA... ESSA ERA A ISSUE QUE TÍNHAMOS NA 

ÚLTIMA AULA,

EM QUE, QUANDO DELETÁVAMOS 1 CATEGORY OU FAZÍAMOS 1 UPDATE NO NAME DE 1 CATEGORY,


ÉRAMOS FORÇADOS A RECARREGAR A PAGE, PARA VER O UPDATE NA TABLE..








-> AGORA, COM ESSE 'table.draw()',

não precisamos mais fazer isso...












-> FAZEMOS A MESMA COISA MAIS PARA BAIXO, AQUI:






  document
    .querySelector('.save-category-btn')
    .addEventListener('click', function (event) {
      const categoryId = event.currentTarget.getAttribute('data-id');

      post(
        '/categories/' + categoryId,
        {
          name: editCategoryModal._element.querySelector('input[name="name"]')
            .value,
        },
        editCategoryModal._element
      ).then((response) => {
        if (response.ok) {
          table.draw();
          editCategoryModal.hide();
        }
      });
    });












ISSO TAMBÉM VAI FAZER O REDRAW DA TABLE,



ASSIM QUE tiver acontecido o save...














CERTO... DEPOIS DISSO, RODAMOS NPM INSTALL E NPM RUN DEV...
















A PAGINATION, SORTING E FILTERING QUE CONSTRUÍREMOS NO BACKEND 
FUNCIONARÃO 

EM QUALQUER FRONTEND,

DESDE QUE VC:


1) HOOK IT UP PROPERLY 


2) STRUCTURE THE RESPONSE, AS NEEDED...














-> OK, MAS QUAIS FORAM AS CHANGES NO BACKEND SIDE?










-> O PROFESSOR ADICIONOU UMA NOVA ROUTE,




DENTRO DO 'web.php',






A ROUTE DE '/load',



de tipo get,



QUE É A ROUTE A QUE 




AQUELA DATATABLE VAI FAZER AJAX REQUESTS...










-> TIPO ASSIM:



 




 <?php declare(strict_types=1);

use App\Controllers\AuthController;
use App\Controllers\CategoriesController;
use App\Controllers\HomeController;
use App\Middleware\AuthMiddleware;
use App\Middleware\GuestMiddleware;
use Slim\Routing\RouteCollectorProxy;
use Slim\App;

return function (App $app) {
    $app->get('/', [HomeController::class, 'index'])->add(AuthMiddleware::class);

    $app->group('', function (RouteCollectorProxy $guest) {
        $guest->get('/login', [AuthController::class, 'loginView']);
        $guest->get('/register', [AuthController::class, 'registerView']);
        $guest->post('/login', [AuthController::class, 'login']);
        $guest->post('/register', [AuthController::class, 'register']);
    })->add(GuestMiddleware::class);

    $app->post('/logout', [AuthController::class, 'logOut'])->add(AuthMiddleware::class);

    $app->group('/categories', function (RouteCollectorProxy $categories) {
        $categories->get('', [CategoriesController::class, 'index']);
        $categories->post('', [CategoriesController::class, 'store']);
        $categories->get('/load', [CategoriesController::class, 'load']);
        // If the id is not an integer, this route won't be reached, because the route is defined, with a regular expression, as '/{id:[0-9]+}'.
        $categories->delete('/{id:[0-9]+}', [CategoriesController::class, 'delete']);
        $categories->get('/{id:[0-9]+}', [CategoriesController::class, 'get']);
        $categories->post('/{id:[0-9]+}', [CategoriesController::class, 'update']);
    })->add(AuthMiddleware::class);
};


















OK...






O METHOD DE LOAD, NESSE CONTROLLER, POR SUA VEZ,

FICOU ASSIM:











    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = array_map(
            function(Category $category) {
                return [
                    'id' => $category->getId(),
                    'name' => $category->getName(),
                    'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                    'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
                ];
            }, 
            $this->categoryService->getAll()
        );

        return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),
        ]);
    }










--> ESTAMOS FETCHEANDO TODAS AS CATEGORIES, E AÍ 

FORMATANDO-AS NO 


FORMATO SUPORTADO PELO OBJECT 

'DATATABLE',


DO FRONTEND...











--> ANTERIORMENTE,

ESTÁVAMOS PASSANDO 


ESSAS CATEGORIES DENTRO DO 'index()',


MAS AGORA 

ESTAMOS 




FAZENDO ISSO 


POR MEIO 


DE ESSA ROUTE SEPARADA DE 'load'...








-> NÃO ESTAMOS MAIS RENDERIZANDO AS CATEGORIES DIRETAMENTE NO TEMPLATE...







-> EXPLICAÇÃO:



    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = array_map(
            function(Category $category) {
                return [
                    'id' => $category->getId(),
                    'name' => $category->getName(),
                    'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                    'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
                ];
            }, 
            $this->categoryService->getAll()
        );

        return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),
        ]);
    }











-> ESTAMOS:





1) PEGANDO OS QUERY PARAMETERS DO REQUEST 



2) FETCHEANDO TODAS AS CATEGORIES...





3) APLICANDO A FUNCTION DE 'ARRAY_MAP' 

EM CIMA DE ESSE ARRAY,


PARA BASICAMENTE LOOPAR EM CADA CATEGORY OBJECT,


E PARA AÍ TRANSFORMAR CADA ENTIDADE 'CATEGORY'

EM 1 ARRAY 

COMPATÍVEL COM A DATATABLE..






AS KEYS SÃO O QUE É MAPPEADO NA PARTE DO JAVASCRIPT, NO FRONTEND....




(tipo 

"{data: name}",
"{data: createdAt}"


)



SE NÃO PASSAMOS DATA NESSA ESTRUTURA, FICAMOS COM ERRORS...











--> ASSIM QUE AS CATEGORIES SÃO TODAS PROPERLY FORMATTED,
    retornamos 1 json response,


    formatada do jeito que 

    a datatable 
    consegue compreender...






--> TEMOS A OPTION DE 'draw',   também,
    que 

    logo explicaremos...




    ex:



            return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),
        ]);











ISSO É TUDO...









A DIFERENÇA ENTRE 'RECORDS TOTAL'


E 

'RECORDS FILTERED'



É QUE 



'RECORDS TOTAL' É O NÚMERO DE RECORDS ANTES DE APLICAR FILTERS AOS RESULTS...










-> 'records filtered' -> é o número de records depois do filter 

ser aplicado 

à query...






-> NESSA PARTE,

ESTAMOS DEFININDO 
O VALUE 


DE 'FILTERED' E 'TOTAL' COMO 

O MESMO NÚMERO,



COM ESTA LÓGICA:



            'recordsTotal' => count($categories),
            'recordsFiltered' => count($categories),










-> MAIS PARA BAIXO, NA NOSSA PÁGINA,

TEMOS AQUELE TEXT QUE DIZ 



''SHOWING 1 TO 10 OF 59 ENTRIES''....










-> DEPOIS QUE ADICIONARMOS FILTERING 
    NO NOSSO APP, 

    ISSO VAI MUDAR...










-> O PROFESSOR SIMULA ISSO (número de records totais maior do que os filtered),


com este código:





            'recordsTotal' => count($categories) + 5,
            'recordsFiltered' => count($categories),









COM ISSO,


FICAMOS CMO 1 MESSAGE DIFERENTE,

DE 



' ''SHOWING 1 TO 10 OF 59 ENTRIES (filtered from 64 total entries)''


















-> VC PODE ESCOLHER A MANEIRA PELA QUAL VC FAZ SHOW DE ESSA INFORMATION.






-> O PROFESSOR PREFERE ESSE SIMPLES SHOW DE TEXT,


SEM ESSA PARTE DE 

'(filtered from 64 total entries)'....


E É EXATAMENTE POR ISSO QUE ELE DEFINIU 


ESSAS 2 KEYS,


'total' e 'filtered',

como o mesmo count value...













-> O PROFESSOR DIZ QUE PODEMOS ADICIONAR 1 MICROOPTIMIZATION,

ESCREVENDO ASSIM:







        $categoryAmount = count($categories);

        return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => $categoryAmount,
            'recordsFiltered' => $categoryAmount,
        ]);
















OK...











-> O PROFESSOR ENTÃO NOS EXPLICA O MOTIVO DO PARAMETER DE 



'draw'...











-> ESSE PARAMETER DE 'draw' 


é 


'''ACTUALLY A _ SEQUENCE NUMBER _ ATTACHED 
    TO A __ REQUEST'''....






''''AND THIS SEQUENCE NUMBER GETS INCREMENTED,
FOR EVERY REQUEST....''''






''''AND THE DATA TABLE USES THIS "SEQUENCE NUMBER"
    TO DRAW THE CORRECT PAGE'''






-> QUER DIZER QUE O 'draw'

É ALGO QUE A DATA TABLE, NO FRONTEND, USA INTERNAMENTE...
















-> CERTO... MAS AGORA DEVEMOS COMEÇAR,

VER COMO PODEMOS FAZER ESSA PAGINATION FUNCIONAR..









-> MAIS TARDE VEREMOS COMO PODEMOS FAZER O SORTING E PAGINATION FUNCIONAREM...
















-> PARA BUILDAR PAGINATION,
    PRECISAMOS BASICAMENTE 



    UTILIZAR AS OPTIONS DE 'LIMIT' E 'OFFSET'

    DENTRO DAS QUERIES...









-> FELIZMENTE, O DOCTRINE ORM QUERY BUILDER
    JÁ POSSUI BUILT-IN METHODS  
    QUE PODEMOS UTILIZAR 

    __ PARA __ SETUPPAR ESSAS OPTIONS...










-> PARA ISSO, 


''WE NEED TO ___EXTRACT_ THE 
    LIMIT AND OFFSET, FROM THE QUERY PARAMETERS ('$params = $request->getQueryParams()'),
    AND THEN _ PASS THEM DOWN TO THE METHOD THAT WILL THEN ACTUALLY APPLY IT TO THE QUERY...'
















-> a primeira coisa que faremos, aqui,

é renomear 



aquele method de 


'$this->categoryService->getAll()''


para outra coisa,


como 




'getPaginatedCategories()',



PQ NÓS REALMENTE NUNCA VAMOS querer 
pegar 

todas as categories de 1 só vez...








CERTO...









-> AÍ, COM ISSO, 




TEREMOS ESSE METHOD DE 'getPaginatedCategories',



LÁ NO categoryService..











VAMOS ESCREVENDO ASSIM:







    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = array_map(
            function(Category $category) {
                return [
                    'id' => $category->getId(),
                    'name' => $category->getName(),
                    'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                    'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
                ];
            }, 
            // $this->categoryService->getAll() // ! We'll never need to actually fetch all categories in a single go. We'll always need to fetch only the paginated categories (page by page, with limit and offset).
            $this->categoryService->getPaginatedCategories($params['length'], $params['start'])
        );

        $categoryAmount = count($categories);

        return $this->responseFormatter->asJson($response, [
            'data' => $categories,
            'draw' => (int) $params['draw'],
            'recordsTotal' => $categoryAmount,
            'recordsFiltered' => $categoryAmount,
        ]);
    }










E ASSIM:







    // Used with pagination.
    public function getPaginatedCategories(): array
    {
    }










CERTO...







AÍ, DENTRO DISSO, NÃO VAMOS USAR 'findAll()',

e sim 



VAMOS 


'GET THE QUERY BUILDER, AND THEN APPLY THE LIMIT AND OFFSET...''








--> PODEMOS ACEITAR O LIMIT E OFFSET COMO PARAMETERS DA FUNCTION,

TIPO ASSIM:





    // Used with pagination.
    public function getPaginatedCategories(int $start, int $length): array
    {
        $qb = $this->entityManager->createQueryBuilder();

    }













COMO VC PODE PERCEBER, AQUI JÁ CRIAMOS 


O QUERY BUILDER,

PARA ENTÃO CONSEGUIRMOS 

CRIAR A LÓGICA PARA RETRIEVE COM O LIMIT E OFFSET...






CERTO... MAS, AQUI,

TEMOS 1 ERRO/DIFERENÇA EM RELAÇÃO AO CÓDIGO DO PROFESSOR....









-> O PROFESSOR USOU 'getRepository(Category::class)',

ANTES DE CHAMAR O 'createQueryBuilder()',

TIPO ASSIM:







  $qb = $this->entityManager->getRepository(Category::class)->createQueryBuilder('c');














  COM ISSO, NÓS CRIAMOS UM QUERY BUILDER PARA A TABLE DE 'categories',

  ao mesmo tempo que 
  definimos um alias de 'c' para ela...













  -> AÍ, OS METHODS PARA APLICAR 'LIMIT' E 'OFFSET' SÃO:






1) 'setFirstResult()'  --> COMO PARAMETER DISSO, COLOCAMOS AQUELE VALUE DE '$start'... 
                            ESSE É BASICAMENTE O PARAMETER CORRESPONDENTE A 'offset'...
                             IT IS THE NUMBER OF ROWS TO _ SKIP__...




2) 'setMaxResult()' ->  É BASICAMENTE O LIMIT.... NÚMERO MÁXIMO DE RECORDS A SEREM RETRIEVADOS, POR VEZ...









EX:






        ->setFirstResult($start) // offset. It is the number of rows to skip.
        ->setMaxResults($length); // limit. It is the maximum number of rows to retrieve.








ex:







     $qb = $this->entityManager->getRepository(Category::class)
        ->createQueryBuilder('c')  // alias of the table will be 'c'.
        ->setFirstResult($start) // offset. It is the number of rows to skip.
        ->setMaxResults($length); // limit. It is the maximum number of rows to retrieve.












CERTO...






ISSO FEITO, FINALMENTE, PODEMOS RETORNAR O RESULT 


DA QUERY,


COM 


'return $query->getQuery()->getResult();'





EX:






    // Used with pagination.
    public function getPaginatedCategories(int $start, int $length): array
    {
        $query = $this->entityManager->getRepository(Category::class)
        ->createQueryBuilder('c')  // alias of the table will be 'c'.
        ->setFirstResult($start) // offset. It is the number of rows to skip.
        ->setMaxResults($length); // limit. It is the maximum number of rows to retrieve.


        return $query->getQuery()->getResult();
    }












CERTO...









--> AGORA VOLTAMOS AO CONTROLLER, PARA PASSAR OS 2 PARAMETERS 

NESSE METHOD....








    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = array_map(
            function(Category $category) {
                return [
                    'id' => $category->getId(),
                    'name' => $category->getName(),
                    'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                    'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
                ];
            }, 
            // $this->categoryService->getAll() // ! We'll never need to actually fetch all categories in a single go. We'll always need to fetch only the paginated categories (page by page, with limit and offset).
            $this->categoryService->getPaginatedCategories($params['start'], $params['length'])
        );















VAMOS OBTER ESSES VALUES LÁ DAS KEYS DO PARAMS,

BASICAMENTE...













--> O PROFESSOR COLOCA 1 VAR_DUMP DE '$params',

para ver COMO PODEMOS 




EXTRAIR ESSES PARAMETER VALUES DO REQUEST...
















-> por default,

o datatables faz sort considerando o NAME,


em ordem alfabética...











-> DENTRO DE ESSE VAR_DUMP,



ficamos com vários values,



mas o que nos interessa 





é a parte de 'start' e 'length'....












NÓS TAMBÉM TEMOS O PARAMETER DE 'search',


que 
contém o value que estamos 'searching for'...











-> também temos o regex, mas não vamos nos preocupar com isso agora.. usaremos isso 
com o filtering, mais tarde...









-> MAS AGORA VAMOS EXTRAIR O 'start' e o 'length',

e aí fazer PASS DOWN DISSO A NOSSA QUERY..










-> É POR ISSO QUE O PROFESSOR ESCREVE ASSIM:






            $this->categoryService->getPaginatedCategories($params['start'], $params['length'])












-> O PROFESSOR TAMBÉM CASTA ESSES NEGÓGIOS COMO INTEGERS,

PQ  ELAS SERÃO STRINGS POR DEFAULT..













-> ESCREVEMOS ASSIM:



            $this->categoryService->getPaginatedCategories((int) $params['start'], (int) $params['length'])











MAIS TARDE, PODEMOS REFORMATAR ISSO COMO UM DTO...








MAS NÃO FAREMOS ISSO AGORA...










-> E ISSO FUNCIONOU,
PQ 

AGORA 

TEMOS 



APENAS 10 ROWS POR PAGE... 




QUER DIZER QUE 


''IT HAS LIMITED THE DISPLAY 
TO ONLY 10 ROWS''...








-> MAS NENHUM BUTTON DAS OUTRAS PAGES APARECEU NA PARTE INFERIOR,

O QUE QUER DIZER QUE A PAGINATION NÃO ESTÁ FUNCIONANDO DE VERDADE AINDA...















-> MAS A PARTE DE LIMIT E OFFSET JÁ ESTÃO 
FUNCIONANDO COMO O ESPERADO...













-> ESTÃO FUNCIONANDO POR CONTA DISTO, NO FRONTEND:









In your JavaScript code, the query parameters for pagination are managed by the DataTables library. Here's a detailed look at how this works and how the query parameters are handled:

DataTables Configuration
In your DataTables initialization, you have the serverSide option set to true and an ajax URL provided:

javascript
Copiar código
const table = new DataTable('#categoriesTable', {
  serverSide: true,
  ajax: '/categories/load',
  orderMulti: false,
  columns: [
    // Column definitions...
  ],
});











quer dizer que é a própria lib de 'datatables'

que está formatando a url e enfiando esses query parameters,

automaticamente....









Your JavaScript code initializes the DataTable with server-side processing enabled and provides a URL for the DataTables AJAX requests. The library takes care of sending the correct query parameters to your server and processing the server’s response to update the table.



Você disse:
what are the defaults of datatable
O ChatGPT disse:
ChatGPT
DataTables is a highly customizable library, but it comes with a set of default settings that control its behavior and appearance. Here’s a summary of some key default settings in DataTables:

Default Settings
Pagination:

paging: true (Pagination is enabled by default).
pagingType: 'simple_numbers' (The default pagination control shows "Previous", page numbers, and "Next" buttons).
Ordering:

ordering: true (Column sorting is enabled by default).
order: [] (No default sorting order; sorting is based on user interaction).
Searching:

searching: true (A search box is included by default).
search: An empty string '' (No default search term).
Information Display:

info: true (Information about the current page and the total number of records is displayed by default).
Length Menu:

lengthMenu: [10, 25, 50, 100] (Options for the number of records per page are 10, 25, 50, and 100).
Page Length:

pageLength: 10 (The default number of records per page is 10).
Display Length:

lengthChange: true (Allows users to change the number of records displayed per page).
DOM Structure:

dom: 'lfrtip' (Defines the layout of the table controls; includes the length changing input, filtering input, table, and pagination controls).
Server-Side Processing:

serverSide: false (Server-side processing is not enabled by default; DataTables operates in client-side mode).
Language:

language: (Contains default text strings for various UI elements, such as search input labels and pagination text).
Ajax:

ajax: null (No default AJAX source; data is expected to be provided directly).
Example of Default Configuration
If you initialize a DataTable with no options, it uses the default settings:






































certo...








MAS A PAGINATION __ AINDA NÃO ESTÁ FUNCIONANDO...












MAS PQ NÃO ESTÁ FUNCIONANDO?










A RAZÃO PARA ISSO NÃO ESTAR FUNCIONANDO 




É O NÚMERO DE 'TOTAL ENTRIES'...







-> O NÚMERO/COUNT DE 'TOTAL ENTRIES'

ESTÁ ERRADO...









-> A FUNCTION DE COUNT,


QUE TEMOS AQUI:






        $categoryAmount = count($categories);









ESTÁ CONTANDO A QUANTIDADE DE CATEGORIES QUE SÃO RETORNADAS POR AQUELA NOSSA QUERY,

E NÃO 


A QUANTIDADE DE CATEGORIES __ REALMENTE __ TOTAL__


DA NOSSA TABLE...








-> PARA CONSERTAR ISSO, BASTA CRIAR UM NOVO METHOD EM 'categoryService',


QUE FAÇA ESSE COUNT AÍ... 













-> E É PRECISAMENTE POR CONTA DISSO QUE NENHUMA OUTRA PAGE/BUTTON DE PAGE 

ESTÁ APARECENDO, NAQUELA PARTE INFERIOR...













-> BASICAMENTE, PRECISAMOS DO TOTAL COUNT 

SEM O OFFSET E LIMIT SENDO APLICADOS A QUERY...












-> PODEMOS BUILDAR HANDLING PARA ISSO, MANUALMENTE,


OU, ENTÃO,

USAR A CLASS DE 'PAGINATOR' 

BUILT-IN,
 

 DO DOCTRINE ORM....














-> PARA ISSO, PARA TER ESSE COUNT CORRETO,


PODEMOS VOLTAR AO CATEGORYSERVICE,



LÁ NO 'getPaginatedCategories',


 


PODEMOS CRIAR 1 NOVA INSTANCE 


DA CLASS DE 'Paginator',

e aí passar 





O QUERY OBJECT COMO ARGUMENT....












-> É POR ISSO QUE, LÁ EM 'getPaginatedCategories',




VAMOS RETORNAR 

NÃO A QUERY EM SI,


E SIM 


VAMOS RETORNAR 



UMA INSTANCE DE 'paginator',


com a query já embutida nele...









-> TIPO ASSIM:







    // Used with pagination.
    public function getPaginatedCategories(int $start, int $length): Paginator
    {
        $query = $this->entityManager->getRepository(Category::class)
        ->createQueryBuilder('c')  // alias of the table will be 'c'.
        ->setFirstResult($start) // offset. It is the number of rows to skip.
        ->setMaxResults($length); // limit. It is the maximum number of rows to retrieve.


        // return $query->getQuery()->getResult();
        return new Paginator($query);
    }












-> a vantagem de 'Paginator'

é que 

ele funciona TAMBÉM COM 


'count()',



MESMO NÃO SENDO 1 ARRAY,



ISSO PQ ELE IMPLEMENTA A INTERFACE DE 'Countable'... (o que faz com que exista o method de 'count()', no seu interior)...










IteratorAggregate --> É UMA INTERFACE QUE NOS DEIXA 'ITERATE OVER AN OBJECt',

                        como se ele fosse 1 array....
















-> O PROFESSOR REFORMATA ISSO,


TIPO ASSIM:










    public function load(Request $request, Response $response): Response
    {
        $params = $request->getQueryParams();

        $categories = $this->categoryService->getPaginatedCategories((int) $params['start'], (int) $params['length']);

        $transformer = function(Category $category) {
            return [
                'id' => $category->getId(),
                'name' => $category->getName(),
                'createdAt' => $category->getCreatedAt()->format('Y-m-d H:i:s'),
                'updatedAt' => $category->getUpdatedAt()->format('Y-m-d H:i:s'),
            ];
        };

        $categoryAmount = count($categories);

        return $this->responseFormatter->asJson($response, [
            'data' => array_map($transformer, (array) $categories->getIterator()),
            'draw' => (int) $params['draw'],
            'recordsTotal' => $categoryAmount,
            'recordsFiltered' => $categoryAmount,
        ]);
    }












Ficou bem mais difícil de ler, mas mais 
conciso...













 A PAGE FUNCIONA COMO ANTES,

 E AGORA 

 A PAGINATION FUNCIONA...







 -> FICAMOS COM 6 PAGES,

 E É POSSÍVEL VER 



 'SHOWING 1 TO 10 OF 59 ENTRIES''..










 -> A PAGINATION ESTÁ FUNCIONANDO CORRETAMENTE,

 PQ AGORA ESTÁ 'LOADING THE SECOND PAGE OF THE CATEGORIES'...











 -> OS BUTTONS DE 'NEXT' E 'PREVIOUS' TAMBÉM FUNCIONAM...








 -> TAMBÉM PODEMOS AUMENTAR O LIMIT DE CATEGORIES QUE SÃO MOSTRADAS POR PAGE, SEM PROBLEMAS...










 CERTO... AGORA QUE A PAGINATION ESTÁ FUNCIONANDO,

 A PRÓXIMA ETAPA 



É ADICIONAR SORTING E FILTERING...




