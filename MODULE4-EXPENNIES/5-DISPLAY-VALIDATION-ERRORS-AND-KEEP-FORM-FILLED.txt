







NO ÚLTIMO VIDEO, ADICIONAMOS VALIDATION (FORM VALIDATION)

E VALIDATION HANDLING... 












NESTE VÍDEO,


PRECISAMOS FLASHAR OS ERRORS QUE RECEBEMOS DA VALIDATIONEXCEPTION,


TUDO PARA QUE CONSIGAMOS FAZER DISPLAY DELES,

DURANTE O PRÓXIMO REQUEST...















--> UMA MANEIRA DE FAZER PERSIST DE DATA,
    DE 1 REQUEST PARA OUTRO REQUEST,


    É POR MEIO DE _ SESSIONS_...











-> NOSSO CÓDIGO DE 'ValidationExceptionMiddleware',

ATUALMENTE,

ESTÁ ASSIM:






<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\ValidationException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class ValidationExceptionMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            // var_dump($e->errors());

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }
}











-->  ESSE MIDDLEWARE HANDLA O CATCHING DAS 
    VALIDATION EXCEPTIONS...








-> DENTRO DELE, PODEMOS FAZER ALGO COMO

 
 __ O _ SAVE_ DOS ERRORS, DENTRO DE 1 SESSION...







 -> PODEMOS FAZER ISSO POR MEIO __ DESTA SINTAXe:











     public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.

    
            $_SESSION['errors'] = $e->errors;

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }













--> OK... MAS NÓS SABEMOS, COM 100% DE CERTEZA,

QUE ISSO __ NÃO FUNCIONARÁ_...













--> MAS PQ?








--> É PQ 

    NÓS AINDA __ NÃO STARTAMOS SESSION ALGUMA,

    em lugar algum...











-> NA AULA 2.25, 

    SOBRE SESSIONS,


    APRENDEMOS 



    QUE 



    ''WE NEED TO START A SESSION,

    TO BE ABLE TO USE THE _ '$_SESSION' 

    SUPERGLOBAL...''









--> OK, MAS ONDE É UM BOM LUGAR PARA COMEÇAR NOSSA SESSION?











BONS LUGARES:




1) NO INÍCIO DO PROCESSO DE 
'bootstrap', lá em 'bootstrap.php'






2) TER 1 MIDDLEWARE QUE FAZ ISSO,   DEDICADO A ISSO...













-> O PROFESSOR PREFERE O APPROACH DO MIDDLEWARE,


POR ISSO ELE CRIA 1 NOVO MIDDLEWARE 



NA PASTA DE 'Middleware',


DE NOME 

'StartSessionsMiddleware'...











-> VAMOS ESCREVENDO ASSIM:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        $response = $this->responseFactory->createResponse();

        // $response = $response->withAddedHeader('Set-Cookie', 'PHPSESSID=1; path=/');

        return $handler->handle($request->withAttribute('response', $response));
    }
}
















-> MAS O PROFESSOR DIZ QUE PODEMOS COMEÇAR NOSSA SESSION 

COM O CALL DO METHOD DE 

'session_start()',


TIPO ASSIM:














<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        session_start();
    }
}













-> ISSO PODE PARECER BOM, SIM,


    MAS NÓS AINDA PRECISAMOS _ GARANTIR __ QUE 

    'SESSIONS HAVE NOT BEEN STARTED',


    antes de INICIARMOS 1 SESSION..








--> PRECISAMOS DE VÁRIOS IF-ELSE, PORTANTO...











-> NÓS TAMBÉM QUEREMOS GARANTIR QUE 

OS HEADERS 

NÃO FORAM ENVIADOS AINDA...









-> É POR ISSO QUE O PROFESSOR ESCREVE ASSIM:




<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
        }
    }
}













SE A SESSION JÁ ESTIVER COMO ACTIVE,

PODEMOS OU:



1) FAZER THROW DA EXCEPTION DIZENDO QUE A SESSION JÁ FOI STARTED 




2) USAR ISSO, PARA FAZER COM QUE 
    AS SESSIONS SEJAM STARTADAS APENAS 
    SE A SESSION NÃO É 'ACTIVE'...










-> O PROFESSOR QUER FAZER O THROW DA EXCEPTION JUSTAMENTE PQ 
ISSO DEVE _ (TECNICAMENTE) NUNCA ACONTECER... 

E, SE ISSO ACONTECER,

QUEREMOS FAZER CATCH DURANTE O DEVELOPMENT... PQ É UM EXCEPTIONAL
BEHAVIOR,


VAMOS QUERER FAZER CATCH PARA GARANTIR QUE NUNCA VAI ACONTECER NOVAMENTE...






EX:




    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new \SessionException('Session already started.');
        }
    }













OK... AÍ CRIAREMOS ESSA CLASS,


LÁ DENTRO DO 

namespace de 'Exception'...









ELA FARÁ EXTEND DA 'RuntimeException',

coisa básica:











<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\SessionException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new SessionException('Session already started.');
        }
    }
}














ok... 








isso feito, podemos checar se os headers já foram enviados,

com o 


method de 



'headers_sent()'...











--> ESSE METHOD TEM 2 REQUIRED ARGUMENTS:




1) filename 



2) line 






-> mas esses parameters 

podem ser 'empty variables'..







-> ESSAS VARIABLES ACABAM AUTOMATICAMENTE SET 


COMO OS VALUES DO 'filename' 

e 

'line' 


em que os headers já foram sent... vc pode loggar isso,
se quiser...






EX:








<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\SessionException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new SessionException('Session already started.');
        }

        if (headers_sent($filename, $line)) {  // these variables can be empty.
            throw new SessionException('Headers already sent.');
        }
    }
}












FINALMENTE, PODEMOS FAZER O START DA SESSION...







ASSIM:





<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\SessionException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new SessionException('Session already started.');
        }

        if (headers_sent($filename, $line)) {  // these variables can be empty.
            throw new SessionException('Headers already sent.');
        }

        session_start();
    }
}









--> E É CLARO QUE, DEPOIS DISSO, QUEREMOS CONTINUAR 
PROCESSANDO O NOSSO REQUEST...







É POR ISSO QUE O PROFESSOR ESCREVE 



'''


$response = $handler->handle($request);




''',


que é o código normal dos middlewares, para 'passar o request adiante'...
















CERTO.... MAS DEPOIS DE CRIAR ESSA RESPONSE, PRECISAMOS 


FAZER __ SAVE__ DA SESSION/CLOSE DA SESSION,




TUDO PARA KINDOF 

'RELEASE THE LOCK'...












--> FAZEMOS ISSO PARA QUE, SE EXISTIREM QUAISQUER CONCURRENT 
WRITES A SESSION, ISSO NÃO VAI 'HOLD' O SCRIPT...









-> COM ISSO, ESSA MUDANÇA,


FICA TIPO 

''WE START THE SESSIONS 
    WE PROCESS THE REQUESTS
    THEN, ON THE WAY OUT, WE _ SAVE THE SESSIONS AND 
    END IT...''








NA MAIOR PARTE DOS CASOS, ISSO NÃO É NECESSÁRIO,

MAS É BOM 


TER ISSO, TER ESTE FORMATO AQUI:





        session_start();

        $response = $handler->handle($request);

        session_write_close();

        return $response;










É BOM TER ISSO,


JUSTAMENTE PARA 


GARANTIR QUE O SCRIPT NÃO SERÁ 'HOLDED UP' POR LOCKS NA SESSION...
















-> CERTO...






ACABAMOS COM ESSE MIDDLEWARE, AGORA SÓ PRECISAMOS REGISTRÁ-LO,

LÁ NO ARQUIVO DE 'middleware.php',




nesse config...













TIPO ASSIM:










<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};










-> PODEMOS CHECAR SE A SESSION 

ESTÁ SENDO SALVA ADEQUADAMENTE...



basta fazer um var dump de 




'var_dump($_SESSION)'



EM QUALQUER 


PARTE DE SEUS CONTROLLERS, nos methods que retornam as views...








TIPO ASSIM:












    public function registerView(Request $request, Response $response): Response
    {
        var_dump($_SESSION);

        return $this->twig->render($response, 'auth/register.twig');
    }











CERTO... AÍ TESTAMOS...









E FUNCIONOU:







/var/www/app/Controllers/AuthController.php:31:
array (size=0)
  empty









--> FICAMOS COM 1 EMPTY ARRAY, INICIALMENTE...









-> ISSO É PQ 
    NENHUMA SESSION FOI SETTADA, AINDA...








--> SE TENTAMOS ENVIAR A NOSSA FORM VAZIA (inválida),


    ESSA SUPERGLOBAL DE '$_SESSION'

    É PREENCHIDA...













A MINHA NAO FOI, POR ALGUMA RAZÃO...







ACHO QUE FIZ ALGO DE ERRADO...









acho que é a ordem dos middlewares... acho que eu deveria ter colocado 

esse middleware de 'session' DEPOIS DOS OUTROS MIDDLEWARES...






não, não era esse o problema...






é algum throw e catch errado...















_> eu não tinha escrito aquele 


''         var_dump($v->errors());


'',



lá no AuthController, no catch block....













-> O QUE QUEREMOS FAZER, AQUI,


É SER CAPAZES DE 'PASS'

ESSES ERRORS AO VIEW,

SEMPRE QUE ACONTECEREM...






-> QUEREMOS OUTPUTTÁ-LOS NO TWIG TEMPLATE,

PARA QUE APAREÇAM 


NOS FIELDS RESPECTIVOS...










--> MAS COMO PODERÍAMOS FAZER ISSO?









-> UMA MANEIRA SERIA PASS DOWN 

OS 'SESSION ERRORS'


COMO PARAMETERS, EM 'registerView',


TIPO ASSIM:






    public function registerView(Request $request, Response $response): Response
    {
        var_dump($_SESSION, new DateTime());

        return $this->twig->render($response, 'auth/register.twig', ['errors' => $_SESSION['errors']] ??[]);
    }


















E ISSO FUNCIONARIA, SIM...












-> MAS HÁ UM DOWNSIDE NESSE APPROACH...










--> O DOWNSIDE É QUE TEREMOS DE FAZER ISSO PARA __ 
EVERY SINGLE VIEW QUE 

TIVERMOS...






--> TEREMOS QUE REPETIR ESSE CÓDIGO 

300x,

portanto...













-> UMA ALTERNATIVA A ISSO, MELHOR,

É UMA FEATURE DO TWIG...








--> ESSA FEATURE DO TWIG  TE PERMITE FAZER 

'PASS DOWN' DE ALGUNS PARAMETERS, globalmente...











-> O QUE PODEMOS FAZER, AQUI, COM ESSA FEATURE,

É CRIAR 1 OUTRO MIDDLEWARE QUE VAI 'GET THE ERRORS' 
LÁ DA SESSION, E ENTÃO VAI 'PASS THEM DOWN' 


A TODAS AS TWIG VIEWS, GLOBALMENTE...









--> PARA ISSO, PARA TER ESSE MIDDLEWARE,


CRIAMOS ELE EM 'Middleware'...










-> SERÁ O 'ValidationErrorsMiddleware'...








VAMOS ESCREVENDO ASSIM:







<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {

    }
}

















OK... AÍ, DENTRO DO METHOD,

PRECISAMOS:



1) CHECAR SE HÁ ALGUM ERROR DEFINIDO DENTRO DA '$_SESSION' SUPERGLOBAL...






com 


if(!empty($_SESSION['errors'])) {
    
}







SE HÁ ERRORS DENTRO DE ESSA SESSION SUPERGLOBAL,


PRECISAMOS PASSAR ESSES ERRORS, GLOBALMENTE,

A TODOS OS TWIG TEMPLATES...












-> E PODEMOS FAZER ISSO POR MEIO DO 



'->addGlobal()' method,

DENTRO DO TWIG ENVIRONMENT...







-> podemos fazer isso tipo assim:




if(!empty($_SESSION['errors'])) {
    
}










-> PRIMEIRAMENTE, PRECISAMOS DE ACESSO AO TWIG ENVIRONMENT...








-> PRECISAMOS DA TWIG INSTANCE,
NO CASO...








-> COMO JÁ INJETAMOS O TWIG NO NOSSO CONTAINER,

PODEMOS FAZER GET DE ESSA INSTANCE,


NO CONSTRUCTOR,

TIPO ASSIM:












<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {

    }
}














isso feito,




PODEMOS 



ESCREVER ASSIM, NO 'process()':






if(!empty($_SESSION['errors'])) {
    $this->twig->getEnvironment()
}











-> DEPOIS DISSO, CHAINAMOS '->getEnvironment()->addGlobal()'...











--> com ESSE METHOD,


podemos deixar a key como 'errors',


E AÍ PODEMOS DEFINIR O VALUE COMO SENDO 


'''

$_SESSION['errors'];



''


TIPO ASSIM:






<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
            
        if(!empty($_SESSION['errors'])) {
            $this->twig->getEnvironment()->addGlobal('errors', $_SESSION['errors']);
        }

    }
}














FICOU TIPO ASSIM:








<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler):Response
    {
            
        if(!empty($_SESSION['errors'])) {
            $this->twig->getEnvironment()->addGlobal('errors', $_SESSION['errors']);
        }

        return $handler->handle($request);
    }
}














CERTO... AGORA SÓ PRECISAMOS REGISTRAR ESSE MIDDLEWARE...




--> COLOCAMOS DEPOIS DO MIDDLEWARE DE VALIDATIONEXCEPTIONMIDDLEWARE,


TIPO ASSIM:




<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};

















CERTO...








AGORA PRECISAMOS OUTPUTTAR ISSO NO TWIG TEMPLATE...





SERÁ NO TWIG TEMPLATE 

'register.twig'...





TIPO ASSIM:
















<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
    <head>
        <meta charset="UTF-8">
        <title>{% block title %}Expennies{% endblock %}</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
        {% block stylesheets %}
            {{ encore_entry_link_tags('app') }}
        {% endblock %}

        {% block javascripts %}
            {{ encore_entry_script_tags('app') }}
        {% endblock %}
    </head>
    <body>
        <div class="container">
            <header class="d-flex flex-wrap justify-content-center py-3 mb-4">
                <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
                    <img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo" />
                    <span class="fs-1 fw-bold">Ex<span class="text-primary">pennies</span></span>
                </a>

                <ul class="nav nav-pills align-items-center">
                    <li class="nav-item"><a href="#" class="nav-link fw-bold fs-5 active" aria-current="page">Overview</a></li>
                    <li class="nav-item"><a href="#" class="nav-link fw-bold fs-5" aria-current="page">Transactions</a></li>
                    <li class="nav-item"><a href="#" class="nav-link fw-bold fs-5" aria-current="page">Categories</a></li>
                </ul>
            </header>
        </div>
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </body>
</html>















-> QUEREMOS OUTPUTTAR/DUMPAR 

OS ERRORS NO TEMPLATE...









-> fazemos isso com o markup 



{{  }}












ESCREVEMOS ASSIM:




{{ errors | json_encode  }}












-> ISSO VAI OUTPUTTAR NOSSOS ERRORS EM 1 FORMATO JSON...





certo..




fica tipo assim:














<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
	<head>
		<meta charset="UTF-8">
		<title>
			{% block title %}Expennies
			{% endblock %}
		</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
		{% block stylesheets %}
			{{ encore_entry_link_tags('app') }}
		{% endblock %}

		{% block javascripts %}
			{{ encore_entry_script_tags('app') }}
		{% endblock %}
	</head>
	<body>
		{{ errors | json_encode }}
		<div class="container">
			<header class="d-flex flex-wrap justify-content-center py-3 mb-4">
				<a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
					<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
					<span class="fs-1 fw-bold">Ex<span class="text-primary">pennies</span>
					</span>
				</a>

				<ul class="nav nav-pills align-items-center">
					<li class="nav-item">
						<a href="#" class="nav-link fw-bold fs-5 active" aria-current="page">Overview</a>
					</li>
					<li class="nav-item">
						<a href="#" class="nav-link fw-bold fs-5" aria-current="page">Transactions</a>
					</li>
					<li class="nav-item">
						<a href="#" class="nav-link fw-bold fs-5" aria-current="page">Categories</a>
					</li>
				</ul>
			</header>
		</div>
		<div class="container"> {% block content %}{% endblock %}
			</div>
		</body>
	</html>

















OK... 










CERTO...










AGORA ES´TA FUNCIONANDO,

ESTAMOS FICANDO COM ACCESS AOS ERRORS, DENTRO DO TWIG TEMPLATE,


MESMO SEM O 'PASS DOWN'  INDIVIDUAL,

EM CADA 1 DE NOSSOS CONTROLLERS... 














-> OK... TUDO QUE NOS RESTA 


É SIMPLESMENTE ACESSAR AS ERROR MESSAGES APROPRIADAS,



E DISPLAYAR EM CADA FIELD INDIVIDUAL...








-> PARA ISSO, O PROFESSOR VAI USAR A CLASS BOOTSTRAP 

'is-invalid',


PARA ADICIONAR STYLING EM CADA FIELD...









TIPO ASSIM:









{% block content %}
	{{ errors | json_encode }}
	<section class="vh-100 bg-primary bg-gradient">
		<div class="container py-5 h-100">
			<div class="row d-flex justify-content-center align-items-center h-100">
				<div class="col-12 col-md-8 col-lg-6 col-xl-5">
					<div class="card bg-light text-white" style="border-radius: 1rem;">
						<div class="card-body p-5 text-center">
							<div class="mb-4">
								<h2 class="fw-bold mb-5 text-uppercase text-primary d-flex justify-content-center align-items-center">
									<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
									Register
								</h2>
								<form method="post" action="/register">
									<div class="form-outline form-white mb-4">
										<input type="text" name="name" class="form-control form-control-lg {{ errors.name ? 'is-invalid' : ''}}" placeholder="Name"/>
									</div>
									<div class="invalid-feedback">
										{{ errors.name | first }}
									</div>










CERTO...








