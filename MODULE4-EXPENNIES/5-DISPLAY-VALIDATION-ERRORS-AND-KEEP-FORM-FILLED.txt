







NO ÚLTIMO VIDEO, ADICIONAMOS VALIDATION (FORM VALIDATION)

E VALIDATION HANDLING... 












NESTE VÍDEO,


PRECISAMOS FLASHAR OS ERRORS QUE RECEBEMOS DA VALIDATIONEXCEPTION,


TUDO PARA QUE CONSIGAMOS FAZER DISPLAY DELES,

DURANTE O PRÓXIMO REQUEST...















--> UMA MANEIRA DE FAZER PERSIST DE DATA,
    DE 1 REQUEST PARA OUTRO REQUEST,


    É POR MEIO DE _ SESSIONS_...











-> NOSSO CÓDIGO DE 'ValidationExceptionMiddleware',

ATUALMENTE,

ESTÁ ASSIM:






<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\ValidationException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class ValidationExceptionMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            // var_dump($e->errors());

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }
}











-->  ESSE MIDDLEWARE HANDLA O CATCHING DAS 
    VALIDATION EXCEPTIONS...








-> DENTRO DELE, PODEMOS FAZER ALGO COMO

 
 __ O _ SAVE_ DOS ERRORS, DENTRO DE 1 SESSION...







 -> PODEMOS FAZER ISSO POR MEIO __ DESTA SINTAXe:











     public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.

    
            $_SESSION['errors'] = $e->errors;

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }













--> OK... MAS NÓS SABEMOS, COM 100% DE CERTEZA,

QUE ISSO __ NÃO FUNCIONARÁ_...













--> MAS PQ?








--> É PQ 

    NÓS AINDA __ NÃO STARTAMOS SESSION ALGUMA,

    em lugar algum...











-> NA AULA 2.25, 

    SOBRE SESSIONS,


    APRENDEMOS 



    QUE 



    ''WE NEED TO START A SESSION,

    TO BE ABLE TO USE THE _ '$_SESSION' 

    SUPERGLOBAL...''









--> OK, MAS ONDE É UM BOM LUGAR PARA COMEÇAR NOSSA SESSION?











BONS LUGARES:




1) NO INÍCIO DO PROCESSO DE 
'bootstrap', lá em 'bootstrap.php'






2) TER 1 MIDDLEWARE QUE FAZ ISSO,   DEDICADO A ISSO...













-> O PROFESSOR PREFERE O APPROACH DO MIDDLEWARE,


POR ISSO ELE CRIA 1 NOVO MIDDLEWARE 



NA PASTA DE 'Middleware',


DE NOME 

'StartSessionsMiddleware'...











-> VAMOS ESCREVENDO ASSIM:









<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        $response = $this->responseFactory->createResponse();

        // $response = $response->withAddedHeader('Set-Cookie', 'PHPSESSID=1; path=/');

        return $handler->handle($request->withAttribute('response', $response));
    }
}
















-> MAS O PROFESSOR DIZ QUE PODEMOS COMEÇAR NOSSA SESSION 

COM O CALL DO METHOD DE 

'session_start()',


TIPO ASSIM:














<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        session_start();
    }
}













-> ISSO PODE PARECER BOM, SIM,


    MAS NÓS AINDA PRECISAMOS _ GARANTIR __ QUE 

    'SESSIONS HAVE NOT BEEN STARTED',


    antes de INICIARMOS 1 SESSION..








--> PRECISAMOS DE VÁRIOS IF-ELSE, PORTANTO...











-> NÓS TAMBÉM QUEREMOS GARANTIR QUE 

OS HEADERS 

NÃO FORAM ENVIADOS AINDA...









-> É POR ISSO QUE O PROFESSOR ESCREVE ASSIM:




<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
        }
    }
}













SE A SESSION JÁ ESTIVER COMO ACTIVE,

PODEMOS OU:



1) FAZER THROW DA EXCEPTION DIZENDO QUE A SESSION JÁ FOI STARTED 




2) USAR ISSO, PARA FAZER COM QUE 
    AS SESSIONS SEJAM STARTADAS APENAS 
    SE A SESSION NÃO É 'ACTIVE'...










-> O PROFESSOR QUER FAZER O THROW DA EXCEPTION JUSTAMENTE PQ 
ISSO DEVE _ (TECNICAMENTE) NUNCA ACONTECER... 

E, SE ISSO ACONTECER,

QUEREMOS FAZER CATCH DURANTE O DEVELOPMENT... PQ É UM EXCEPTIONAL
BEHAVIOR,


VAMOS QUERER FAZER CATCH PARA GARANTIR QUE NUNCA VAI ACONTECER NOVAMENTE...






EX:




    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new \SessionException('Session already started.');
        }
    }













OK... AÍ CRIAREMOS ESSA CLASS,


LÁ DENTRO DO 

namespace de 'Exception'...









ELA FARÁ EXTEND DA 'RuntimeException',

coisa básica:











<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\SessionException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new SessionException('Session already started.');
        }
    }
}














ok... 








isso feito, podemos checar se os headers já foram enviados,

com o 


method de 



'headers_sent()'...











--> ESSE METHOD TEM 2 REQUIRED ARGUMENTS:




1) filename 



2) line 






-> mas esses parameters 

podem ser 'empty variables'..







-> ESSAS VARIABLES ACABAM AUTOMATICAMENTE SET 


COMO OS VALUES DO 'filename' 

e 

'line' 


em que os headers já foram sent... vc pode loggar isso,
se quiser...






EX:








<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\SessionException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new SessionException('Session already started.');
        }

        if (headers_sent($filename, $line)) {  // these variables can be empty.
            throw new SessionException('Headers already sent.');
        }
    }
}












FINALMENTE, PODEMOS FAZER O START DA SESSION...







ASSIM:





<?php declare(strict_types=1);

namespace App\Middleware;

use App\Exception\SessionException;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class StartSessionsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            throw new SessionException('Session already started.');
        }

        if (headers_sent($filename, $line)) {  // these variables can be empty.
            throw new SessionException('Headers already sent.');
        }

        session_start();
    }
}









--> E É CLARO QUE, DEPOIS DISSO, QUEREMOS CONTINUAR 
PROCESSANDO O NOSSO REQUEST...







É POR ISSO QUE O PROFESSOR ESCREVE 



'''


$response = $handler->handle($request);




''',


que é o código normal dos middlewares, para 'passar o request adiante'...
















CERTO.... MAS DEPOIS DE CRIAR ESSA RESPONSE, PRECISAMOS 


FAZER __ SAVE__ DA SESSION/CLOSE DA SESSION,




TUDO PARA KINDOF 

'RELEASE THE LOCK'...












--> FAZEMOS ISSO PARA QUE, SE EXISTIREM QUAISQUER CONCURRENT 
WRITES A SESSION, ISSO NÃO VAI 'HOLD' O SCRIPT...









-> COM ISSO, ESSA MUDANÇA,


FICA TIPO 

''WE START THE SESSIONS 
    WE PROCESS THE REQUESTS
    THEN, ON THE WAY OUT, WE _ SAVE THE SESSIONS AND 
    END IT...''








NA MAIOR PARTE DOS CASOS, ISSO NÃO É NECESSÁRIO,

MAS É BOM 


TER ISSO, TER ESTE FORMATO AQUI:





        session_start();

        $response = $handler->handle($request);

        session_write_close();

        return $response;










É BOM TER ISSO,


JUSTAMENTE PARA 


GARANTIR QUE O SCRIPT NÃO SERÁ 'HOLDED UP' POR LOCKS NA SESSION...
















-> CERTO...






ACABAMOS COM ESSE MIDDLEWARE, AGORA SÓ PRECISAMOS REGISTRÁ-LO,

LÁ NO ARQUIVO DE 'middleware.php',




nesse config...













TIPO ASSIM:










<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};










-> PODEMOS CHECAR SE A SESSION 

ESTÁ SENDO SALVA ADEQUADAMENTE...



basta fazer um var dump de 




'var_dump($_SESSION)'



EM QUALQUER 


PARTE DE SEUS CONTROLLERS, nos methods que retornam as views...








TIPO ASSIM:












    public function registerView(Request $request, Response $response): Response
    {
        var_dump($_SESSION);

        return $this->twig->render($response, 'auth/register.twig');
    }











CERTO... AÍ TESTAMOS...









E FUNCIONOU:







/var/www/app/Controllers/AuthController.php:31:
array (size=0)
  empty









--> FICAMOS COM 1 EMPTY ARRAY, INICIALMENTE...









-> ISSO É PQ 
    NENHUMA SESSION FOI SETTADA, AINDA...








--> SE TENTAMOS ENVIAR A NOSSA FORM VAZIA (inválida),


    ESSA SUPERGLOBAL DE '$_SESSION'

    É PREENCHIDA...













A MINHA NAO FOI, POR ALGUMA RAZÃO...







ACHO QUE FIZ ALGO DE ERRADO...









acho que é a ordem dos middlewares... acho que eu deveria ter colocado 

esse middleware de 'session' DEPOIS DOS OUTROS MIDDLEWARES...






não, não era esse o problema...






é algum throw e catch errado...















_> eu não tinha escrito aquele 


''         var_dump($v->errors());


'',



lá no AuthController, no catch block....













-> O QUE QUEREMOS FAZER, AQUI,


É SER CAPAZES DE 'PASS'

ESSES ERRORS AO VIEW,

SEMPRE QUE ACONTECEREM...






-> QUEREMOS OUTPUTTÁ-LOS NO TWIG TEMPLATE,

PARA QUE APAREÇAM 


NOS FIELDS RESPECTIVOS...










--> MAS COMO PODERÍAMOS FAZER ISSO?









-> UMA MANEIRA SERIA PASS DOWN 

OS 'SESSION ERRORS'


COMO PARAMETERS, EM 'registerView',


TIPO ASSIM:






    public function registerView(Request $request, Response $response): Response
    {
        var_dump($_SESSION, new DateTime());

        return $this->twig->render($response, 'auth/register.twig', ['errors' => $_SESSION['errors']] ??[]);
    }


















E ISSO FUNCIONARIA, SIM...












-> MAS HÁ UM DOWNSIDE NESSE APPROACH...










--> O DOWNSIDE É QUE TEREMOS DE FAZER ISSO PARA __ 
EVERY SINGLE VIEW QUE 

TIVERMOS...






--> TEREMOS QUE REPETIR ESSE CÓDIGO 

300x,

portanto...













-> UMA ALTERNATIVA A ISSO, MELHOR,

É UMA FEATURE DO TWIG...








--> ESSA FEATURE DO TWIG  TE PERMITE FAZER 

'PASS DOWN' DE ALGUNS PARAMETERS, globalmente...











-> O QUE PODEMOS FAZER, AQUI, COM ESSA FEATURE,

É CRIAR 1 OUTRO MIDDLEWARE QUE VAI 'GET THE ERRORS' 
LÁ DA SESSION, E ENTÃO VAI 'PASS THEM DOWN' 


A TODAS AS TWIG VIEWS, GLOBALMENTE...









--> PARA ISSO, PARA TER ESSE MIDDLEWARE,


CRIAMOS ELE EM 'Middleware'...










-> SERÁ O 'ValidationErrorsMiddleware'...








VAMOS ESCREVENDO ASSIM:







<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {

    }
}

















OK... AÍ, DENTRO DO METHOD,

PRECISAMOS:



1) CHECAR SE HÁ ALGUM ERROR DEFINIDO DENTRO DA '$_SESSION' SUPERGLOBAL...






com 


if(!empty($_SESSION['errors'])) {
    
}







SE HÁ ERRORS DENTRO DE ESSA SESSION SUPERGLOBAL,


PRECISAMOS PASSAR ESSES ERRORS, GLOBALMENTE,

A TODOS OS TWIG TEMPLATES...












-> E PODEMOS FAZER ISSO POR MEIO DO 



'->addGlobal()' method,

DENTRO DO TWIG ENVIRONMENT...







-> podemos fazer isso tipo assim:




if(!empty($_SESSION['errors'])) {
    
}










-> PRIMEIRAMENTE, PRECISAMOS DE ACESSO AO TWIG ENVIRONMENT...








-> PRECISAMOS DA TWIG INSTANCE,
NO CASO...








-> COMO JÁ INJETAMOS O TWIG NO NOSSO CONTAINER,

PODEMOS FAZER GET DE ESSA INSTANCE,


NO CONSTRUCTOR,

TIPO ASSIM:












<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {

    }
}














isso feito,




PODEMOS 



ESCREVER ASSIM, NO 'process()':






if(!empty($_SESSION['errors'])) {
    $this->twig->getEnvironment()
}











-> DEPOIS DISSO, CHAINAMOS '->getEnvironment()->addGlobal()'...











--> com ESSE METHOD,


podemos deixar a key como 'errors',


E AÍ PODEMOS DEFINIR O VALUE COMO SENDO 


'''

$_SESSION['errors'];



''


TIPO ASSIM:






<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
            
        if(!empty($_SESSION['errors'])) {
            $this->twig->getEnvironment()->addGlobal('errors', $_SESSION['errors']);
        }

    }
}














FICOU TIPO ASSIM:








<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler):Response
    {
            
        if(!empty($_SESSION['errors'])) {
            $this->twig->getEnvironment()->addGlobal('errors', $_SESSION['errors']);
        }

        return $handler->handle($request);
    }
}














CERTO... AGORA SÓ PRECISAMOS REGISTRAR ESSE MIDDLEWARE...




--> COLOCAMOS DEPOIS DO MIDDLEWARE DE VALIDATIONEXCEPTIONMIDDLEWARE,


TIPO ASSIM:




<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};

















CERTO...








AGORA PRECISAMOS OUTPUTTAR ISSO NO TWIG TEMPLATE...





SERÁ NO TWIG TEMPLATE 

'register.twig'...





TIPO ASSIM:
















<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
    <head>
        <meta charset="UTF-8">
        <title>{% block title %}Expennies{% endblock %}</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
        {% block stylesheets %}
            {{ encore_entry_link_tags('app') }}
        {% endblock %}

        {% block javascripts %}
            {{ encore_entry_script_tags('app') }}
        {% endblock %}
    </head>
    <body>
        <div class="container">
            <header class="d-flex flex-wrap justify-content-center py-3 mb-4">
                <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
                    <img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo" />
                    <span class="fs-1 fw-bold">Ex<span class="text-primary">pennies</span></span>
                </a>

                <ul class="nav nav-pills align-items-center">
                    <li class="nav-item"><a href="#" class="nav-link fw-bold fs-5 active" aria-current="page">Overview</a></li>
                    <li class="nav-item"><a href="#" class="nav-link fw-bold fs-5" aria-current="page">Transactions</a></li>
                    <li class="nav-item"><a href="#" class="nav-link fw-bold fs-5" aria-current="page">Categories</a></li>
                </ul>
            </header>
        </div>
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </body>
</html>















-> QUEREMOS OUTPUTTAR/DUMPAR 

OS ERRORS NO TEMPLATE...









-> fazemos isso com o markup 



{{  }}












ESCREVEMOS ASSIM:




{{ errors | json_encode  }}












-> ISSO VAI OUTPUTTAR NOSSOS ERRORS EM 1 FORMATO JSON...





certo..




fica tipo assim:














<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
	<head>
		<meta charset="UTF-8">
		<title>
			{% block title %}Expennies
			{% endblock %}
		</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
		{% block stylesheets %}
			{{ encore_entry_link_tags('app') }}
		{% endblock %}

		{% block javascripts %}
			{{ encore_entry_script_tags('app') }}
		{% endblock %}
	</head>
	<body>
		{{ errors | json_encode }}
		<div class="container">
			<header class="d-flex flex-wrap justify-content-center py-3 mb-4">
				<a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
					<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
					<span class="fs-1 fw-bold">Ex<span class="text-primary">pennies</span>
					</span>
				</a>

				<ul class="nav nav-pills align-items-center">
					<li class="nav-item">
						<a href="#" class="nav-link fw-bold fs-5 active" aria-current="page">Overview</a>
					</li>
					<li class="nav-item">
						<a href="#" class="nav-link fw-bold fs-5" aria-current="page">Transactions</a>
					</li>
					<li class="nav-item">
						<a href="#" class="nav-link fw-bold fs-5" aria-current="page">Categories</a>
					</li>
				</ul>
			</header>
		</div>
		<div class="container"> {% block content %}{% endblock %}
			</div>
		</body>
	</html>

















OK... 










CERTO...










AGORA ES´TA FUNCIONANDO,

ESTAMOS FICANDO COM ACCESS AOS ERRORS, DENTRO DO TWIG TEMPLATE,


MESMO SEM O 'PASS DOWN'  INDIVIDUAL,

EM CADA 1 DE NOSSOS CONTROLLERS... 














-> OK... TUDO QUE NOS RESTA 


É SIMPLESMENTE ACESSAR AS ERROR MESSAGES APROPRIADAS,



E DISPLAYAR EM CADA FIELD INDIVIDUAL...








-> PARA ISSO, O PROFESSOR VAI USAR A CLASS BOOTSTRAP 

'is-invalid',


PARA ADICIONAR STYLING EM CADA FIELD...









TIPO ASSIM:









{% block content %}
	{{ errors | json_encode }}
	<section class="vh-100 bg-primary bg-gradient">
		<div class="container py-5 h-100">
			<div class="row d-flex justify-content-center align-items-center h-100">
				<div class="col-12 col-md-8 col-lg-6 col-xl-5">
					<div class="card bg-light text-white" style="border-radius: 1rem;">
						<div class="card-body p-5 text-center">
							<div class="mb-4">
								<h2 class="fw-bold mb-5 text-uppercase text-primary d-flex justify-content-center align-items-center">
									<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
									Register
								</h2>
								<form method="post" action="/register">
									<div class="form-outline form-white mb-4">
										<input type="text" name="name" class="form-control form-control-lg {{ errors.name ? 'is-invalid' : ''}}" placeholder="Name"/>
									</div>
									<div class="invalid-feedback">
										{{ errors.name | first }}
									</div>










CERTO...



















-> TEMOS QUE TENTAR FAZER ISSO FUNCIONAR 

POR CONTA PRÓPRIA...






--> FAZER OS OUTROS FIELDS FUNCIONAREM...








--> BASTA ESCREVER ALGO ASSIM:









{% extends 'auth/layout.twig' %}

{% block title %}Register
{% endblock %}

{% block content %}
	{{ errors ? errors | json_encode : '' }}
	<section class="vh-100 bg-primary bg-gradient">
		<div class="container py-5 h-100">
			<div class="row d-flex justify-content-center align-items-center h-100">
				<div class="col-12 col-md-8 col-lg-6 col-xl-5">
					<div class="card bg-light text-white" style="border-radius: 1rem;">
						<div class="card-body p-5 text-center">
							<div class="mb-4">
								<h2 class="fw-bold mb-5 text-uppercase text-primary d-flex justify-content-center align-items-center">
									<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
									Register
								</h2>
								<form method="post" action="/register">
									<div class="form-outline form-white mb-4">
										<input type="text" name="name" class="form-control form-control-lg {{ errors.name ? 'is-invalid' : ''}}" placeholder="Name"/>
                                        <div class="invalid-feedback">
										        {{ errors.name | first }}
									     </div>
									</div>
									<div class="form-outline form-white mb-4">
										<input type="email" name="email" class="form-control form-control-lg {{ errors.email ? 'is-invalid' : ''}}" placeholder="Email"/>
                                        <div class="invalid-feedback">
										    {{ errors.email | first }}
									    </div>
                                    </div>
									<div class="form-outline form-white mb-4">
										<input type="password" name="password" class="form-control form-control-lg {{ errors.password ? 'is-invalid' : ''}}" placeholder="Password"/>
                                        <div class="invalid-feedback">
										    {{ errors.password | first }}
									    </div>
									</div>
									<div class="form-outline form-white mb-5">
										<input type="password" name="confirmPassword" class="form-control form-control-lg {{ errors.confirmPassword ? 'is-invalid' : ''}}" placeholder="Confirm Password"/>
                                        <div class="invalid-feedback">
										    {{ errors.confirmPassword | first }}
									    </div>
									</div>
									<button class="btn btn-primary bg-gradient text-white btn-lg px-5" type="submit">
										Register
									</button>
								</form>
							</div>
							<div>
								<p class="mb-0 text-dark">Have an account?
									<a href="/login" class="text-primary fw-bold">Sign In</a>
								</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>
{% endblock %}













com isso, refreshamos a page, e ficamos com 1 nice ui em cada 

1 dos fields...












-> CERTO...





-> MAS PROVAVELMENTE QUEREMOS FAZER OS ERRORS 


'GO AWAY'

NO PRÓXIMO REFRESH DE PÁGINA..









ISSO PQ, ATUALMENTE, ELES NÃO ESTÃO INDO EMBORA 

DEPOIS DO PRIMEIRO REFRESH... ISSO PQ ESTÃO FICANDO SALVOS 


NA '$_SESSION' DE NOSSO APP...















-> O PROFESSOR QUER QUE ESSES ERRORS SEJAM DISPLAYADOS 
APENAS UMA ÚNICA VEZ,


E DEPOIS SUMAM...














--> É PARECIDO COM O EXPRESS-FLASH, PORTANTO...






-> ''WHAT WE CAN DO, IN THIS CASE,

IS ___ UNSET__ THE ERRORS, WITHIN THE SESSION,
 
 AFTER WE RETRIEVE THE SESSION, IN THE 'ValidationErrorsMiddleware'...











TIPO ASSIM:









           
        if(!empty($_SESSION['errors'])) { // insert errors, if any, into the twig template global (errors taken from the $_SESSION superglobal).
            
            $errors = $_SESSION['errors'];
            
            $this->twig->getEnvironment()->addGlobal('errors', $errors);
        }

    


TEMOS ESSE CÓDIGO, SIM...






AÍ, DEPOIS DE ADICIONAR ISSO AO CONTEXTO GLOBAL DE NOSSAS VIEWS,

PODEMOS SIMPLESMENTE FAZER UNSET DE ESSA VARIABLE CONTENDO OS VALUES DE '$_SESSION['errors']
',

COM 'unset()':










<?php declare(strict_types=1);

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;
use Slim\Views\Twig;

class ValidationErrorsMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler):Response
    {

        if (isset($_SESSION['errors'])) {
         var_dump($_SESSION['errors']);
        } else {
            var_dump('EMPTY');
        }
           
        if(!empty($_SESSION['errors'])) { // insert errors, if any, into the twig template global (errors taken from the $_SESSION superglobal).
            
            $errors = $_SESSION['errors'];
            
            $this->twig->getEnvironment()->addGlobal('errors', $errors);

            unset($errors); /// We do this so that the errors are 'flashed' (in other words, they disappear after being shown only once).
        }

        return $handler->handle($request);
    }
}
















CERTO... E ISSO FUNCIONOU...




OS ERRORS ESTARÃO GONE,
TODA VEZ QUE REFRESHARMOS A PAGE,

DEPOIS DE FICARMOS COM AS MENSAGENS DE ERROR/VALIDATION 

EM CADA INPUT FIELD...
















-> CERTO... AGORA O PROFESSOR PREENCHE 

OS FIELDS NORMALMENTE....






-> E A VALIDATION FUNCIONA.....






->  OK, MAS AÍ O PROFESSOR 


NOS APONTA 1 PROBLEMA:
















'''WHENEVER I GET REDIRECTED FOR FALING 

THE AUTH PROCESS,


I GET TO SEE WHICH FIELDS WERE WRONG, YES...''







--> MAS O PROBLEMA, AQUI,

    É QUE _ AS COISAS QUE TÍNHAMOS DIGITADO 

    NOS INPUT FIELDS __ VÃO SUMIR...





    E ISSO É RUIM, PQ O USER TERÁ DE INPUTTAR 

    COISAS NO INPUT VALUE DE NOVO....
















IMAGINE QUE VC TEM 20 INPUT FIELDS... VC TERIA DE PREENCHER 
TUDO DE NOVO...








--> OK... É POR ISSO QUE QUEREMOS MANTER 


OS INPUT FIELDS PREENCHIDOS, MESMO QUANDO O USER É REDIRECIONADO 
BACK TO THIS REGISTER PAGE, DEVIDO A VALIDATION ERRORS,



PARA TER 1 MELHOR USER EXPERIENCE...












--> MSA COMO OPDEMOS FAZER ISSO?







-> DENTRO DO MIDDLEWARE DE 'ValidationExceptionMiddleware',


    NO TRECHO EM QUE FAZEMOS ADD DOS ERRORS À SESSION,


    QUE É AQUI:










    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.


            $_SESSION['errors'] = $e->getErrors();  // * stores the errors in the $_SESSION superglobal, so that they can be displayed in the template.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }






    EM '$_SESSION['errors'],


PODEMOS FAZER O SET, NESSE SUPER GLOBAL DE '$_SESSION',


TAMBÉM 



DA POST DATA DO REQUEST...








--> DESSA FORMA,
 
    A POST DATA FICARÁ DISPONÍVEL 

    DENTRO DO PRÓXIMO REQUEST,



    MESMO APÓS O USER SER REDIRECIONADO...
    












    -> para isso, podemos escrever assim:








'$_SESSION['old'] => $request->getParsedBody();








CERTO...














COM ISSO, PRECISAMOS FAZER 

ESSA DATA FUNCIONAR COM O TWIG TEMPLATE...










--> ESSENCIALMENTE,

TEMOS QUE FAZER A MESMA COISA QUE FIZEMOS COM O 'ValidationExceptionMiddleware'...








-> COMEÇAMOS ASSIM:









class ValidationExceptionMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.

            $_SESSION['errors'] = $e->errors();  // * stores the errors in the $_SESSION superglobal, so that they can be displayed in the template.
            $_SESSION['old'] = $request->getParsedBody();  // * stores the old form data in the $_SESSION superglobal, so that it can be displayed in the template.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }
}















OU SEJA,

AGORA TEREMOS 2 KEYS:



$_SESSION['errors'] = $e->errors();  // * stores the errors in the $_SESSION superglobal, so that they can be displayed in the template.
$_SESSION['old'] = $request->getParsedBody();  // * stores the old form data in the $_SESSION superglobal, so that it can be displayed in the template.













-> AGORA PRECISAMOS DE OUTRO MIDDLEWARE, 1 MIDDLEWARE 
PARA HANDLAR ESSA OLD DATA,



COLOCAR ELA NOS NOSSOS INPUT FIELDS...









-> É POR ISSO QUE DUPLICAMOS 'ValidationErrorsMiddleware',



E AÍ 



COLOCAMOS 1 NOME DE 'OldFormDataMiddleware'...









AÍ ESCREVEMOS ASSIM:












class OldFormDataMiddleware implements MiddlewareInterface {
    public function __construct(private ResponseFactory $responseFactory, private readonly Twig $twig) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {

        if (!empty($_SESSION['old'])) { // insert errors, if any, into the twig template global (errors taken from the $_SESSION superglobal).

            $old = $_SESSION['old'];


            $this->twig->getEnvironment()->addGlobal('old', $old);
            unset($_SESSION['old']); /// We do this so that the errors are 'flashed' (in other words, they disappear after being shown only once).

        }

        return $handler->handle($request);
    }
}











DEPOIS DISSO, REGISTRAMOS ESSE MIDDLEWARE, ASSIM:








<?php declare(strict_types=1);

use App\Config;
use Slim\Views\Twig;
use Slim\Views\TwigMiddleware;
use Slim\App;

return function (App $app) {
    $container = $app->getContainer();
    $config = $container->get(Config::class);

    // Twig
    $app->add(TwigMiddleware::create($app, $container->get(Twig::class)));

    // Custom Validation Exception Middleware:
    $app->add(\App\Middleware\ValidationExceptionMiddleware::class);

    // Custom Validation Errors Middleware:
    $app->add(\App\Middleware\ValidationErrorsMiddleware::class);

    // Custom Old Form Data Middleware:
    $app->add(\App\Middleware\OldFormDataMiddleware::class);

    // Session Middleware:
    $app->add(\App\Middleware\StartSessionsMiddleware::class);

    // Logger
    $app->addErrorMiddleware(
        (bool) $config->get('display_error_details'),
        (bool) $config->get('log_errors'),
        (bool) $config->get('log_error_details')
    );
};
















DEPOIS DISSO,

NO TEMPLATE DE register.twig,









PODEMOS ACESSAR ESSES VALUES 

com 


'value="{{ old.name }}"



e etc etc...





TIPO ASSIM:








{% extends 'auth/layout.twig' %}

{% block title %}Register
{% endblock %}

{% block content %}
	<section class="vh-100 bg-primary bg-gradient">
		<div class="container py-5 h-100">
			<div class="row d-flex justify-content-center align-items-center h-100">
				<div class="col-12 col-md-8 col-lg-6 col-xl-5">
					<div class="card bg-light text-white" style="border-radius: 1rem;">
						<div class="card-body p-5 text-center">
							<div class="mb-4">
								<h2 class="fw-bold mb-5 text-uppercase text-primary d-flex justify-content-center align-items-center">
									<img src="{{ asset('build/images/logo.png') }}" width="64" height="64" alt="Expennies Logo"/>
									Register
								</h2>
								<form method="post" action="/register">
									<div class="form-outline form-white mb-4">
										<input type="text" 
										name="name" 
										class="form-control form-control-lg {{ errors.name ? 'is-invalid' : ''}}" 
										placeholder="Name"
										value="{{old.name}}"
										/>
										<div class="invalid-feedback">
											{{ errors.name | first }}
										</div>
									</div>

									<div class="form-outline form-white mb-4">
										<input type="email" 
										name="email" 
										class="form-control form-control-lg {{ errors.email ? 'is-invalid' : ''}}" 
										placeholder="Email"
										value="{{old.email}}"
										/>
										<div class="invalid-feedback">
											{{ errors.email | first }}
										</div>
									</div>

									<div class="form-outline form-white mb-4">
										<input type="password" 
										name="password" 
										class="form-control form-control-lg {{ errors.password ? 'is-invalid' : ''}}" 
										placeholder="Password"
										/>
										<div class="invalid-feedback">
											{{ errors.password | first }}
										</div>
									</div>

									<div class="form-outline form-white mb-5">
										<input 
										type="password" 
										name="confirmPassword" 
										class="form-control form-control-lg {{ errors.confirmPassword ? 'is-invalid' : ''}}" 
										placeholder="Confirm Password"/>
										<div class="invalid-feedback">
											{{ errors.confirmPassword | first }}
										</div>
									</div>

									<button class="btn btn-primary bg-gradient text-white btn-lg px-5" type="submit">
										Register
									</button>
								</form>
							</div>
							<div>
								<p class="mb-0 text-dark">Have an account?
									<a href="/login" class="text-primary fw-bold">Sign In</a>
								</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>
{% endblock %}



















ENTRETANTO, APONTA O PROFESSOR,


É CONSIDERADA UMA GOOD PRACTICE __ NÃO FLASHAR__ PASSWORD 


VALUES EM SESSIONS...







--> É POR ISSO QUE VAMOS TENTAR _ REMOVER__ OS VALUES DE 'password' 

e 'confirmPassword'



do array extraído de '$_POST',

de alguma maneira...












--> MAS COMO PODEMOS FAZER ISSO?





--> NÃO QUEREMOS STORE QUALQUER TIPO DE SENSITIVE DATA 
    DENTRO 

    DA SESSION, BASICAMENTE...







--> certo, mas como podemos fazer isso?









-> HÁ DIVERSAS MANEIRAS PELAS QUAIS PODEMOS FAZER ISSO....











-> QUEREMOS EXCLUIR ALGUNS FIELDS DE SEREM FLASHADOS À SESSION...








PARA ISSO, VAMOS ATÉ ESTE TRECHO:



class ValidationExceptionMiddleware implements MiddlewareInterface
{
    public function __construct(private ResponseFactory $responseFactory) {}

    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.

            $_SESSION['errors'] = $e->errors();  // * stores the errors in the $_SESSION superglobal, so that they can be displayed in the template.
            $_SESSION['old'] = $request->getParsedBody();  // * stores the old form data in the $_SESSION superglobal, so that it can be displayed in the template.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }
}












-> O PROFESSOR COLOCA A DATA em 1 variable, '$oldData',

e aí ele chama o method de 'unset'

PARA REMOVER ALGUMAS DAS KEYS DE ESSA VARIABLE,

TIPO ASSIM:



    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.
            $oldData = $request->getParsedBody();

            // Remove the 'password' and 'confirmPassword' fields from the old data, because they are not needed in the template.
            unset($oldData['password']);
            unset($oldData['confirmPassword']);

            $_SESSION['errors'] = $e->errors();  // * stores the errors in the $_SESSION superglobal, so that they can be displayed in the template.
            $_SESSION['old'] = $oldData;  // * stores the old form data in the $_SESSION superglobal, so that it can be displayed in the template.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }











poderíamos escrever assim,


mas o professor quer usar outro approach...








--> O PROFESSOR QUER USAR 
    ARRAY FUNCTIONS, PARA FILTRAR 

    AS KEYS QUE EXISTEM DENTRO DE ESSE ARRAY...










TIPO ASSIM:







    public function process(Request $request, RequestHandlerInterface $handler): Response
    {
        try {
            return $handler->handle($request);
        } catch (ValidationException $e) {
            $response = $this->responseFactory->createResponse();

            $referer = $request->getServerParams()['HTTP_REFERER'];  // * gets the 'Referer' header, which contains the URL of the page that the user was trying to access.
            $oldData = $request->getParsedBody();

            // Use this Info/list to remove the 'password' and 'confirmPassword' fields from the old data, because they are not needed in the template.
            $sensitiveFields = ['password', 'confirmPassword'];

            $_SESSION['errors'] = $e->errors();  // * stores the errors in the $_SESSION superglobal, so that they can be displayed in the template.
            $_SESSION['old'] = array_diff_key($oldData, array_flip($sensitiveFields));  // * stores the old form data in the $_SESSION superglobal, so that it can be displayed in the template.

            return $response->withHeader('Location', $referer);  // This will redirect the user back to the 'register' page (the page that the user was trying to access, to be more precise)...
        }
    }












    USAMOS 'array_diff_key()'...






-> O PRIMEIRO ARGUMENT SERÁ A DATA INTEIRA ($oldData)..







-> 'array_flip()' -> o que isso faz é FLIPPAR 
                        AS KEYS E VALUES...

                        O value era 'password' antes... 
                        depois dessa function, vai se tornar a key do array...
                        (e não o value)






-> já 'array_diff_key()'

vai computar a DIFERENÇA, COM BASE NA KEY....






-> e como 'oldData' possui 

coisas como 



password => 'seuValue' 

confirmPassword => 'seuOutroValue',




ESSAS 2 KEYS, 'password' e 'confirmPassword',


SERÃO COMPARADAS COM O ARRAY DE '$sensitiveFields' FLIPPADO,



O QUE VAI ACABAR REMOVENDO ESSAS 2 KEYS,


PQ ESSAS 2 KEYS TAMBÉM EXISTEM NO SEGUNDO ARRAY, DE '$sensitiveFields'...


















--> É CLARO QUE HÁ LUGARES MELHORES PARA ARMAZENAR 

ESSE ARRAY DE '$sensitiveFields',



mas mudaremos isso mais tarde...














-> ok... com isso, apenas o name e email ficarão contidos na session...












O CÓDIGO NÃO ESTÁ MT BONITO, MAS ESTÁ FUNCIONANDO..








O QUE INTERESSA:





1) USER REGISTRATION IS WORKING 



2) VALIDATION IS WORKING 


3) USER IS ABLE TO LOG IN AND LOG OUT...











-> AGORA VAMOS QUERER REFATORAR 1 POUCO, NA PRÓXIMA AULA...